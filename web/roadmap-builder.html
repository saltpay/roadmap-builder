<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>üó∫Ô∏è Roadmap Builder</title>
    <!-- Link to external CSS file -->
    <link rel="stylesheet" href="./styles.css">
    
    <!-- Import DateUtility for centralized date handling -->
            <script src="./utilities/date-utility.js"></script>
    
    <!-- Import UIUtility for centralized UI generation -->
            <script src="./utilities/ui-utility.js"></script>
    
    <!-- Import ConfigUtility for centralized configuration -->
            <script src="./utilities/config-utility.js"></script>
    
    <!-- Import IMO Utilities for cross-team search -->
    <script src="./utilities/imo-utility.js"></script>
    <script src="./utilities/imo-view-generator.js"></script>
    
    <!-- Layout Toggle Styles -->
    <style>
        /* Horizontal layout with file browser, builder, and preview */
        .builder-container {
            display: flex;
            flex-direction: row;
            min-height: 100vh;
            gap: 20px;
            padding: 10px;
        }
        
        /* File Browser Panel */
        .file-browser-panel {
            width: 200px;
            background: white;
            border: 2px solid #007cba;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
            overflow: hidden;
            flex-shrink: 0;
        }
        
        .file-browser-panel.collapsed {
            width: 0px;
            border: none;
            padding: 0;
            margin: 0;
            min-width: 0;
        }
        
        .file-browser-header {
            background: #007cba;
            color: white;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
        }
        
        .file-browser-header h3 {
            margin: 0;
            font-size: 16px;
            color: white;
        }
        
        .file-browser-panel.collapsed .file-browser-header {
            display: none;
        }
        
        .collapse-btn {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 2px;
            margin: 0;
            line-height: 1;
            transform: translateY(-10px) translateX(10px);
        }
        
        .file-browser-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }
        
        .file-browser-panel.collapsed .file-browser-content {
            display: none;
        }
        
        /* Expand file browser button (shown with builder controls) */
        .expand-file-browser-btn {
            background: none;
            border: none;
            color: #007cba;
            font-size: 11px;
            cursor: pointer;
            padding: 4px 8px;
            margin-right: 10px;
            display: none;
            line-height: 1;
        }
        
        .expand-file-browser-btn:hover {
            color: #007cba;
            background: none;
        }
        
        .expand-file-browser-btn.visible {
            display: inline-block;
        }
        
        .file-browser-actions {
            margin-bottom: 15px;
        }
        
        .file-list {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-left: 2px solid transparent;
            font-family: 'Courier New', monospace;
        }
        
        .file-item:hover {
            background-color: #f0f8ff;
            border-left-color: #007cba;
        }
        
        .file-item-icon {
            margin-right: 8px;
            font-size: 14px;
            width: 16px;
            text-align: center;
        }
        
        .file-item-info {
            flex: 1;
        }
        
        .file-item-name {
            font-weight: normal;
            color: #333;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
        }
        
        .file-item::before {
            content: "‚îú‚îÄ ";
            color: #666;
            font-size: 12px;
            margin-right: 4px;
        }
        
        .file-item:last-child::before {
            content: "‚îî‚îÄ ";
        }
        
        .no-directory-message {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }
        
        .directory-path {
            font-size: 12px;
            color: #333;
            margin-bottom: 8px;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            padding: 4px 8px;
            border-bottom: 1px solid #ddd;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }
        
        .builder-panel {
            width: 100%;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #cfd8dc;
            flex: 1;
            min-height: 0;
            transition: all 0.3s ease;
        }
        
        .preview-panel {
            width: 100%;
            height: 70vh;
            min-height: 600px;
            overflow: auto;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }
        
        /* Collapsed builder - minimize to just header */
        .builder-panel.collapsed {
            flex: none;
            height: auto;
            overflow: hidden;
        }
        
        .builder-panel.collapsed > *:not(.header-with-buttons) {
            display: none;
        }
        
        /* When builder collapsed, expand preview */
        .builder-panel.collapsed + .preview-panel {
            height: calc(100vh - 80px);
            flex: 1;
        }
        

        
        /* Ensure iframe fills container properly in both layouts */
        .preview-panel {
            min-height: 600px;
        }
        
        #preview-area {
            width: 100%;
            height: 1000px;
            border: none;
        }
        
        /* In preview-first layout, make iframe responsive to container height */
        .builder-container.preview-first-layout #preview-area {
            height: 100%;
            min-height: 600px;
        }

        /* Builder Panel Drag and Drop */
        .builder-panel {
            transition: all 0.3s ease;
        }

        .builder-panel.drag-over {
            background: rgba(0, 123, 186, 0.03);
            border: 2px dashed #007cba;
            border-radius: 8px;
        }

        .builder-panel.drag-over::before {
            content: 'üìÅ Drop roadmap file anywhere on this form (.json)';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 123, 186, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            pointer-events: none;
            white-space: nowrap;
        }

        /* Auto-filled timeline change date fields styling */
        .auto-filled {
            font-style: italic;
            color: #666;
        }

        /* Fullscreen button label visibility */
        .fullscreen-button {
            color: #111;
        }
        .fullscreen-button .fullscreen-label {
            font-size: 12px;
            margin-left: 6px;
            color: #111;
        }

        /* Bar chart expand/collapse styles */
        .bar-chart-container[data-tooltip="breakdown"]:hover {
            background: #e5e7eb !important;
        }
        
        .expand-chevron {
            display: inline-block;
            transition: transform 0.2s ease;
        }
        
        .bar-chart-container:hover .expand-chevron {
            color: #374151;
        }
    </style>
</head>
<body>


    <div class="builder-container">
        <!-- File Browser Panel -->
        <div class="file-browser-panel collapsed" id="fileBrowserPanel">
            <div class="file-browser-header">
                <h3>üìÅ Roadmap Files</h3>
                <button onclick="toggleFileBrowser()" class="collapse-btn" id="fileBrowserToggle" title="Close File Browser">√ó</button>
            </div>
            <div class="file-browser-content" id="fileBrowserContent">
                <div class="file-browser-actions">
                    <button onclick="selectDirectory()" class="secondary" style="width: 100%; margin-bottom: 10px;">
                        üìÇ Select Folder
                    </button>
                </div>
                <div class="file-list" id="fileList">
                    <div class="no-directory-message">
                        Click "Select Folder" to browse your roadmap files
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main Content (Builder + Preview) -->
        <div class="main-content">
            <!-- Builder Panel -->
            <div class="builder-panel">
            <div class="header-with-buttons">
                <div style="margin-bottom: 10px;">
                    <button class="expand-file-browser-btn visible" id="expandFileBrowserBtn" onclick="toggleFileBrowser()" title="Show File Browser">
                        ‚ñ∂ Show Files
                    </button>
                    <button onclick="toggleBuilderCollapse()" id="builderCollapseBtn" class="secondary" style="font-size: 12px; padding: 4px 8px; background: none; border: none; color: #007cba; cursor: pointer;">‚ñ≤ Hide Builder</button>
                </div>
                <div class="title-and-buttons">
                    <h1 style="margin: 0; padding: 0; text-align: left;"><span id="roadmapIcon">üó∫Ô∏è</span> Roadmap Builder</h1>
                    <div class="top-action-buttons">
                    <button onclick="newRoadmap()" class="secondary">üÜï New Roadmap</button>
                    <button onclick="loadRoadmap()" class="secondary">üìÇ Load Roadmap</button>
                    <button onclick="saveRoadmap()" class="secondary">üíæ Save Roadmap</button>
                    <button onclick="openIMOSearch()" class="secondary">üîç Search</button>
                    <button onclick="openStatsModal()" class="secondary">üìä Stats</button>
                    <style>
                        .dropdown-content {
                            display: none;
                            position: absolute;
                            background: #f8f9fa;
                            min-width: 120px;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                            z-index: 10000;
                            right: 0;
                            top: 100%;
                            border-radius: 6px;
                            border: 1px solid #cfd8dc;
                            padding: 4px 0;
                        }
                        .dropdown-content a {
                            display: block;
                            color: #222;
                            background: none;
                            padding: 8px 18px;
                            text-decoration: none;
                            font-family: inherit;
                            font-size: 15px;
                            border: none;
                            border-radius: 0;
                            transition: background 0.15s;
                            cursor: pointer;
                        }
                        .dropdown-content a:hover {
                            background: #e0e0e0;
                            color: #007cba;
                        }
                        .dropdown .secondary {
                            border-radius: 6px 6px 6px 6px;
                        }
                    </style>
                    <div class="dropdown" style="display: inline-block; position: relative;">
                        <button id="shareDropdownBtn" class="secondary" onclick="toggleShareDropdown(event)">üåê Share ‚ñº</button>
                        <div id="shareDropdownMenu" class="dropdown-content">
                            <a href="#" onclick="exportHTML(); closeShareDropdown(); return false;">HTML</a>
                            <a href="#" onclick="exportJPG(); closeShareDropdown(); return false;">JPG</a>
                            <a href="#" onclick="exportPDF(); closeShareDropdown(); return false;">PDF</a>
                        </div>
                    </div>
                        <!-- html-to-image for JPG export -->
                    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js"></script>
                    <!-- jsPDF for PDF export -->
                    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script>
    // --- Share Dropdown Logic ---
    function toggleShareDropdown(event) {
        event.stopPropagation();
        const menu = document.getElementById('shareDropdownMenu');
        const builderPanel = document.querySelector('.builder-panel');
        
        if (menu.style.display === 'block') {
            menu.style.display = 'none';
            return;
        }
        
        // Check if builder is collapsed
        const isCollapsed = builderPanel.classList.contains('collapsed');
        
        if (isCollapsed) {
            // When collapsed, use fixed positioning to drop down below button
            const shareButton = document.getElementById('shareDropdownBtn');
            const buttonRect = shareButton.getBoundingClientRect();
            
            // Position dropdown below the button using fixed positioning
            menu.style.position = 'fixed';
            menu.style.top = (buttonRect.bottom + 2) + 'px';  // 2px below button
            menu.style.left = (buttonRect.right - 120) + 'px';  // Align with right edge of button
            menu.style.right = 'auto';
            menu.style.bottom = 'auto';
        } else {
            // When expanded, use normal relative positioning
            menu.style.position = 'absolute';
            menu.style.top = '100%';
            menu.style.left = 'auto';
            menu.style.right = '0';
            menu.style.bottom = 'auto';
        }
        
        menu.style.display = 'block';
        
        // Close on outside click
        setTimeout(() => {
            document.addEventListener('click', closeShareDropdown, { once: true });
        }, 0);
    }
    function closeShareDropdown() {
        const menu = document.getElementById('shareDropdownMenu');
        if (menu) menu.style.display = 'none';
    }

    // --- Bottom Share Dropdown Logic ---
    function toggleShareDropdownBottom(event) {
        event.stopPropagation();
        const menu = document.getElementById('shareDropdownMenuBottom');
        
        if (menu.style.display === 'block') {
            menu.style.display = 'none';
            return;
        }
        
        // Position dropdown to open upward (above the button) to avoid iframe obstruction
        menu.style.position = 'absolute';
        menu.style.top = 'auto';
        menu.style.left = 'auto';
        menu.style.right = '0';
        menu.style.bottom = '100%';
        
        menu.style.display = 'block';
        
        // Close on outside click
        setTimeout(() => {
            document.addEventListener('click', closeShareDropdownBottom, { once: true });
        }, 0);
    }

    function closeShareDropdownBottom() {
        const menu = document.getElementById('shareDropdownMenuBottom');
        if (menu) menu.style.display = 'none';
    }

    // --- Export as JPG ---
    async function exportJPG() {
        // Find the preview iframe and get its document
        const iframe = document.getElementById('preview-area');
        if (!iframe || !iframe.contentWindow || !iframe.contentDocument) {
            alert('Preview not available.');
            return;
        }
        const previewDoc = iframe.contentDocument;
        // Try to find the main roadmap content (assume full document)
        // Use the HTML element for true full height/width
        const htmlElem = previewDoc.documentElement;
        if (!htmlElem) {
            alert('Preview not available.');
            return;
        }
        try {
            // Get the true full scrollable size (html > body)
            const width = Math.max(htmlElem.scrollWidth, htmlElem.offsetWidth, htmlElem.clientWidth, 1200);
            // Add extra padding to height to avoid clipping bottom
            const height = Math.max(htmlElem.scrollHeight, htmlElem.offsetHeight, htmlElem.clientHeight, 800) + 32;
            // Clone the HTML element for rendering
            const clone = htmlElem.cloneNode(true);
            clone.style.background = '#fff';
            clone.style.overflow = 'visible';
            clone.style.width = width + 'px';
            clone.style.height = height + 'px';
            // Container for offscreen rendering
            const container = document.createElement('div');
            container.style.position = 'fixed';
            container.style.left = '-9999px';
            container.style.top = '0';
            container.style.background = '#fff';
            container.style.width = width + 'px';
            container.style.height = height + 'px';
            container.appendChild(clone);
            document.body.appendChild(container);
            
            // Hide edit icons in the clone for JPG export
            const style = document.createElement('style');
            style.textContent = `
                .edit-icon,
                .monthly-edit-icon {
                    display: none !important;
                }
            `;
            clone.appendChild(style);
            
            // Wait for images/fonts to load (best effort)
            await new Promise(resolve => setTimeout(resolve, 200));
            const dataUrl = await window.htmlToImage.toJpeg(clone, { quality: 0.95, backgroundColor: '#fff', width, height });
            
            // Get team name and year for default filename
            const teamName = document.getElementById('teamName').value.trim() || 'MyTeam';
            const roadmapYear = document.getElementById('roadmapYear').value || '2025';
            const defaultFilename = `${teamName}.Teya-Roadmap.${roadmapYear}.jpg`;
            
            // Try to use File System Access API for save dialog (if supported)
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: defaultFilename,
                        types: [{
                            description: 'JPEG images',
                            accept: { 'image/jpeg': ['.jpg', '.jpeg'] }
                        }]
                    });
                    
                    // Convert dataUrl to blob
                    const response = await fetch(dataUrl);
                    const blob = await response.blob();
                    
                    // Write to file
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    
                    document.body.removeChild(container);
                    return;
                } catch (err) {
                    // If user cancelled, don't do anything
                    if (err.name === 'AbortError') {
                        document.body.removeChild(container);
                        return;
                    }
                    
                    // For other errors, fall back to automatic download
                }
            }
            
            // Fallback: automatic download (original behavior)
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = defaultFilename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            document.body.removeChild(container);
        } catch (err) {
            alert('Failed to export JPG: ' + err);
        }
    }

    // --- Export as PDF ---
    async function exportPDF() {
        // Find the preview iframe and get its document
        const iframe = document.getElementById('preview-area');
        if (!iframe || !iframe.contentWindow || !iframe.contentDocument) {
            alert('Preview not available.');
            return;
        }
        const previewDoc = iframe.contentDocument;
        // Try to find the main roadmap content (assume full document)
        // Use the HTML element for true full height/width
        const htmlElem = previewDoc.documentElement;
        if (!htmlElem) {
            alert('Preview not available.');
            return;
        }
        try {
            // Get the true full scrollable size (html > body)
            const width = Math.max(htmlElem.scrollWidth, htmlElem.offsetWidth, htmlElem.clientWidth, 1200);
            // Add extra padding to height to avoid clipping bottom
            const height = Math.max(htmlElem.scrollHeight, htmlElem.offsetHeight, htmlElem.clientHeight, 800) + 32;
            // Clone the HTML element for rendering
            const clone = htmlElem.cloneNode(true);
            clone.style.background = '#fff';
            clone.style.overflow = 'visible';
            clone.style.width = width + 'px';
            clone.style.height = height + 'px';
            // Container for offscreen rendering
            const container = document.createElement('div');
            container.style.position = 'fixed';
            container.style.left = '-9999px';
            container.style.top = '0';
            container.style.background = '#fff';
            container.style.width = width + 'px';
            container.style.height = height + 'px';
            container.appendChild(clone);
            document.body.appendChild(container);
            
            // Hide edit icons in the clone for PDF export
            const stylePDF = document.createElement('style');
            stylePDF.textContent = `
                .edit-icon,
                .monthly-edit-icon {
                    display: none !important;
                }
            `;
            clone.appendChild(stylePDF);
            
            // Wait for images/fonts to load (best effort)
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Generate image data (same as JPG export)
            const dataUrl = await window.htmlToImage.toJpeg(clone, { quality: 0.95, backgroundColor: '#fff', width, height });
            
            // Convert to PDF using jsPDF
            const { jsPDF } = window.jspdf;
            
            // Calculate PDF dimensions (landscape orientation for roadmaps)
            const pdfWidth = Math.min(width / 4, 420); // A3 landscape width in mm (420mm)
            const pdfHeight = (height / width) * pdfWidth;
            
            // Create PDF in landscape orientation
            const pdf = new jsPDF({
                orientation: pdfWidth > pdfHeight ? 'landscape' : 'portrait',
                unit: 'mm',
                format: [pdfWidth, pdfHeight]
            });
            
            // Add the image to PDF
            pdf.addImage(dataUrl, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            
            // Get team name and year for default filename
            const teamName = document.getElementById('teamName').value.trim() || 'MyTeam';
            const roadmapYear = document.getElementById('roadmapYear').value || '2025';
            const defaultFilename = `${teamName}.Teya-Roadmap.${roadmapYear}.pdf`;
            
            // Try to use File System Access API for save dialog (if supported)
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: defaultFilename,
                        types: [{
                            description: 'PDF documents',
                            accept: { 'application/pdf': ['.pdf'] }
                        }]
                    });
                    
                    // Generate PDF as blob
                    const pdfBlob = pdf.output('blob');
                    
                    // Write to file
                    const writable = await fileHandle.createWritable();
                    await writable.write(pdfBlob);
                    await writable.close();
                    
                    document.body.removeChild(container);
                    return;
                } catch (err) {
                    // If user cancelled, don't do anything
                    if (err.name === 'AbortError') {
                        document.body.removeChild(container);
                        return;
                    }
                    
                    // For other errors, fall back to automatic download
                }
            }
            
            // Fallback: automatic download (original behavior)
            pdf.save(defaultFilename);
            document.body.removeChild(container);
        } catch (err) {
            alert('Failed to export PDF: ' + err);
        }
    }
    </script>
                </div>
                </div>
            </div>
            
            <!-- Stats Modal -->
            <div id="statsModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 10000; align-items: center; justify-content: center; padding: 20px;">
                <div style="background: #fff; border-radius: 10px; width: 80vw; max-width: 600px; max-height: 90vh; box-shadow: 0 10px 30px rgba(0,0,0,0.25); display: flex; flex-direction: column;">
                    <div style="display:flex; align-items:center; justify-content:space-between; padding: 12px 16px; border-bottom: 1px solid #e5e7eb; flex-shrink: 0;">
                        <h3 style="margin:0; font-size: 18px;">Roadmap Statistics</h3>
                        <button onclick="closeStatsModal()" class="secondary" style="border:none; background:none; font-size: 20px; line-height: 1; cursor:pointer; color: #666; padding: 4px;">√ó</button>
                    </div>
                    <div id="statsModalBody" style="padding: 16px; overflow-y: auto; flex: 1; min-height: 0;">
                        <!-- Stats content injected here -->
                    </div>
                    <div style="padding: 12px 16px; border-top: 1px solid #e5e7eb; text-align: right; flex-shrink: 0;">
                        <button onclick="closeStatsModal()" class="secondary">Close</button>
                    </div>
                </div>
            </div>
            
            <div class="form-group" style="max-width: 70px;">
                <label for="roadmapYear">Year:</label>
                <input type="number" id="roadmapYear" placeholder="2025" value="2025" min="2020" max="2030">
            </div>
            
            <!-- Current Filename (editable) -->
            <div id="currentFilenameDisplay" style="display: none;">
                <div class="inline-group">
                    <div class="form-group">
                        <label for="currentFilename">Current Filename:</label>
                        <input type="text" id="currentFilename" placeholder="Roadmap filename">
                    </div>
                    <div class="form-group" style="visibility: hidden;">
                        <!-- Empty space to match inline-group layout -->
                    </div>
                </div>
            </div>
            
            <div class="inline-group">
                <div class="form-group">
                    <label for="teamName">Team Name:</label>
                    <input type="text" id="teamName" placeholder="e.g., eCommerce">
                </div>
                <div class="form-group">
                    <label for="directorVP">Engineering Director/VP:</label>
                    <input type="text" id="directorVP" placeholder="Director or VP Name">
                </div>
            </div>
            <div class="inline-group">
                <div class="form-group">
                    <label for="em">Engineering Manager:</label>
                    <input type="text" id="em" placeholder="EM Name">
                </div>
                <div class="form-group">
                    <label for="pm">Product Manager:</label>
                    <input type="text" id="pm" placeholder="PM Name">
                </div>
            </div>
            
            <div class="form-group">
                <label for="teamDescription">Team Description:</label>
                <textarea id="teamDescription" placeholder="Describe your team's mission, goals, and context" rows="3" style="resize: vertical;"></textarea>
            </div>
            
            <!-- KTLO Section -->
            <h2>KTLO (Keep The Lights On)</h2>
            <div class="ktlo-section" style="border-color: #28a745;">
                <div class="flex-header">
                    <div class="flex-center">
                        <button id="ktlo-collapse-btn" onclick="toggleKTLOCollapse()" title="Collapse KTLO">‚ñº</button>
                        <h4 class="no-margin">KTLO Configuration</h4>
                    </div>
                </div>
                
                <div id="ktlo-content">
                    <div class="form-group">
                        <label for="ktlo-position-toggle">KTLO Position: <span style="font-weight: normal; color: #666;">(Shift+K to toggle)</span></label>
                        <label style="display: flex; align-items: center; gap: 5px; font-weight: normal; margin-top: 5px; text-align: left; margin-left: 3px;">
                            <input type="checkbox" id="ktlo-position-toggle" style="width: auto; flex-shrink: 0;">
                            Top (Before the Epics)
                        </label>
                    </div>
                    
                    <div class="form-group">
                        <label for="ktlo-title">KTLO Story Title:</label>
                        <input type="text" id="ktlo-title" placeholder="e.g., KTLO">
                    </div>
                    
                    <div class="form-group">
                        <label for="ktlo-bullets">KTLO Bullet Points (one per line):</label>
                        <textarea id="ktlo-bullets" placeholder="Keep the Lights On&#10;Operational Excellence&#10;Infrastructure Maintenance"></textarea>
                    </div>
                    
                    <h4>Monthly KTLO Data</h4>
                    
                    <div id="ktlo-monthly-content">
                        <div class="form-group">
                            <label for="ktlo-month-selector">Select Month:</label>
                            <select id="ktlo-month-selector" onchange="switchKTLOMonth()" style="width: 120px; display: inline-block;">
                                <option value="jan">JAN</option>
                                <option value="feb">FEB</option>
                                <option value="mar">MAR</option>
                                <option value="apr">APR</option>
                                <option value="may">MAY</option>
                                <option value="jun">JUN</option>
                                <option value="jul">JUL</option>
                                <option value="aug">AUG</option>
                                <option value="sep">SEP</option>
                                <option value="oct">OCT</option>
                                <option value="nov">NOV</option>
                                <option value="dec">DEC</option>
                            </select>
                        </div>
                        
                        <div style="display: flex; gap: 100px; align-items: flex-end;">
                            <div class="form-group" style="flex: none; width: auto;">
                                <label for="ktlo-current-number">Team Size:</label>
                                <input type="number" id="ktlo-current-number" placeholder="5" min="0" style="width: 200px;">
                            </div>
                            
                            <div class="form-group" style="flex: none; width: auto;">
                                <label for="ktlo-current-percentage">KTLO %:</label>
                                <input type="number" id="ktlo-current-percentage" placeholder="15" min="0" max="100" step="5" style="width: 200px;">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="ktlo-current-description">Description:</label>
                            <textarea id="ktlo-current-description" placeholder="Line 1: Main activity&#10;Line 2: Additional details" rows="2" style="resize: vertical;"></textarea>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- EPICs Section -->
            <h2>EPICs</h2>
            <div id="epics-container">
                <!-- EPICs will be added here dynamically -->
            </div>
            <button onclick="addEpic()">+ Add EPIC</button>
            
            <!-- Below The Line Section -->
            <h2>Below The Line</h2>
            <div class="btl-section" style="border: 2px solid #007cba; border-radius: 8px; padding: 15px; margin-bottom: 20px; background: #f8f9fa;">
                <div class="flex-header">
                    <div class="flex-center">
                        <button id="btl-collapse-btn" onclick="toggleBTLCollapse()" title="Expand Below The Line" class="collapse-btn-collapsed">‚ñ∂</button>
                        <h4 class="no-margin">Below The Line Stories</h4>
                    </div>
                </div>
                
                <div id="btl-content" style="display: none;">
                    <p style="margin-bottom: 15px; color: #666; font-style: italic;">Stories that are below the line - placeholder items for potential future consideration. <strong>Maximum of 3 stories.</strong></p>
                    
                    <div id="btl-stories-container">
                        <!-- BTL stories will be added here -->
                    </div>
                    <button onclick="addBTLStory()">+ Add Story</button>
                </div>
            </div>
            
            <!-- Story Sorting Settings -->
            <div class="form-group" style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; gap: 5px; font-weight: normal;">
                    <input type="checkbox" id="story-sorting-toggle" style="width: auto; flex-shrink: 0;" onchange="handleSortingToggle()">
                    Sort stories by start date within each epic
                </label>
                <label style="display: flex; align-items: center; gap: 5px; font-weight: normal; margin-top: 6px;">
                    <input type="checkbox" id="story-sorting-end-toggle" style="width: auto; flex-shrink: 0;" onchange="handleEndSortingToggle()">
                    Sort stories by end date within each epic
                </label>
                <label style="display: flex; align-items: center; gap: 5px; font-weight: normal; margin-top: 6px;">
                    <input type="checkbox" id="force-text-below-toggle" style="width: auto; flex-shrink: 0;" onchange="handleForceTextBelowToggle()">
                    Force all text boxes below stories
                </label>
            </div>
            
            <!-- Action Buttons -->
            <div class="action-buttons">
                <button onclick="newRoadmap()" class="secondary">üÜï New Roadmap</button>
                <button onclick="loadRoadmap()" class="secondary">üìÇ Load Roadmap</button>
                <button onclick="saveRoadmap()" class="secondary">üíæ Save Roadmap</button>
                <button onclick="openIMOSearch()" class="secondary">üîç Search</button>
                <button onclick="openStatsModal()" class="secondary">üìä Stats</button>
                <div class="dropdown" style="display: inline-block; position: relative;">
                    <button id="shareDropdownBtnBottom" class="secondary" onclick="toggleShareDropdownBottom(event)">üåê Share ‚ñº</button>
                    <div id="shareDropdownMenuBottom" class="dropdown-content">
                        <a href="#" onclick="exportHTML(); closeShareDropdownBottom(); return false;">HTML</a>
                        <a href="#" onclick="exportJPG(); closeShareDropdownBottom(); return false;">JPG</a>
                        <a href="#" onclick="exportPDF(); closeShareDropdownBottom(); return false;">PDF</a>
                    </div>
                </div>
            </div>
            
            <!-- Hidden file input for loading roadmaps (JSON only) -->
            <input type="file" id="roadmapLoadInput" accept=".json" style="display: none;" onchange="handleRoadmapLoad(event)">
            <!-- Legacy inputs kept for compatibility -->
            <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="handleFileLoad(event)">
            <!-- Fallback directory picker for browsers without File System Access API -->
            <input type="file" id="directoryFileInput" style="display: none;" multiple webkitdirectory>

        </div>
        
            <!-- Preview Panel -->
            <div class="preview-panel" onclick="showFullscreen()">
                <button class="fullscreen-button" onclick="event.stopPropagation(); toggleFullscreen()" title="Enter Fullscreen">
                    <span class="fullscreen-icon">‚õ∂</span>
                </button>
                <iframe id="preview-area" src="about:blank"></iframe>
            </div>
        </div>
    </div>
    
    <!-- Fullscreen Overlay -->
    <div class="fullscreen-overlay" id="fullscreen-overlay" onclick="hideFullscreen()">
        <div class="fullscreen-content" onclick="event.stopPropagation()">
            <button class="fullscreen-close" onclick="hideFullscreen()">‚úï Close</button>
            <iframe id="fullscreen-preview" src="about:blank"></iframe>
        </div>
    </div>

    <!-- Edit Story Modal -->
    <div id="editStoryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="editStoryTitle">Edit Story</h3>
                <span class="close" onclick="closeEditModal()">&times;</span>
            </div>
            <div class="modal-body">
                <form id="editStoryForm" onsubmit="return false;">
                    <div class="form-group">
                        <label for="editTitle">Story Title:</label>
                        <input type="text" id="editTitle" name="title" required>
                    </div>
                    
                    <!-- KTLO Position Toggle (only shown for KTLO) -->
                    <div class="form-group" id="editKTLOPositionGroup" style="display: none;">
                        <label for="editKTLOPosition">KTLO Position:</label>
                        <label style="display: flex; align-items: center; gap: 5px; font-weight: normal; margin-top: 5px; text-align: left; margin-left: 3px;">
                            <input type="checkbox" id="editKTLOPosition" style="width: auto; flex-shrink: 0;">
                            Top (Before the Epics)
                        </label>
                    </div>
                    
                    <div class="inline-group">
                        <div class="form-group">
                            <label for="editStart">Start Date/Month:</label>
                            <input type="text" id="editStart" name="start" placeholder="JAN, SEPT, or 15/1/25">
                        </div>
                        <div class="form-group">
                            <label for="editEnd">End Date/Month:</label>
                            <input type="text" id="editEnd" name="end" placeholder="MAR, SEPT, or 15/3/25">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="editBullets">Bullet Points (one per line):</label>
                        <textarea id="editBullets" name="bullets" rows="4"></textarea>
                    </div>
                    
                    <!-- BTL Date Added field (only shown for BTL) -->
                    <div id="editBTLDateAddedGroup" class="form-group" style="display: none;">
                        <label for="editBTLDateAdded">Date Added:</label>
                        <input type="text" id="editBTLDateAdded" placeholder="15/01/25 or 15-01-2025">
                    </div>
                    
                    <div id="editBTLDescriptionGroup" class="form-group" style="display: none;">
                        <label for="editBTLDescription">Description (optional):</label>
                        <input type="text" id="editBTLDescription" placeholder="Why was this added?">
                    </div>
                    
                    <!-- Monthly KTLO Data (only shown for KTLO) -->
                    <div id="editKTLOMonthlySection" style="display: none; margin-top: 15px; padding: 15px; border: 1px solid #ddd; border-radius: 4px;">
                        <h4 style="margin: 0 0 15px 0;">Monthly KTLO Data</h4>
                        <div id="editKTLOMonthsContainer">
                            <div class="form-group">
                                <label for="edit-ktlo-month-selector">Select Month:</label>
                                <select id="edit-ktlo-month-selector" onchange="switchEditKTLOMonth()" style="width: 120px; display: inline-block;">
                                    <option value="jan">JAN</option>
                                    <option value="feb">FEB</option>
                                    <option value="mar">MAR</option>
                                    <option value="apr">APR</option>
                                    <option value="may">MAY</option>
                                    <option value="jun">JUN</option>
                                    <option value="jul">JUL</option>
                                    <option value="aug">AUG</option>
                                    <option value="sep">SEP</option>
                                    <option value="oct">OCT</option>
                                    <option value="nov">NOV</option>
                                    <option value="dec">DEC</option>
                                </select>
                            </div>
                            
                            <div style="display: flex; gap: 100px; align-items: flex-end;">
                                <div class="form-group" style="flex: none; width: auto;">
                                    <label for="edit-ktlo-current-number">Team Size:</label>
                                    <input type="number" id="edit-ktlo-current-number" min="0" style="width: 200px;" placeholder="5">
                                </div>
                                
                                <div class="form-group" style="flex: none; width: auto;">
                                    <label for="edit-ktlo-current-percentage">KTLO %:</label>
                                    <input type="number" id="edit-ktlo-current-percentage" min="0" max="100" step="5" style="width: 200px;" placeholder="15">
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label for="edit-ktlo-current-description">Description:</label>
                                <textarea id="edit-ktlo-current-description" rows="2" style="resize: vertical;"></textarea>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="editIMO">IMO <span style="font-style: italic; color: #888;">(optional)</span>:</label>
                        <input type="text" id="editIMO" name="imo" placeholder="0001">
                    </div>
                    
                    <!-- Row 1: New, Done, Cancelled, Info, Timeline -->
                    <div class="checkbox-group">
                        <input type="checkbox" id="editNewStory" name="newstory" onchange="toggleEditStatusFields()">
                        <label for="editNewStory">New</label>
                        
                        <input type="checkbox" id="editDone" name="done" onchange="toggleEditStatusFields()">
                        <label for="editDone">Done</label>
                        
                        <input type="checkbox" id="editCancelled" name="cancelled" onchange="toggleEditStatusFields()">
                        <label for="editCancelled">Cancelled</label>
                        
                        <input type="checkbox" id="editInfo" name="info" onchange="toggleEditStatusFields()">
                        <label for="editInfo">Info</label>
                        
                        <input type="checkbox" id="editTimelineChanges" name="timelinechanges" onchange="toggleEditTimelineChanges()">
                        <label for="editTimelineChanges">Timeline</label>
                    </div>
                    
                    <!-- Row 2: At Risk, Proposed, Transferred: In, Out -->
                    <div class="checkbox-group">
                        <input type="checkbox" id="editAtRisk" name="atrisk" onchange="toggleEditStatusFields()">
                        <label for="editAtRisk">At Risk</label>
                        
                        <input type="checkbox" id="editProposed" name="proposed" onchange="toggleEditStatusFields()">
                        <label for="editProposed">Proposed</label>
                        
                        <label style="margin-left: 8px; margin-right: 2px;">Transferred:</label>
                        <input type="checkbox" id="editTransferredIn" name="transferredin" onchange="toggleEditStatusFields()">
                        <label for="editTransferredIn" style="margin-right: 5px;">In</label>
                        
                        <input type="checkbox" id="editTransferredOut" name="transferredout" onchange="toggleEditStatusFields()">
                        <label for="editTransferredOut">Out</label>
                    </div>
                    
                    <div id="editStatusFields" style="margin-top: 10px;">
                        <div id="editDoneFields" class="border-card" style="display: none;">
                            <h5>Story Complete</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label for="editDoneDate">Done Date:</label>
                                    <input type="text" id="editDoneDate" placeholder="15/3/25">
                                </div>
                                <div class="form-group">
                                    <label for="editDoneNotes">Done Notes:</label>
                                    <input type="text" id="editDoneNotes">
                                </div>
                            </div>
                        </div>
                        
                        <div id="editCancelFields" class="border-card" style="display: none;">
                            <h5>Story Cancellation</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label for="editCancelDate">Cancel Date:</label>
                                    <input type="text" id="editCancelDate" placeholder="15/3/25">
                                </div>
                                <div class="form-group">
                                    <label for="editCancelNotes">Cancel Notes:</label>
                                    <input type="text" id="editCancelNotes">
                                </div>
                            </div>
                        </div>
                        
                        <div id="editAtRiskFields" class="border-card" style="display: none;">
                            <h5>Story At Risk</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label for="editAtRiskDate">Risk Date:</label>
                                    <input type="text" id="editAtRiskDate" placeholder="15/3/25">
                                </div>
                                <div class="form-group">
                                    <label for="editAtRiskNotes">Risk Notes:</label>
                                    <input type="text" id="editAtRiskNotes">
                                </div>
                            </div>
                        </div>
                        
                        <div id="editNewStoryFields" class="border-card" style="display: none;">
                            <h5>New Story</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label for="editNewStoryDate">New Date:</label>
                                    <input type="text" id="editNewStoryDate" placeholder="15/3/25">
                                </div>
                                <div class="form-group">
                                    <label for="editNewStoryNotes">New Notes:</label>
                                    <input type="text" id="editNewStoryNotes">
                                </div>
                            </div>
                        </div>
                        
                        <div id="editInfoFields" class="border-card" style="display: none; margin-bottom: 5px;">
                            <h5 style="margin-top: 0; margin-bottom: 10px;">Story Information</h5>
                            <div id="editInfoEntries">
                                <!-- Info entries will be added here -->
                                </div>
                            <button id="add-edit-info-btn" onclick="addEditInfoEntry()" class="secondary" style="margin-top: 10px;">+ Add Info Entry</button>
                        </div>

                                                <div id="editTransferredInFields" class="border-card" style="display: none;">
                            <h5>Story Transferred In Details</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label for="editTransferredInDate">Transfer In Date:</label>
                                    <input type="text" id="editTransferredInDate" placeholder="15/01/25">
                                </div>
                                <div class="form-group">
                                    <label for="editTransferredInNotes">Transfer In Notes:</label>
                                    <input type="text" id="editTransferredInNotes">
                                </div>
                            </div>
                        </div>

                        <div id="editTransferredOutFields" class="border-card" style="display: none;">
                            <h5>Story Transferred Out Details</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label for="editTransferredOutDate">Transfer Out Date:</label>
                                    <input type="text" id="editTransferredOutDate" placeholder="15/12/25">
                                </div>
                                <div class="form-group">
                                    <label for="editTransferredOutNotes">Transfer Out Notes:</label>
                                    <input type="text" id="editTransferredOutNotes">
                                </div>
                            </div>
                        </div>

                        <div id="editProposedFields" class="border-card" style="display: none;">
                            <h5>Proposed Story</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label for="editProposedDate">Proposed Date:</label>
                                    <input type="text" id="editProposedDate" placeholder="15/01/25">
                                </div>
                                <div class="form-group">
                                    <label for="editProposedNotes">Proposed Notes:</label>
                                    <input type="text" id="editProposedNotes">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Story Timeline Section -->
                    <div id="editTimelineChangesSection" class="border-section" style="display: none; margin-top: 0px;">
                        <h4 style="margin-top: 0; margin-bottom: 10px;">Story Timeline</h4>
                        <div id="editChangesContainer">
                            <!-- Story timeline entries will be added here -->
                        </div>
                        <button type="button" id="add-edit-change-btn" class="secondary" onclick="addEditChange()" style="margin-top: 10px;">+ Add Timeline Entry</button>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <div class="flex-form">
                    <button type="button" class="btn-modal" style="background: #28a745; color: white; border: none; padding: 6px 8px; font-size: 14px; margin-right: 2px; cursor: pointer;" onclick="moveCurrentStoryUp()" title="Move story up" tabindex="-1">‚ñ≤</button>
                    <button type="button" class="btn-modal" style="background: #28a745; color: white; border: none; padding: 6px 8px; font-size: 14px; margin-right: 2px; cursor: pointer;" onclick="moveCurrentStoryDown()" title="Move story down" tabindex="-1">‚ñº</button>
                    <button type="button" class="btn-modal danger" style="padding: 6px 8px; font-size: 14px; cursor: pointer;" onclick="deleteCurrentStory()" title="Delete story" tabindex="-1">üóëÔ∏è</button>
                </div>
                <div class="flex-modal-footer">
                    <button type="button" class="primary" onclick="saveStoryChanges()" tabindex="-1">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- New Roadmap Modal -->
    <div id="newRoadmapModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>New Roadmap</h2>
                <button class="close" onclick="closeNewRoadmapModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 20px;">Select the year for your new roadmap. All current data will be cleared.</p>
                <div class="form-group">
                    <label for="newRoadmapYear">Roadmap Year:</label>
                    <input type="number" id="newRoadmapYear" value="2025" min="2020" max="2030" style="width: 100px;" onkeydown="if(event.key === 'Enter') confirmNewRoadmap();">
                </div>
            </div>
            <div class="modal-footer">
                <div class="flex-modal-footer">
                    <button type="button" onclick="closeNewRoadmapModal()" class="secondary">Cancel</button>
                    <button type="button" onclick="confirmNewRoadmap()" class="btn-modal">Create New Roadmap</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Monthly KTLO Edit Modal -->
    <div id="editMonthlyKTLOModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="editMonthlyKTLOTitle">Edit Monthly KTLO</h2>
                <button class="close" onclick="closeEditMonthlyKTLOModal()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="editMonthlyKTLOForm">
                    <div class="form-group">
                        <label for="editMonthlyKTLOMonth">Month:</label>
                        <select id="editMonthlyKTLOMonth" disabled style="width: 120px;">
                            <option value="jan">January</option>
                            <option value="feb">February</option>
                            <option value="mar">March</option>
                            <option value="apr">April</option>
                            <option value="may">May</option>
                            <option value="jun">June</option>
                            <option value="jul">July</option>
                            <option value="aug">August</option>
                            <option value="sep">September</option>
                            <option value="oct">October</option>
                            <option value="nov">November</option>
                            <option value="dec">December</option>
                        </select>
                    </div>
                    
                    <div class="inline-group">
                        <div class="form-group">
                            <label for="editMonthlyKTLONumber">Team Size:</label>
                            <input type="number" id="editMonthlyKTLONumber" min="0" placeholder="5" style="width: 200px;">
                        </div>
                        
                        <div class="form-group">
                            <label for="editMonthlyKTLOPercentage">KTLO %:</label>
                            <input type="number" id="editMonthlyKTLOPercentage" min="0" max="100" step="5" placeholder="15" style="width: 200px;">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="editMonthlyKTLODescription">Description:</label>
                        <textarea id="editMonthlyKTLODescription" rows="2" style="resize: vertical;" placeholder="Line 1: Main activity&#10;Line 2: Additional details"></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <div></div>
                <div class="flex-modal-footer">
                    <button type="button" class="primary" onclick="saveMonthlyKTLOChanges()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <script src="roadmap-generator.js"></script>
    <!-- Native date picker - no external JS needed -->
    <script>
        // Check for RoadmapGenerator availability
        if (typeof RoadmapGenerator === 'undefined') {
            // Try to reload the script if it failed to load
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(() => {
                    if (typeof RoadmapGenerator === 'undefined') {
                        const script = document.createElement('script');
                        script.src = 'roadmap-generator.js';
                        document.head.appendChild(script);
                    }
                }, 100);
            });
        }
    </script>
    <script>
        let epicCounter = 0;
        let storyCounters = {};
        let changeCounter = 0;
        let isGeneratingPreview = false; // Flag to prevent duplicate preview generation
        
        // Hexadecimal counter-based unique identifier generation
        let epicIdCounter = 0;
        let storyIdCounter = 0;
        
        function createEpicId() {
            // Create hexadecimal ID for EPICs (e.g., "0xE0000001", "0xE0000002")
            epicIdCounter++;
            const id = `0xE${epicIdCounter.toString(16).padStart(7, '0').toUpperCase()}`;
            return id;
        }
        
        function createStoryId(epicId) {
            // Create hexadecimal ID for Stories (e.g., "0x50000001", "0x50000002")
            // Using 5 prefix (looks like S) to distinguish from EPICs which use E prefix
            storyIdCounter++;
            const id = `0x5${storyIdCounter.toString(16).padStart(7, '0').toUpperCase()}`;
            return id;
        }
        
        async function loadDefaultTemplate() {
            // Double-check: Never load default template if external data is being processed
            if (window.loadingExternalData) {
                return;
            }
            
            try {
                const response = await fetch('Roadmap-Default-Template.json');
                if (!response.ok) {
                    throw new Error(`Failed to load template: ${response.status}`);
                }
                
                const templateData = await response.json();
                
                // Reset ID counters
                epicIdCounter = 0;
                storyIdCounter = 0;
                
                // Ensure monthly KTLO modal is hidden
                const monthlyModal = document.getElementById('editMonthlyKTLOModal');
                if (monthlyModal) {
                    monthlyModal.style.display = 'none';
                }
                
                // Clear existing data first
                document.getElementById('epics-container').innerHTML = '';
                document.getElementById('btl-stories-container').innerHTML = '';
                epicCounter = 0;
                storyCounters = {};
                btlStoryCounter = 0;
                
                // Initialize basic page elements
                initializeKTLOMonths();
                updateBTLAddButton();
                addAutoUpdateListeners();
                updateAllDatePickerRanges();
                
                // Load the template data
                loadTeamData(templateData.teamData);
                
                // Set default filename based on team name and year
                setTimeout(() => {
                    const teamName = document.getElementById('teamName').value.trim() || 'MyTeam';
                    const roadmapYear = document.getElementById('roadmapYear').value || '2025';
                    const defaultFilename = `${teamName}.Teya-Roadmap.${roadmapYear}.json`;
                    updateFilenameDisplay(defaultFilename);
                }, 100);
                
                // Preview generation will be handled by loadTeamData completion tracking
                
            } catch (error) {
                console.error('Error loading default template:', error);
                // Fallback to basic initialization
                initializeBasicTemplate();
            }
        }
        
        function initializeBasicTemplate() {
            // Reset ID counters
            epicIdCounter = 0;
            storyIdCounter = 0;

            // Ensure monthly KTLO modal is hidden
            const monthlyModal = document.getElementById('editMonthlyKTLOModal');
            if (monthlyModal) {
                monthlyModal.style.display = 'none';
            }

            // Clear any existing epics or BTL stories
            document.getElementById('epics-container').innerHTML = '';
            document.getElementById('btl-stories-container').innerHTML = '';
            epicCounter = 0;
            storyCounters = {};
            btlStoryCounter = 0;

            // Set all KTLO monthly data to 0
            ktloMonthlyData = {
                jan: { number: '0', percentage: '0', description: '' },
                feb: { number: '0', percentage: '0', description: '' },
                mar: { number: '0', percentage: '0', description: '' },
                apr: { number: '0', percentage: '0', description: '' },
                may: { number: '0', percentage: '0', description: '' },
                jun: { number: '0', percentage: '0', description: '' },
                jul: { number: '0', percentage: '0', description: '' },
                aug: { number: '0', percentage: '0', description: '' },
                sep: { number: '0', percentage: '0', description: '' },
                oct: { number: '0', percentage: '0', description: '' },
                nov: { number: '0', percentage: '0', description: '' },
                dec: { number: '0', percentage: '0', description: '' }
            };

            // Initialize KTLO and Monthly UI
            initializeKTLOMonths();
            updateBTLAddButton();
            addAutoUpdateListeners();
            updateAllDatePickerRanges();

            // Position KTLO section based on default state
            setTimeout(() => {
                repositionKTLOSection();
                collapseAllSections();
                generatePreview();
            }, 100);
        }
        
        // More robust initialization with multiple retry attempts
        function attemptInitialization(retryCount = 0) {
            const maxRetries = 10; // Try for up to 2 seconds (10 * 200ms)
            
            if (typeof RoadmapGenerator !== 'undefined') {
                // Check if we're loading external data before loading default template
                if (window.loadingExternalData) {
                    return;
                }
                
                // Success! Load the default template
                loadDefaultTemplate();
                return;
            }
            
            if (retryCount < maxRetries) {
                // Keep trying every 200ms
                setTimeout(() => {
                    attemptInitialization(retryCount + 1);
                }, 200);
            } else {
                // Final fallback after all retries exhausted
                console.warn('RoadmapGenerator failed to load, using basic template');
                initializeBasicTemplate();
            }
        }

        // Use DOMContentLoaded instead of window.onload for more reliable initialization
        document.addEventListener('DOMContentLoaded', function() {
            // Add keyboard shortcut listener for KTLO toggle
            document.addEventListener('keydown', handleKTLOToggleShortcut);

            // Close stats modal on Escape
            document.addEventListener('keydown', function(e){
                if (e.key === 'Escape') closeStatsModal();
            });
            
            // Global focus event listener to prevent focus on hidden date inputs
            document.addEventListener('focusin', function(event) {
                const target = event.target;
                // If focus lands on a hidden date input, redirect to the associated text input
                if (target && target.type === 'date' && 
                    target.style.opacity === '0' && 
                    target.style.pointerEvents === 'none') {
                    
                    // Find the associated text input (should be the previous sibling)
                    const textInput = target.previousElementSibling;
                    if (textInput && textInput.tagName === 'INPUT' && textInput.type === 'text') {
                        event.preventDefault();
                        textInput.focus();
                    }
                }
            });
            
            // Initialize date pickers for modal fields when modal opens (they may not exist yet)
            
            // Check for external data first before starting default initialization
            const urlParams = new URLSearchParams(window.location.search);
            const loadDataKey = urlParams.get('loadData');
            
            if (loadDataKey) {
                // Set the flag immediately to prevent any default template loading
                window.loadingExternalData = true;
                // External data will be handled by the other DOMContentLoaded handler
                return;
            }
            
            // Start the initialization attempt immediately (only if no external data)
            attemptInitialization();
        });
        
        // Store KTLO monthly data in memory since we only show one month at a time
        let ktloMonthlyData = {
            jan: { number: '', percentage: '', description: '' },
            feb: { number: '', percentage: '', description: '' },
            mar: { number: '', percentage: '', description: '' },
            apr: { number: '', percentage: '', description: '' },
            may: { number: '', percentage: '', description: '' },
            jun: { number: '', percentage: '', description: '' },
            jul: { number: '', percentage: '', description: '' },
            aug: { number: '', percentage: '', description: '' },
            sep: { number: '', percentage: '', description: '' },
            oct: { number: '', percentage: '', description: '' },
            nov: { number: '', percentage: '', description: '' },
            dec: { number: '', percentage: '', description: '' }
        };
        
        function initializeKTLOMonths() {
            // Initialize the month selector to January and load its data
            const selector = document.getElementById('ktlo-month-selector');
            if (selector) {
                selector.value = 'jan';
                selector.setAttribute('data-previous-month', 'jan');
                loadKTLOMonth('jan');
            }
        }
        
        function switchKTLOMonth() {
            // Save current month's data before switching
            const selector = document.getElementById('ktlo-month-selector');
            const oldMonth = selector.getAttribute('data-previous-month') || selector.value;
            
            // Save the old month's data
            const numberInput = document.getElementById('ktlo-current-number');
            const percentageInput = document.getElementById('ktlo-current-percentage');
            const descriptionInput = document.getElementById('ktlo-current-description');
            
            ktloMonthlyData[oldMonth] = {
                number: numberInput ? numberInput.value : '',
                percentage: percentageInput ? percentageInput.value : '',
                description: descriptionInput ? descriptionInput.value : ''
            };
            
            // Store the new month as the "previous" for next time
            selector.setAttribute('data-previous-month', selector.value);
            
            const selectedMonth = selector.value;
            loadKTLOMonth(selectedMonth);
        }
        
        function loadKTLOMonth(month) {
            const data = ktloMonthlyData[month];
            const numberInput = document.getElementById('ktlo-current-number');
            const percentageInput = document.getElementById('ktlo-current-percentage');
            const descriptionInput = document.getElementById('ktlo-current-description');
            
            if (numberInput) numberInput.value = data.number;
            if (percentageInput) percentageInput.value = data.percentage;
            if (descriptionInput) descriptionInput.value = data.description;
        }
        
        function saveCurrentKTLOData() {
            // Don't save current data if we're creating a new roadmap (would overwrite fresh defaults)
            if (window.isCreatingNewRoadmap) {
                return;
            }
            
            const selector = document.getElementById('ktlo-month-selector');
            if (!selector) return;
            
            const currentMonth = selector.value;
            const numberInput = document.getElementById('ktlo-current-number');
            const percentageInput = document.getElementById('ktlo-current-percentage');
            const descriptionInput = document.getElementById('ktlo-current-description');
            
            ktloMonthlyData[currentMonth] = {
                number: numberInput ? numberInput.value : '',
                percentage: percentageInput ? percentageInput.value : '',
                description: descriptionInput ? descriptionInput.value : ''
            };
        }
        

        
        function addEpic() {
            epicCounter++;
            storyCounters[epicCounter] = 0;
            
            // Generate 8-character unique ID for the EPIC
            const epicId = createEpicId();
            
            const epicHtml = `
                <div class="epic-section" id="epic-${epicCounter}" data-epic-id="${epicId}">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button id="collapse-btn-${epicCounter}" onclick="toggleEpicCollapse(${epicCounter})" title="Collapse EPIC">‚ñº</button>
                            <h3 style="margin: 0;">EPIC ${epicCounter}</h3>
                        </div>
                        <button class="danger" onclick="removeEpic(${epicCounter})" tabindex="-1">üóëÔ∏è Remove EPIC</button>
                    </div>
                    
                    <div class="form-group">
                        <label for="epic-name-${epicCounter}">EPIC Name:</label>
                        <input type="text" id="epic-name-${epicCounter}" placeholder="e.g., EPIC 1" value="EPIC ${epicCounter}">
                    </div>
                    
                    <!-- Hidden ID field for data collection -->
                    <input type="hidden" id="epic-id-${epicCounter}" value="${epicId}">
                    
                    <div id="epic-content-${epicCounter}">
                        <h4>Stories</h4>
                        <div id="stories-container-${epicCounter}">
                            <!-- Stories will be added here -->
                        </div>
                        <button onclick="addStory(${epicCounter})">+ Add Story</button>
                    </div>
                </div>
            `;
            
            document.getElementById('epics-container').insertAdjacentHTML('beforeend', epicHtml);
            
            // Add auto-update listeners to the new EPIC elements
            const epicNameField = document.getElementById(`epic-name-${epicCounter}`);
            if (epicNameField) addListenersToElement(epicNameField);
            
            addStory(epicCounter); // Add one story by default
        }
        
        function removeEpic(epicId) {
            const epicElement = document.getElementById(`epic-${epicId}`);
            const epicName = document.getElementById(`epic-name-${epicId}`)?.value || `EPIC ${epicId}`;
            
            if (!confirm(`Are you sure you want to remove "${epicName}"? This will delete the EPIC and all its stories permanently.`)) {
                return;
            }
            
            epicElement.remove();
            delete storyCounters[epicId];
            
            // Refresh the roadmap preview
            generatePreview();
        }
        
        function toggleEpicCollapse(epicId) {
            const contentDiv = document.getElementById(`epic-content-${epicId}`);
            const collapseBtn = document.getElementById(`collapse-btn-${epicId}`);
            
            if (contentDiv.style.display === 'none') {
                // Expand
                contentDiv.style.display = 'block';
                collapseBtn.textContent = '‚ñº';
                collapseBtn.title = 'Collapse EPIC';
                collapseBtn.classList.remove('collapse-btn-collapsed');
                
                // Initialize date pickers for this EPIC after expansion
                setTimeout(() => {
                    initializeDatePickersForEpic(epicId);
                }, 50);
            } else {
                // Collapse
                contentDiv.style.display = 'none';
                collapseBtn.textContent = '‚ñ∂';
                collapseBtn.title = 'Expand EPIC';
                collapseBtn.classList.add('collapse-btn-collapsed');
            }
        }
        
        function initializeDatePickersForEpic(epicId) {
            // Find all date fields within this specific EPIC
            const epicElement = document.getElementById(`epic-${epicId}`);
            if (!epicElement) {
                return;
            }
            
            // Story start/end date fields (allow month names)
            const storyDateFields = epicElement.querySelectorAll('input[id*="-start-"], input[id*="-end-"]');
            storyDateFields.forEach(field => {
                if (!field.dataset.datePickerInitialized) {
                    initializeDatePicker(field, true);
                }
            });
            
            // Status date fields (specific dates only)
            const statusDateFields = epicElement.querySelectorAll('input[id*="-date-"]');
            statusDateFields.forEach(field => {
                if (!field.dataset.datePickerInitialized) {
                    initializeDatePicker(field, false);
                }
            });
            
            // Timeline change date fields (specific dates only)
            const timelineFields = epicElement.querySelectorAll('input[id*="-prev-"], input[id*="-new-"]');
            timelineFields.forEach(field => {
                if (!field.dataset.datePickerInitialized) {
                    initializeDatePicker(field, false);
                }
            });
        }
        
        function initializeDatePickersForSection(sectionType) {
            let sectionElement;
            if (sectionType === 'ktlo') {
                sectionElement = document.getElementById('ktlo-content');
            } else if (sectionType === 'btl') {
                sectionElement = document.getElementById('btl-content');
            }
            
            if (!sectionElement) {
                return;
            }
            
            // BTL start/end date fields (allow month names)
            if (sectionType === 'btl') {
                const btlDateFields = sectionElement.querySelectorAll('input[id*="-start-"], input[id*="-end-"]');
                btlDateFields.forEach(field => {
                    if (!field.dataset.datePickerInitialized) {
                        initializeDatePicker(field, true);
                    }
                });
            }
        }
        
        function toggleKTLOCollapse() {
            const contentDiv = document.getElementById('ktlo-content');
            const collapseBtn = document.getElementById('ktlo-collapse-btn');
            
            if (contentDiv.style.display === 'none') {
                // Expand
                contentDiv.style.display = 'block';
                collapseBtn.textContent = '‚ñº';
                collapseBtn.title = 'Collapse KTLO';
                collapseBtn.classList.remove('collapse-btn-collapsed');
                
                // Initialize date pickers for KTLO section after expansion
                setTimeout(() => {
                    initializeDatePickersForSection('ktlo');
                }, 50);
            } else {
                // Collapse
                contentDiv.style.display = 'none';
                collapseBtn.textContent = '‚ñ∂';
                collapseBtn.title = 'Expand KTLO';
                collapseBtn.classList.add('collapse-btn-collapsed');
            }
        }
        
        // Generic collapse toggle function
        function toggleCollapse(contentId, buttonId, sectionName) {
            const contentDiv = document.getElementById(contentId);
            const collapseBtn = document.getElementById(buttonId);
            
            if (contentDiv.style.display === 'none') {
                // Expand
                contentDiv.style.display = 'block';
                collapseBtn.textContent = '‚ñº';
                collapseBtn.title = `Collapse ${sectionName}`;
                collapseBtn.classList.remove('collapse-btn-collapsed');
            } else {
                // Collapse
                contentDiv.style.display = 'none';
                collapseBtn.textContent = '‚ñ∂';
                collapseBtn.title = `Expand ${sectionName}`;
                collapseBtn.classList.add('collapse-btn-collapsed');
            }
        }
        
        function toggleBTLCollapse() {
            const contentDiv = document.getElementById('btl-content');
            const collapseBtn = document.getElementById('btl-collapse-btn');
            
            if (contentDiv.style.display === 'none') {
                // Expand
                contentDiv.style.display = 'block';
                collapseBtn.textContent = '‚ñº';
                collapseBtn.title = 'Collapse BTL';
                collapseBtn.classList.remove('collapse-btn-collapsed');
                
                // Initialize date pickers for BTL section after expansion
                setTimeout(() => {
                    initializeDatePickersForSection('btl');
                }, 50);
            } else {
                // Collapse
                contentDiv.style.display = 'none';
                collapseBtn.textContent = '‚ñ∂';
                collapseBtn.title = 'Expand BTL';
                collapseBtn.classList.add('collapse-btn-collapsed');
            }
        }
        

        
        function repositionKTLOSection() {
            const ktloToggle = document.getElementById('ktlo-position-toggle');
            if (!ktloToggle) return;
            
            // Find the complete KTLO section (h2 + div)
            const ktloHeader = [...document.querySelectorAll('h2')].find(h2 => h2.textContent.includes('KTLO (Keep The Lights On)'));
            const ktloDiv = ktloHeader ? ktloHeader.nextElementSibling : null;
            
            // Find the complete EPICs section (h2 + div + button)
            const epicsHeader = [...document.querySelectorAll('h2')].find(h2 => h2.textContent.trim() === 'EPICs');
            const epicsContainer = epicsHeader ? epicsHeader.nextElementSibling : null;
            const epicsButton = epicsContainer ? epicsContainer.nextElementSibling : null;
            
            // Find BTL section for reference when positioning at bottom
            const btlHeader = [...document.querySelectorAll('h2')].find(h2 => h2.textContent.includes('Below The Line'));
            
            if (!ktloHeader || !ktloDiv || !epicsHeader || !epicsContainer || !epicsButton) {
                return;
            }
            
            if (ktloToggle.checked) {
                // Move KTLO before EPICs (top position)
                epicsHeader.parentNode.insertBefore(ktloHeader, epicsHeader);
                epicsHeader.parentNode.insertBefore(ktloDiv, epicsHeader);
            } else {
                // Move KTLO after EPICs, before BTL (bottom position)
                if (btlHeader) {
                    btlHeader.parentNode.insertBefore(ktloHeader, btlHeader);
                    btlHeader.parentNode.insertBefore(ktloDiv, btlHeader);
                } else {
                    // If no BTL section, insert after EPICs button
                    epicsButton.parentNode.insertBefore(ktloHeader, epicsButton.nextSibling);
                    epicsButton.parentNode.insertBefore(ktloDiv, epicsButton.nextSibling);
                }
            }
        }
        
        // Debounced generatePreview to avoid too many rapid updates
        let previewTimeout;
        function debouncedGeneratePreview() {
            clearTimeout(previewTimeout);
            previewTimeout = setTimeout(generatePreview, getConfigUtility().CSS.TIMING.DEBOUNCE_DELAY); // Wait for debounce delay after last change
        }

        // Keyboard shortcut for toggling KTLO position
        function handleKTLOToggleShortcut(event) {
            // Check if user is currently typing in an editable element
            const activeElement = document.activeElement;
            const isEditable = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.contentEditable === 'true'
            );
            
            // Don't handle shortcuts when user is typing in an editable field
            if (isEditable) {
                return;
            }
            
            // Check for Shift+K
            if (event.shiftKey && event.key === 'K') {
                event.preventDefault();
                toggleKTLOPosition();
            }
        }

        function toggleKTLOPosition() {
            const ktloToggle = document.getElementById('ktlo-position-toggle');
            if (ktloToggle) {
                // Toggle the checkbox state
                ktloToggle.checked = !ktloToggle.checked;
                
                // Reposition the KTLO section in the builder form
                repositionKTLOSection();
                
                // Regenerate the preview to show the change
                generatePreview();
                
                // Show a brief notification
                showKTLOPositionNotification(ktloToggle.checked);
            }
        }

        function handleSortingToggle() {
            const sortingToggle = document.getElementById('story-sorting-toggle');
            if (sortingToggle) {
                // Save the preference
                getConfigUtility().setSortStories(sortingToggle.checked);
                // Ensure mutual exclusivity
                if (sortingToggle.checked) {
                    const endToggle = document.getElementById('story-sorting-end-toggle');
                    if (endToggle) {
                        endToggle.checked = false;
                        getConfigUtility().setSortByEnd(false);
                    }
                    getConfigUtility().setSortByStart(true);
                } else {
                    getConfigUtility().setSortByStart(false);
                }
                
                // Reorder stories in the UI based on sorting preference
                if (sortingToggle.checked) {
                    reorderStoriesInUI();
                } else {
                    // Restore original order when sorting is disabled
                    restoreOriginalStoryOrder();
                }
                
                // Regenerate the preview to show the change
                generatePreview();
                
                // Show a brief notification
                showSortingNotification(sortingToggle.checked);
            }
        }

        function handleEndSortingToggle() {
            const endToggle = document.getElementById('story-sorting-end-toggle');
            if (endToggle) {
                // Persist preference and enforce mutual exclusivity
                getConfigUtility().setSortByEnd(endToggle.checked);
                if (endToggle.checked) {
                    const startToggle = document.getElementById('story-sorting-toggle');
                    if (startToggle) {
                        startToggle.checked = false;
                        getConfigUtility().setSortStories(false);
                        getConfigUtility().setSortByStart(false);
                    }
                }
                
                // Apply or restore ordering
                if (endToggle.checked) {
                    reorderStoriesInUI(true);
                } else {
                    restoreOriginalStoryOrder();
                }
                
                // Update preview
                generatePreview();
                showSortingNotification(endToggle.checked);
            }
        }

        // Temporary variable for force text below (one-time action)
        let tempForceTextBelow = false;
        
        function handleForceTextBelowToggle() {
            const toggle = document.getElementById('force-text-below-toggle');
            if (toggle) {
                // Use temporary variable instead of saving to localStorage
                tempForceTextBelow = toggle.checked;
                // Regenerate the preview to apply placement
                generatePreview();
            }
        }

        // Store original story order for each epic
        const originalStoryOrders = new Map();
        
        function storeOriginalStoryOrder(epicId) {
            const epicEl = document.getElementById(`epic-${epicId}`);
            if (!epicEl) return;
            
            const storyElements = epicEl.querySelectorAll('.story-section');
            const originalOrder = Array.from(storyElements).map(el => el.id);
            originalStoryOrders.set(epicId, originalOrder);
        }
        
        function reorderStoriesInUI(sortByEnd = false) {
            // Get all epic sections
            const epicElements = document.querySelectorAll('.epic-section');
            epicElements.forEach(epicEl => {
                const epicId = epicEl.id.split('-')[1];
                const storyElements = epicEl.querySelectorAll('.story-section');
                
                if (storyElements.length <= 1) return; // No need to sort single stories
                
                // Store original order if not already stored
                if (!originalStoryOrders.has(epicId)) {
                    storeOriginalStoryOrder(epicId);
                }
                
                // Collect story data and sort it
                const stories = [];
                storyElements.forEach(storyEl => {
                    const storyId = storyEl.id.replace('story-', '');
                    try {
                        const story = collectStoryData(storyId);
                        story._element = storyEl; // Keep reference to DOM element
                        stories.push(story);
                    } catch (error) {
                        // Skip invalid stories
                    }
                });
                
                // Sort stories (start-first or end-first based on flag)
                stories.sort((a, b) => {
                    const aStart = a.startDate || a.startMonth || 'JAN';
                    const bStart = b.startDate || b.startMonth || 'JAN';
                    const aEnd = a.endDate || a.endMonth || 'MAR';
                    const bEnd = b.endDate || b.endMonth || 'MAR';

                    const year = parseInt(document.getElementById('roadmapYear').value) || 2025;
                    if (sortByEnd) {
                        const endComparison = getDateUtility().compareDateOrMonth(aEnd, bEnd, year);
                        if (endComparison !== 0) return endComparison;
                        return getDateUtility().compareDateOrMonth(aStart, bStart, year);
                    } else {
                        const startComparison = getDateUtility().compareDateOrMonth(aStart, bStart, year);
                        if (startComparison !== 0) return startComparison;
                        return getDateUtility().compareDateOrMonth(aEnd, bEnd, year);
                    }
                });
                
                // Reorder DOM elements - find the correct container
                const storiesContainer = document.getElementById(`stories-container-${epicId}`);
                if (storiesContainer) {
                    stories.forEach(story => {
                        if (story._element) {
                            storiesContainer.appendChild(story._element);
                        }
                    });
                }
            });
        }
        
        function restoreOriginalStoryOrder() {
            // Get all epic sections
            const epicElements = document.querySelectorAll('.epic-section');
            epicElements.forEach(epicEl => {
                const epicId = epicEl.id.split('-')[1];
                const originalOrder = originalStoryOrders.get(epicId);
                
                if (!originalOrder) return; // No original order stored
                
                const storiesContainer = document.getElementById(`stories-container-${epicId}`);
                if (storiesContainer) {
                    // Restore original order
                    originalOrder.forEach(storyId => {
                        const storyElement = document.getElementById(storyId);
                        if (storyElement) {
                            storiesContainer.appendChild(storyElement);
                        }
                    });
                }
            });
        }

        function showSortingNotification(isEnabled) {
            const notification = document.createElement('div');
            notification.innerHTML = `Story sorting ${isEnabled ? 'ENABLED' : 'DISABLED'}`;
            notification.style.cssText = `
                position: fixed;
                top: 60px;
                right: 20px;
                background: ${isEnabled ? '#28a745' : '#6c757d'};
                color: white;
                padding: 10px 15px;
                border-radius: 5px;
                font-weight: bold;
                z-index: 10000;
                animation: fadeInOut 2s ease-in-out;
            `;
            
            document.body.appendChild(notification);
            
            // Remove notification after animation
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }

        function showKTLOPositionNotification(isTop) {
            const notification = document.createElement('div');
            notification.innerHTML = `KTLO moved to ${isTop ? 'TOP' : 'BOTTOM'} (Shift+K to toggle)`;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 10px 15px;
                border-radius: 5px;
                font-weight: bold;
                z-index: 10000;
                animation: fadeInOut 2s ease-in-out;
            `;
            
            // Add animation CSS if it doesn't exist
            if (!document.getElementById('ktlo-notification-style')) {
                const style = document.createElement('style');
                style.id = 'ktlo-notification-style';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translateY(-10px); }
                        20% { opacity: 1; transform: translateY(0); }
                        80% { opacity: 1; transform: translateY(0); }
                        100% { opacity: 0; transform: translateY(-10px); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // Remove notification after animation
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }
        
        function addAutoUpdateListeners() {
            // Team information fields
            const teamFields = ['roadmapYear', 'teamName', 'directorVP', 'em', 'pm', 'teamDescription'];
            teamFields.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', debouncedGeneratePreview);
                    element.addEventListener('change', debouncedGeneratePreview);
                    
                    // Special handling for roadmapYear to update date picker ranges
                    if (id === 'roadmapYear') {
                        element.addEventListener('change', function() {
                            updateAllDatePickerRanges();
                        });
                    }
                    
                    // Update filename when team name or year changes
                    if (id === 'teamName' || id === 'roadmapYear') {
                        element.addEventListener('input', function() {
                            const currentFilename = document.getElementById('currentFilename').value.trim();
                            // Only auto-update if filename follows the default pattern
                            if (currentFilename.includes('.Teya-Roadmap.') && currentFilename.endsWith('.json')) {
                                const teamName = document.getElementById('teamName').value.trim() || 'MyTeam';
                                const roadmapYear = document.getElementById('roadmapYear').value || '2025';
                                const newFilename = `${teamName}.Teya-Roadmap.${roadmapYear}.json`;
                                document.getElementById('currentFilename').value = newFilename;
                            }
                        });
                    }
                }
            });
            
            // KTLO fields
            const ktloFields = ['ktlo-title', 'ktlo-bullets'];
            ktloFields.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', debouncedGeneratePreview);
                    element.addEventListener('change', debouncedGeneratePreview);
                }
            });
            
            // KTLO position toggle
            const ktloToggle = document.getElementById('ktlo-position-toggle');
            if (ktloToggle) {
                ktloToggle.addEventListener('change', function() {
                    repositionKTLOSection();
                    generatePreview(); // Immediate update for position changes
                });
            }
            
            // KTLO monthly data fields (new dropdown approach)
            const ktloMonthlyFields = ['ktlo-current-number', 'ktlo-current-percentage', 'ktlo-current-description'];
            ktloMonthlyFields.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', function() {
                        saveCurrentKTLOData();
                        debouncedGeneratePreview();
                    });
                    element.addEventListener('change', function() {
                        saveCurrentKTLOData();
                        debouncedGeneratePreview();
                    });
                }
            });
            
            // Add listeners to existing EPIC and story elements
            addListenersToExistingElements();
        }
        
        /**
         * Validate that end date is not before start date
         */
        function validateEndDate(event) {
            const endField = event.target;
            const endValue = endField.value.trim();
            
            if (!endValue) {
                // Empty is okay - clear any error styling
                endField.style.borderColor = '';
                endField.style.backgroundColor = '';
                return;
            }
            
            // Find corresponding start date field
            const endFieldId = endField.id;
            let startFieldId = '';
            
            if (endFieldId.includes('story-end-')) {
                startFieldId = endFieldId.replace('story-end-', 'story-start-');
            } else if (endFieldId.includes('btl-end-')) {
                startFieldId = endFieldId.replace('btl-end-', 'btl-start-');
            } else if (endFieldId.includes('End')) {
                startFieldId = endFieldId.replace('End', 'Start');
            }
            
            if (!startFieldId) return;
            
            const startField = document.getElementById(startFieldId);
            if (!startField) return;
            
            const startValue = startField.value.trim();
            if (!startValue) {
                // No start date to compare - clear any error styling
                endField.style.borderColor = '';
                endField.style.backgroundColor = '';
                return;
            }
            
            try {
                const roadmapYear = parseInt(document.getElementById('roadmapYear').value) || new Date().getFullYear();
                
                // Parse both dates to ISO format for comparison
                const startISO = DateUtility.parseTextValue(startValue, false, roadmapYear);
                const endISO = DateUtility.parseTextValue(endValue, true, roadmapYear);
                
                if (startISO && endISO && endISO < startISO) {
                    // End date is before start date - show error styling (stays until user fixes it)
                    endField.style.borderColor = '#dc3545';
                    endField.style.backgroundColor = '#ffe6e6';
                    alert(`Warning: End date (${endValue}) is before start date (${startValue}).`);
                } else {
                    // Valid - clear any error styling
                    endField.style.borderColor = '';
                    endField.style.backgroundColor = '';
                }
            } catch (error) {
                // If parsing fails, don't validate (might be month name)
                endField.style.borderColor = '';
                endField.style.backgroundColor = '';
            }
        }
        
        function addListenersToExistingElements() {
            // EPIC name fields
            document.querySelectorAll('[id^="epic-name-"]').forEach(element => {
                element.addEventListener('input', debouncedGeneratePreview);
                element.addEventListener('change', debouncedGeneratePreview);
            });
            
            // Story fields
            document.querySelectorAll('[id^="story-title-"], [id^="story-start-"], [id^="story-end-"], [id^="story-bullets-"], [id^="story-imo-"]').forEach(element => {
                element.addEventListener('input', debouncedGeneratePreview);
                element.addEventListener('change', debouncedGeneratePreview);
            });
            
            // Add validation to story end date fields
            document.querySelectorAll('[id^="story-end-"]').forEach(element => {
                if (!element.dataset.hasValidation) {
                    element.addEventListener('blur', validateEndDate);
                    // Clear error styling when user starts typing
                    element.addEventListener('input', function() {
                        this.style.borderColor = '';
                        this.style.backgroundColor = '';
                    });
                    element.dataset.hasValidation = 'true';
                }
            });
            
            // Story checkboxes (status, timeline changes)
            document.querySelectorAll('[id^="story-done-"], [id^="story-cancelled-"], [id^="story-atrisk-"], [id^="story-newstory-"], [id^="story-transferredout-"], [id^="story-changes-"]').forEach(element => {
                element.addEventListener('change', debouncedGeneratePreview);
            });
            
            // Story status fields (done, cancel, at-risk, new story notes and dates)
            document.querySelectorAll('[id^="done-date-"], [id^="done-notes-"], [id^="cancel-date-"], [id^="cancel-notes-"], [id^="atrisk-date-"], [id^="atrisk-notes-"], [id^="newstory-date-"], [id^="newstory-notes-"]').forEach(element => {
                element.addEventListener('input', debouncedGeneratePreview);
                element.addEventListener('change', debouncedGeneratePreview);
            });
            
            // Timeline change fields
            document.querySelectorAll('[id^="change-date-"], [id^="change-desc-"], [id^="change-prev-"], [id^="change-new-"]').forEach(element => {
                element.addEventListener('input', debouncedGeneratePreview);
                element.addEventListener('change', debouncedGeneratePreview);
            });
            
            // BTL story fields
            document.querySelectorAll('[id^="btl-title-"], [id^="btl-start-"], [id^="btl-end-"], [id^="btl-bullets-"], [id^="btl-imo-"]').forEach(element => {
                element.addEventListener('input', debouncedGeneratePreview);
                element.addEventListener('change', debouncedGeneratePreview);
            });
            
            // Add validation to BTL end date fields
            document.querySelectorAll('[id^="btl-end-"]').forEach(element => {
                if (!element.dataset.hasValidation) {
                    element.addEventListener('blur', validateEndDate);
                    // Clear error styling when user starts typing
                    element.addEventListener('input', function() {
                        this.style.borderColor = '';
                        this.style.backgroundColor = '';
                    });
                    element.dataset.hasValidation = 'true';
                }
            });
            
            // Add validation to edit modal end date field
            const editEndField = document.getElementById('editEnd');
            if (editEndField && !editEndField.dataset.hasValidation) {
                editEndField.addEventListener('blur', validateEndDate);
                // Clear error styling when user starts typing
                editEndField.addEventListener('input', function() {
                    this.style.borderColor = '';
                    this.style.backgroundColor = '';
                });
                editEndField.dataset.hasValidation = 'true';
            }
            
            // Date pickers are now initialized when sections are expanded
        }
        
        function addListenersToElement(element) {
            // Helper function to add auto-update listeners to a single element
            if (element.type === 'checkbox') {
                element.addEventListener('change', debouncedGeneratePreview);
            } else {
                element.addEventListener('input', debouncedGeneratePreview);
                element.addEventListener('change', debouncedGeneratePreview);
            }
        }
        
        function collapseAllSections() {
            // Collapse all EPICs
            const epicElements = document.querySelectorAll('.epic-section');
            epicElements.forEach(epicEl => {
                const epicId = epicEl.id.split('-')[1];
                const contentDiv = document.getElementById(`epic-content-${epicId}`);
                const collapseBtn = document.getElementById(`collapse-btn-${epicId}`);
                
                if (contentDiv && collapseBtn) {
                    contentDiv.style.display = 'none';
                    collapseBtn.textContent = '‚ñ∂';
                    collapseBtn.title = 'Expand EPIC';
                    collapseBtn.classList.add('collapse-btn-collapsed');
                }
            });
            
            // Collapse KTLO
            const ktloContentDiv = document.getElementById('ktlo-content');
            const ktloCollapseBtn = document.getElementById('ktlo-collapse-btn');
            
            if (ktloContentDiv && ktloCollapseBtn) {
                ktloContentDiv.style.display = 'none';
                ktloCollapseBtn.textContent = '‚ñ∂';
                ktloCollapseBtn.title = 'Expand KTLO';
                ktloCollapseBtn.classList.add('collapse-btn-collapsed');
            }
            
            // Collapse BTL
            const btlContentDiv = document.getElementById('btl-content');
            const btlCollapseBtn = document.getElementById('btl-collapse-btn');
            
            if (btlContentDiv && btlCollapseBtn) {
                btlContentDiv.style.display = 'none';
                btlCollapseBtn.textContent = '‚ñ∂';
                btlCollapseBtn.title = 'Expand BTL';
                btlCollapseBtn.classList.add('collapse-btn-collapsed');
            }
            
            // Collapse Monthly KTLO
            const ktloMonthlyContentDiv = document.getElementById('ktlo-monthly-content');
            const ktloMonthlyCollapseBtn = document.getElementById('ktlo-monthly-collapse-btn');
            
            if (ktloMonthlyContentDiv && ktloMonthlyCollapseBtn) {
                ktloMonthlyContentDiv.style.display = 'none';
                ktloMonthlyCollapseBtn.textContent = '‚ñ∂';
                ktloMonthlyCollapseBtn.title = 'Expand Monthly KTLO';
                ktloMonthlyCollapseBtn.classList.add('collapse-btn-collapsed');
            }
        }
        
        function addStory(epicId) {
            storyCounters[epicId]++;
            const storyId = `${epicId}-${storyCounters[epicId]}`;
            
            // Generate unique Story ID
            const storyUniqueId = createStoryId();
            
            const storyHtml = `
                <div class="story-section" id="story-${storyId}" data-story-id="${storyUniqueId}">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0;">üìã Story ${storyCounters[epicId]}</h4>
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <button onclick="moveStoryUp('${storyId}')" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;" title="Move story up" tabindex="-1">‚ñ≤</button>
                            <button onclick="moveStoryDown('${storyId}')" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;" title="Move story down" tabindex="-1">‚ñº</button>
                            <button class="danger" onclick="removeStory('${storyId}')" tabindex="-1">üóëÔ∏è</button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="story-title-${storyId}">Story Title:</label>
                        <input type="text" id="story-title-${storyId}" placeholder="Story title">
                    </div>
                    
                    <!-- Hidden Story ID field for data collection -->
                    <input type="hidden" id="story-id-${storyId}" value="${storyUniqueId}">
                    
                    <div class="inline-group">
                        <div class="form-group">
                            <label for="story-start-${storyId}">Start (Month or Date):</label>
                            <input type="text" id="story-start-${storyId}" placeholder="JAN, SEPT, 15/01/25, or 15-01-2025">
                        </div>
                        <div class="form-group">
                            <label for="story-end-${storyId}">End (Month or Date):</label>
                            <input type="text" id="story-end-${storyId}" placeholder="MAR, SEPT, 15/03/25, or 15-03-2025">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="story-bullets-${storyId}">Bullet Points (one per line):</label>
                        <textarea id="story-bullets-${storyId}" placeholder="First bullet point\nSecond bullet point"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="story-imo-${storyId}">IMO <span style="font-style: italic; color: #888;">(optional)</span>:</label>
                        <input type="text" id="story-imo-${storyId}" placeholder="0001">
                    </div>
                    
                    <!-- Row 1: New, Done, Cancelled, Info, Timeline -->
                    <div class="checkbox-group">
                        <input type="checkbox" id="story-newstory-${storyId}" onchange="handleNewStoryChange('${storyId}')">
                        <label for="story-newstory-${storyId}">New</label>
                        
                        <input type="checkbox" id="story-done-${storyId}" onchange="handleDoneChange('${storyId}')">
                        <label for="story-done-${storyId}">Done</label>
                        
                        <input type="checkbox" id="story-cancelled-${storyId}" onchange="handleCancelledChange('${storyId}')">
                        <label for="story-cancelled-${storyId}">Cancelled</label>
                        
                        <input type="checkbox" id="story-info-${storyId}" onchange="handleInfoChange('${storyId}')">
                        <label for="story-info-${storyId}">Info</label>
                        
                        <input type="checkbox" id="story-changes-${storyId}" onchange="toggleChanges('${storyId}')">
                        <label for="story-changes-${storyId}">Timeline</label>
                    </div>
                    
                    <!-- Row 2: At Risk, Proposed, Transferred: In, Out -->
                    <div class="checkbox-group">
                        <input type="checkbox" id="story-atrisk-${storyId}" onchange="handleAtRiskChange('${storyId}')">
                        <label for="story-atrisk-${storyId}">At Risk</label>
                        
                        <input type="checkbox" id="story-proposed-${storyId}" onchange="handleProposedChange('${storyId}')">
                        <label for="story-proposed-${storyId}">Proposed</label>
                        
                        <label style="margin-left: 8px; margin-right: 2px;">Transferred:</label>
                        <input type="checkbox" id="story-transferredin-${storyId}" onchange="handleTransferredInChange('${storyId}')">
                        <label for="story-transferredin-${storyId}" style="margin-right: 5px;">In</label>
                        
                        <input type="checkbox" id="story-transferredout-${storyId}" onchange="handleTransferredOutChange('${storyId}')">
                        <label for="story-transferredout-${storyId}">Out</label>
                    </div>
                    
                    <!-- Done Section -->
                    <div id="done-section-${storyId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5>Story Complete</h5>
                        <div class="inline-group">
                            <div class="form-group">
                                <label for="done-date-${storyId}">Done Date:</label>
                                <input type="text" id="done-date-${storyId}" placeholder="07/10 or 07/10/25 or 07-10-2025">
                            </div>
                            <div class="form-group">
                                <label for="done-notes-${storyId}">Done Notes:</label>
                                <input type="text" id="done-notes-${storyId}" placeholder="Completion notes">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Cancelled Section -->
                    <div id="cancelled-section-${storyId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5>Story Cancellation</h5>
                        <div class="inline-group">
                            <div class="form-group">
                                <label for="cancel-date-${storyId}">Cancel Date:</label>
                                <input type="text" id="cancel-date-${storyId}" placeholder="15/10 or 15/10/25 or 15-10-2025">
                            </div>
                            <div class="form-group">
                                <label for="cancel-notes-${storyId}">Cancel Notes:</label>
                                <input type="text" id="cancel-notes-${storyId}" placeholder="Cancellation reason">
                            </div>
                        </div>
                    </div>
                    
                    <!-- At Risk Section -->
                    <div id="atrisk-section-${storyId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5>Story At Risk</h5>
                        <div class="inline-group">
                            <div class="form-group">
                                <label for="atrisk-date-${storyId}">Warning Date:</label>
                                <input type="text" id="atrisk-date-${storyId}" placeholder="15/10 or 15/10/25 or 15-10-2025">
                            </div>
                            <div class="form-group">
                                <label for="atrisk-notes-${storyId}">Risk Description:</label>
                                <input type="text" id="atrisk-notes-${storyId}" placeholder="Describe the risk or warning">
                            </div>
                        </div>
                    </div>
                    
                    <!-- New Story Section -->
                    <div id="newstory-section-${storyId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5>New Story</h5>
                        <div class="inline-group">
                            <div class="form-group">
                                <label for="newstory-date-${storyId}">Announcement Date:</label>
                                <input type="text" id="newstory-date-${storyId}" placeholder="15/10 or 15/10/25 or 15-10-2025">
                            </div>
                            <div class="form-group">
                                <label for="newstory-notes-${storyId}">New Description:</label>
                                <input type="text" id="newstory-notes-${storyId}" placeholder="Describe what makes this story new">
                            </div>
                        </div>
                    </div>

                    <!-- Info Section -->
                    <div id="info-section-${storyId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5>Story Information</h5>
                        <div id="info-entries-${storyId}">
                            <!-- Info entries will be added here -->
                            </div>
                        <button id="add-info-btn-${storyId}" onclick="addInfoEntry('${storyId}')" class="secondary" style="margin-top: 10px;">+ Add Info Entry</button>
                    </div>

                    <!-- Transferred In Section -->
                    <div id="transferredin-section-${storyId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5>Story Transferred In Details</h5>
                        <div class="inline-group">
                            <div class="form-group">
                                <label for="transferredin-date-${storyId}">Transfer In Date:</label>
                                <input type="text" id="transferredin-date-${storyId}" placeholder="15/01 or 15/01/25 or 15-01-2025">
                            </div>
                            <div class="form-group">
                                <label for="transferredin-notes-${storyId}">Transfer In Notes:</label>
                                <input type="text" id="transferredin-notes-${storyId}" placeholder="Transfer details">
                            </div>
                        </div>
                    </div>

                    <!-- Transferred Out Section -->
                    <div id="transferredout-section-${storyId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5>Story Transferred Out Details</h5>
                        <div class="inline-group">
                            <div class="form-group">
                                <label for="transferredout-date-${storyId}">Transfer Out Date:</label>
                                <input type="text" id="transferredout-date-${storyId}" placeholder="15/12 or 15/12/25 or 15-12-2025">
                            </div>
                            <div class="form-group">
                                <label for="transferredout-notes-${storyId}">Transfer Out Notes:</label>
                                <input type="text" id="transferredout-notes-${storyId}" placeholder="Transfer out details">
                            </div>
                        </div>
                    </div>

                    <!-- Proposed Section -->
                    <div id="proposed-section-${storyId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5>Proposed Story</h5>
                        <div class="inline-group">
                            <div class="form-group">
                                <label for="proposed-date-${storyId}">Proposed Date:</label>
                                <input type="text" id="proposed-date-${storyId}" placeholder="15/01 or 15/01/25 or 15-01-2025">
                            </div>
                            <div class="form-group">
                                <label for="proposed-notes-${storyId}">Proposed Notes:</label>
                                <input type="text" id="proposed-notes-${storyId}" placeholder="Proposal details">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Story Timeline Section -->
                    <div id="changes-section-${storyId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h5>Story Timeline</h5>
                        <div id="changes-container-${storyId}">
                            <!-- Story timeline entries will be added here -->
                        </div>
                        <button id="add-change-btn-${storyId}" onclick="addChange('${storyId}')" class="secondary">+ Add Timeline Entry</button>
                    </div>
                </div>
            `;
            
            document.getElementById(`stories-container-${epicId}`).insertAdjacentHTML('beforeend', storyHtml);
            
            // Add auto-update listeners to the new story elements
            const storyFields = [
                `story-title-${storyId}`,
                `story-start-${storyId}`,
                `story-end-${storyId}`,
                `story-bullets-${storyId}`,
                `story-imo-${storyId}`,
                `done-date-${storyId}`,
                `done-notes-${storyId}`,
                `cancel-date-${storyId}`,
                `cancel-notes-${storyId}`,
                `atrisk-date-${storyId}`,
                `atrisk-notes-${storyId}`,
                `newstory-date-${storyId}`,
                `newstory-notes-${storyId}`,
                `info-date-${storyId}`,
                `info-notes-${storyId}`,
                `transferredout-date-${storyId}`,
                `transferredout-notes-${storyId}`,
                `transferredin-date-${storyId}`,
                `transferredin-notes-${storyId}`,
                `proposed-date-${storyId}`,
                `proposed-notes-${storyId}`
            ];
            
            storyFields.forEach(fieldId => {
                const element = document.getElementById(fieldId);
                if (element) {
                    addListenersToElement(element);
                }
            });
            
            // Date pickers will be initialized when EPIC is expanded
            
            // Add listeners to checkboxes (these need special handling in the existing onchange handlers)
            const checkboxes = [
                `story-done-${storyId}`,
                `story-cancelled-${storyId}`,
                `story-atrisk-${storyId}`,
                `story-newstory-${storyId}`,
                `story-info-${storyId}`,
                `story-transferredout-${storyId}`,
                `story-transferredin-${storyId}`,
                `story-proposed-${storyId}`,
                `story-changes-${storyId}`
            ];
            
            checkboxes.forEach(checkboxId => {
                const element = document.getElementById(checkboxId);
                if (element) {
                    // Add auto-update listener that will fire after the existing onchange handler
                    element.addEventListener('change', debouncedGeneratePreview);
                }
            });
            
            // Initialize date pickers for the newly created story
            setTimeout(() => {
                const startField = document.getElementById(`story-start-${storyId}`);
                const endField = document.getElementById(`story-end-${storyId}`);
                
                if (startField) {
                    initializeDatePicker(startField, true);
                }
                if (endField) {
                    initializeDatePicker(endField, true);
                    // Add validation listener
                    if (!endField.dataset.hasValidation) {
                        endField.addEventListener('blur', validateEndDate);
                        // Clear error styling when user starts typing
                        endField.addEventListener('input', function() {
                            this.style.borderColor = '';
                            this.style.backgroundColor = '';
                        });
                        endField.dataset.hasValidation = 'true';
                    }
                }
                
                // Initialize all status date fields that may be shown later
                initializeDatePicker(document.getElementById(`done-date-${storyId}`), false);
                initializeDatePicker(document.getElementById(`cancel-date-${storyId}`), false);
                initializeDatePicker(document.getElementById(`atrisk-date-${storyId}`), false);
                initializeDatePicker(document.getElementById(`newstory-date-${storyId}`), false);
                initializeDatePicker(document.getElementById(`info-date-${storyId}`), false);
                initializeDatePicker(document.getElementById(`transferredin-date-${storyId}`), false);
                initializeDatePicker(document.getElementById(`transferredout-date-${storyId}`), false);
                initializeDatePicker(document.getElementById(`proposed-date-${storyId}`), false);
            }, 200); // Increased delay to ensure DOM elements are ready
        }
        
        function removeStory(storyId) {
            // Extract the epic ID from the story ID (format: epicId-storyNumber)
            const epicId = storyId.split('-')[0];
            
            // Remove the story element
            document.getElementById(`story-${storyId}`).remove();
            
            // Find the epic element and update story numbers
            const epicElement = document.getElementById(`epic-${epicId}`);
            if (epicElement) {
                updateStoryNumbers(epicElement);
                
                // Update the story counter to match the actual number of remaining stories
                const remainingStories = epicElement.querySelectorAll('.story-section');
                storyCounters[epicId] = remainingStories.length;
            }
            
            // Refresh the roadmap preview
            generatePreview();
        }
        
        let btlStoryCounter = 0;
        
        function addBTLStory() {
            // Check if we already have max BTL stories
            const existingBTLStories = document.querySelectorAll('#btl-stories-container .story-section');
            if (existingBTLStories.length >= getConfigUtility().CSS.UI.BTL_MAX_STORIES) {
                alert(`Maximum of ${getConfigUtility().CSS.UI.BTL_MAX_STORIES} BTL stories allowed. Please remove an existing story before adding a new one.`);
                return;
            }
            
            btlStoryCounter++;
            const storyId = `btl-${btlStoryCounter}`;
            
            const storyHtml = `
                <div class="story-section" id="story-${storyId}">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0;">üìã Story ${btlStoryCounter}</h4>
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <button onclick="moveBTLStoryUp('${storyId}')" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;" title="Move story up" tabindex="-1">‚ñ≤</button>
                            <button onclick="moveBTLStoryDown('${storyId}')" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;" title="Move story down" tabindex="-1">‚ñº</button>
                            <button class="danger" onclick="deleteBTLStory('${storyId}')" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;" title="Delete story" tabindex="-1">üóëÔ∏è</button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="btl-title-${storyId}">Story Title:</label>
                        <input type="text" id="btl-title-${storyId}" placeholder="Story title">
                    </div>
                    
                    <div class="inline-group">
                        <div class="form-group">
                            <label for="btl-start-${storyId}">Start (Month or Date):</label>
                            <input type="text" id="btl-start-${storyId}" placeholder="JAN, SEPT, 15/01/25, or 15-01-2025">
                        </div>
                        <div class="form-group">
                            <label for="btl-end-${storyId}">End (Month or Date):</label>
                            <input type="text" id="btl-end-${storyId}" placeholder="MAR, SEPT, 15/03/25, or 15-03-2025">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="btl-bullets-${storyId}">Bullet Points (one per line):</label>
                        <textarea id="btl-bullets-${storyId}" placeholder="First bullet point\nSecond bullet point"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="btl-dateadded-${storyId}">Date Added:</label>
                        <input type="text" id="btl-dateadded-${storyId}" placeholder="15/01/25 or 15-01-2025">
                    </div>
                    
                    <div class="form-group">
                        <label for="btl-description-${storyId}">Description (optional):</label>
                        <input type="text" id="btl-description-${storyId}" placeholder="Why was this added?">
                    </div>
                    
                    <div class="form-group">
                        <label for="btl-imo-${storyId}">IMO <span style="font-style: italic; color: #888;">(optional)</span>:</label>
                        <input type="text" id="btl-imo-${storyId}" placeholder="0001">
                    </div>
                </div>
            `;
            
            document.getElementById('btl-stories-container').insertAdjacentHTML('beforeend', storyHtml);
            
            // Add auto-update listeners to the new BTL story elements
            const btlFields = [
                `btl-title-${storyId}`,
                `btl-start-${storyId}`,
                `btl-end-${storyId}`,
                `btl-bullets-${storyId}`,
                `btl-dateadded-${storyId}`,
                `btl-description-${storyId}`,
                `btl-imo-${storyId}`
            ];
            
            btlFields.forEach(fieldId => {
                const element = document.getElementById(fieldId);
                if (element) {
                    addListenersToElement(element);
                }
            });
            
            // Initialize date pickers for BTL date fields immediately since BTL is always expanded
            initializeDatePicker(document.getElementById(`btl-start-${storyId}`), true);
            const btlEndField = document.getElementById(`btl-end-${storyId}`);
            if (btlEndField) {
                initializeDatePicker(btlEndField, true);
                // Add validation listener
                if (!btlEndField.dataset.hasValidation) {
                    btlEndField.addEventListener('blur', validateEndDate);
                    // Clear error styling when user starts typing
                    btlEndField.addEventListener('input', function() {
                        this.style.borderColor = '';
                        this.style.backgroundColor = '';
                    });
                    btlEndField.dataset.hasValidation = 'true';
                }
            }
            initializeDatePicker(document.getElementById(`btl-dateadded-${storyId}`), false);
            
            updateBTLAddButton();
        }
        
        // BTL delete function for main form
        window.deleteBTLStory = function(storyId) {
            const elementToRemove = document.getElementById(`story-${storyId}`);
            if (elementToRemove) {
                elementToRemove.remove();
                updateBTLAddButton();
                generatePreview();
            }
        };

        
        function updateBTLAddButton() {
            const existingBTLStories = document.querySelectorAll('#btl-stories-container .story-section');
            const addButton = document.querySelector('button[onclick="addBTLStory()"]');
            
            if (existingBTLStories.length >= 3) {
                addButton.disabled = true;
                addButton.textContent = '+ Add Story (Max 3 reached)';
                addButton.style.opacity = '0.5';
                addButton.style.cursor = 'not-allowed';
            } else {
                addButton.disabled = false;
                addButton.textContent = '+ Add Story';
                addButton.style.opacity = '1';
                addButton.style.cursor = 'pointer';
            }
        }
        
        function moveBTLStoryUp(storyId) {
            const story = document.getElementById(`story-${storyId}`);
            const prevStory = story.previousElementSibling;
            if (prevStory && prevStory.classList.contains('story-section')) {
                story.parentNode.insertBefore(story, prevStory);
            }
        }
        
        function moveBTLStoryDown(storyId) {
            const story = document.getElementById(`story-${storyId}`);
            const nextStory = story.nextElementSibling;
            if (nextStory && nextStory.classList.contains('story-section')) {
                story.parentNode.insertBefore(nextStory, story);
            }
        }
        
        function toggleChanges(storyId) {
            const checkbox = document.getElementById(`story-changes-${storyId}`);
            const section = document.getElementById(`changes-section-${storyId}`);
            
            if (checkbox.checked) {
                section.style.display = 'block';
                
                // Automatically add one timeline change if none exist
                const container = document.getElementById(`changes-container-${storyId}`);
                const existingChanges = container.querySelectorAll(`div[id^="change-${storyId}-change-"]`);
                if (existingChanges.length === 0) {
                    addChange(storyId);
                }
            } else {
                section.style.display = 'none';
                // Clear existing changes when hiding
                const container = document.getElementById(`changes-container-${storyId}`);
                if (container) {
                    container.innerHTML = '';
                }
                // Update button state after clearing changes
                updateChangeButton(storyId);
            }
        }
        
        function getTodaysDateEuropean() {
            return DateUtility.getTodaysDateEuropean();
        }
        
        // Utility function to get current roadmap year
        function getCurrentRoadmapYear() {
            return parseInt(document.getElementById('roadmapYear').value) || new Date().getFullYear();
        }

        // Global tracking for date picker initialization to prevent duplicates
        const initializedDatePickers = new Set();
        
        // Simple date picker helper using native HTML5 date input
        function initializeDatePicker(inputElement, allowMonthOnly = true) {
            if (!inputElement) {
                return;
            }
            
            // Use multiple methods to prevent duplicates
            if (inputElement.dataset.datePickerInitialized === 'true') {
                return;
            }
            
            if (initializedDatePickers.has(inputElement.id)) {
                inputElement.dataset.datePickerInitialized = 'true'; // Ensure flag is set
                return;
            }
            
            // Double-check by looking for existing hidden date input
            const existingHidden = inputElement.parentNode?.querySelector('input[type="date"]');
            if (existingHidden) {
                inputElement.dataset.datePickerInitialized = 'true';
                initializedDatePickers.add(inputElement.id);
                return;
            }
            
            // Mark as initialized immediately using both methods
            inputElement.dataset.datePickerInitialized = 'true';
            initializedDatePickers.add(inputElement.id);
            
            // Determine if this is an end date field (should default to last day of month)
            const isEndDateField = inputElement.id.includes('-end-') || 
                                  inputElement.id.includes('End') || 
                                  inputElement.id.includes('-prev-') ||  // Previous End Date
                                  inputElement.id.includes('-new-');     // New End Date
            
            // Create a simple, hidden native date input as helper
            const hiddenDateInput = document.createElement('input');
            hiddenDateInput.type = 'date';
            hiddenDateInput.tabIndex = -1; // Exclude from tab order
            
            // Set date range to allow roadmap year dates
            const roadmapYear = getCurrentRoadmapYear();
            hiddenDateInput.min = `${roadmapYear - 1}-01-01`; // Allow previous year
            hiddenDateInput.max = `${roadmapYear + 1}-12-31`; // Allow next year
            
            hiddenDateInput.style.cssText = `
                position: absolute;
                opacity: 0;
                pointer-events: none;
                width: 1px;
                height: 1px;
                z-index: -1;
            `;
            
            // Insert hidden date input after the text input
            inputElement.parentNode.insertBefore(hiddenDateInput, inputElement.nextSibling);
            
                         // Add calendar icon to the text input with hover effect
             inputElement.style.backgroundImage = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'16\' height=\'16\' fill=\'%23666\' viewBox=\'0 0 16 16\'%3E%3Cpath d=\'M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5 0zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z\'/%3E%3C/svg%3E")';
             inputElement.style.backgroundRepeat = 'no-repeat';
             inputElement.style.backgroundPosition = 'right 8px center';
             inputElement.style.backgroundSize = '16px 16px';
             inputElement.style.paddingRight = '30px';
             inputElement.style.cursor = 'text';
             inputElement.title = 'Type date/month directly or click calendar icon to open date picker';
            
                         // Helper function to convert text input value to date
             const parseTextValue = (value) => {
                 // Always get current roadmap year value to handle year changes
                 const roadmapYear = getCurrentRoadmapYear();
                 return DateUtility.parseTextValue(value, isEndDateField, roadmapYear);
             };
            
            // Helper function to convert date input value back to text format
            const formatDateToText = (dateValue) => {
                return DateUtility.formatDateToText(dateValue);
            };
            
                         // Sync text input value to hidden date input
             const syncToDateInput = () => {
                 // Ensure we have a valid input element
                 if (!inputElement || !inputElement.value) {
                     return; // Silent return - this is normal during initialization
                 }
                 
                 const textValue = inputElement.value.trim();
                 

                 
                 const dateValue = parseTextValue(textValue);
                 if (hiddenDateInput) {
                     // Update date range dynamically in case roadmap year changed
                     const currentRoadmapYear = getCurrentRoadmapYear();
                     hiddenDateInput.min = `${currentRoadmapYear - 1}-01-01`;
                     hiddenDateInput.max = `${currentRoadmapYear + 1}-12-31`;
                     
                     hiddenDateInput.value = dateValue;
                 }
             };
             
             // Initialize with existing value if present
             setTimeout(() => {
                 syncToDateInput();
             }, 10);
             
             // Open date picker only when clicking on the calendar icon (right side of input)
             inputElement.addEventListener('click', function(e) {
                 const inputRect = this.getBoundingClientRect();
                 const clickX = e.clientX - inputRect.left;
                 const inputWidth = inputRect.width;
                 
                 // Only open date picker if clicked on the right 30px (where the calendar icon is)
                 if (clickX > inputWidth - 30) {
                     e.preventDefault();
                     
                     // Ensure date range is current before opening picker
                     const currentRoadmapYear = getCurrentRoadmapYear();
                     hiddenDateInput.min = `${currentRoadmapYear - 1}-01-01`;
                     hiddenDateInput.max = `${currentRoadmapYear + 1}-12-31`;
                     
                     // Smart default date logic for empty fields
                     if (!inputElement.value.trim()) {
                         let defaultDate = null;
                         
                         // Priority 1: If this is an end date field, try to default to start date
                         if (isEndDateField) {
                             // Extract story ID and find corresponding start date field
                             const fieldId = inputElement.id;
                             let startFieldId = '';
                             
                             if (fieldId.includes('story-end-')) {
                                 startFieldId = fieldId.replace('story-end-', 'story-start-');
                             } else if (fieldId.includes('End')) {
                                 startFieldId = fieldId.replace('End', 'Start');
                             }
                             
                             if (startFieldId) {
                                 const startField = document.getElementById(startFieldId);
                                 if (startField && startField.value.trim()) {
                                     // Parse the start date and set as default for end date picker
                                     defaultDate = parseTextValue(startField.value.trim());
                                 }
                             }
                         }
                         
                         // Priority 2: If no start date found (or it's a start date field), 
                         // check if roadmap year is in the future
                         if (!defaultDate) {
                             const currentYear = new Date().getFullYear();
                             if (currentRoadmapYear > currentYear) {
                                 // Set to January 1st of the roadmap year
                                 defaultDate = `${currentRoadmapYear}-01-01`;
                             }
                         }
                         
                         // Apply the default date if we found one
                         if (defaultDate) {
                             hiddenDateInput.value = defaultDate;
                         }
                     }
                     
                     syncToDateInput();
                     
                     // Position the hidden input near the calendar icon (right side of the input)
                     const rect = this.getBoundingClientRect();
                     let scrollLeft = 0;
                     let scrollTop = 0;
                     
                     // Check if we're in a modal dialog (different positioning context)
                     const modal = this.closest('.modal');
                     if (!modal) {
                         // Normal page positioning - account for scroll
                         scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                         scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                     }
                     // For modals, use direct positioning since they're typically fixed/absolute
                     
                     // Position with right edge aligned to right edge of input field
                     const datePickerWidth = 200; // Reasonable width for date picker
                     const rightEdgePos = rect.left + rect.width + scrollLeft; // Right edge of input
                     const leftPos = rightEdgePos - datePickerWidth; // Position so right edge aligns
                     const topPos = rect.top + scrollTop;
                     
                     hiddenDateInput.style.position = 'absolute';
                     hiddenDateInput.style.left = leftPos + 'px';
                     hiddenDateInput.style.top = topPos + 'px';
                     hiddenDateInput.style.width = datePickerWidth + 'px'; // Full width for proper alignment
                     hiddenDateInput.style.height = rect.height + 'px';
                     hiddenDateInput.style.zIndex = '10000';
                     hiddenDateInput.style.opacity = '0';
                     hiddenDateInput.style.pointerEvents = 'none';
                     
                     // Scroll into view if needed
                     this.scrollIntoView({ behavior: 'instant', block: 'center' });
                     
                     setTimeout(() => {
                         try {
                             if (hiddenDateInput.showPicker) {
                                 hiddenDateInput.showPicker();
                             } else {
                                 // Fallback for browsers without showPicker support
                                 hiddenDateInput.style.opacity = '1';
                                 hiddenDateInput.style.pointerEvents = 'auto';
                                 hiddenDateInput.focus();
                                 hiddenDateInput.click();
                                 setTimeout(() => {
                                     hiddenDateInput.style.opacity = '0';
                                     hiddenDateInput.style.pointerEvents = 'none';
                                 }, 100);
                             }
                         } catch (error) {
                             // If showPicker fails, try alternative approach
                             hiddenDateInput.style.opacity = '1';
                             hiddenDateInput.style.pointerEvents = 'auto';
                             hiddenDateInput.focus();
                             hiddenDateInput.click();
                             setTimeout(() => {
                                 hiddenDateInput.style.opacity = '0';
                                 hiddenDateInput.style.pointerEvents = 'none';
                             }, 100);
                         }
                     }, 10);
                 }
                 // Otherwise, allow normal text input behavior
             });
             
             // Change cursor to pointer when hovering over calendar icon area
             inputElement.addEventListener('mousemove', function(e) {
                 const inputRect = this.getBoundingClientRect();
                 const mouseX = e.clientX - inputRect.left;
                 const inputWidth = inputRect.width;
                 
                 if (mouseX > inputWidth - 30) {
                     this.style.cursor = 'pointer';
                 } else {
                     this.style.cursor = 'text';
                 }
             });
             
             // Reset cursor when mouse leaves
             inputElement.addEventListener('mouseleave', function() {
                 this.style.cursor = 'text';
             });
            
                         // Update text input when date is selected
             hiddenDateInput.addEventListener('change', function() {
                 if (this.value) {
                     inputElement.value = formatDateToText(this.value);
                     inputElement.dispatchEvent(new Event('change', { bubbles: true }));
                 }
             });
             
             // Keep date picker in sync when user types manually, and format with year
             inputElement.addEventListener('blur', function() {
                 const textValue = this.value.trim();
                 if (textValue) {
                     // Parse the date
                     const dateValue = parseTextValue(textValue);
                     if (dateValue) {
                         // Format it back with the year included
                         const formattedDate = formatDateToText(dateValue);
                         if (formattedDate && formattedDate !== textValue) {
                             this.value = formattedDate;
                         }
                     }
                 }
                 syncToDateInput();
             });
             
             // Already marked as initialized at the beginning of function
        }

        // Global function to refresh all date pickers with their current values
        function refreshAllDatePickers() {
            // Find all date inputs that should have date pickers
            const dateInputs = document.querySelectorAll('input[type="text"][id*="start"], input[type="text"][id*="end"], input[type="text"][id*="date"]');
            
            dateInputs.forEach(input => {
                // Only reinitialize if not already initialized or missing calendar icon
                const hasCalendarIcon = input.style.backgroundImage && input.style.backgroundImage.includes('data:image/svg+xml');
                
                if (!hasCalendarIcon) {
                    // Remove existing initialization flags to force reinit
                    input.dataset.datePickerInitialized = 'false';
                    initializedDatePickers.delete(input.id);
                    
                    // Determine if this is a month-only field
                    const allowMonthOnly = input.id.includes('start') || input.id.includes('end');
                    
                    // Reinitialize the date picker
                    initializeDatePicker(input, allowMonthOnly);
                }
            });
        }
        
        // Update date picker ranges when roadmap year changes
        function updateAllDatePickerRanges() {
            const currentRoadmapYear = getCurrentRoadmapYear();
            const minDate = `${currentRoadmapYear - 1}-01-01`;
            const maxDate = `${currentRoadmapYear + 1}-12-31`;
            
            // Update all hidden date inputs
            document.querySelectorAll('input[type="date"]').forEach(dateInput => {
                if (dateInput.style.opacity === '0') { // This identifies our hidden date inputs
                    dateInput.min = minDate;
                    dateInput.max = maxDate;
                }
            });
        }

        // ===== OPTIMIZED CHECKBOX HANDLING SYSTEM =====
        // 
        // This optimization reduces ~150 lines of repetitive checkbox code to ~30 lines
        // Benefits:
        // - Single generic handler function replaces 7 individual functions
        // - Configuration-driven approach for easy maintenance
        // - Utility functions for data management
        // - Maintains full backward compatibility
        //
        
        // Configuration object defining all status types
        const STATUS_CONFIG = {
            done: {
                label: 'Done',
                sectionTitle: 'Story Complete',
                dateLabel: 'Done Date',
                notesLabel: 'Done Notes',
                datePlaceholder: '07/10 or 07/10/25 or 07-10-2025',
                notesPlaceholder: 'Completion notes'
            },
            cancelled: {
                label: 'Cancelled', 
                sectionTitle: 'Story Cancellation',
                dateLabel: 'Cancel Date',
                notesLabel: 'Cancel Notes',
                datePlaceholder: '15/10 or 15/10/25 or 15-10-2025',
                notesPlaceholder: 'Cancellation reason'
            },
            atrisk: {
                label: 'At Risk',
                sectionTitle: 'Story At Risk',
                dateLabel: 'Risk Date', 
                notesLabel: 'Risk Notes',
                datePlaceholder: '20/10 or 20/10/25 or 20-10-2025',
                notesPlaceholder: 'Risk details'
            },
            newstory: {
                label: 'New',
                sectionTitle: 'New Story Details',
                dateLabel: 'Story Date',
                notesLabel: 'Story Notes', 
                datePlaceholder: '01/11 or 01/11/25 or 01-11-2025',
                notesPlaceholder: 'New story details'
            },
            transferredout: {
                label: 'Out',
                sectionTitle: 'Story Transferred Out Details',
                dateLabel: 'Transfer Out Date',
                notesLabel: 'Transfer Out Notes',
                datePlaceholder: '15/12 or 15/12/25 or 15-12-2025', 
                notesPlaceholder: 'Transfer out details'
            },
            transferredin: {
                label: 'In',
                sectionTitle: 'Story Transferred In Details',
                dateLabel: 'Transfer In Date',
                notesLabel: 'Transfer In Notes',
                datePlaceholder: '01/12 or 01/12/25 or 01-12-2025',
                notesPlaceholder: 'Transfer in details'
            },
            proposed: {
                label: 'Proposed',
                sectionTitle: 'Story Proposed Details', 
                dateLabel: 'Proposed Date',
                notesLabel: 'Proposed Notes',
                datePlaceholder: '10/12 or 10/12/25 or 10-12-2025',
                notesPlaceholder: 'Proposal details'
            }
        };

        // Generic status change handler - replaces all individual handlers
        function handleStatusChange(storyId, statusType) {
            const checkboxId = `story-${statusType}-${storyId}`;
            const sectionId = `${statusType}-section-${storyId}`;
            const dateFieldId = `${statusType === 'atrisk' ? 'atrisk' : statusType === 'cancelled' ? 'cancel' : statusType}-date-${storyId}`;
            
            const checkbox = document.getElementById(checkboxId);
            const section = document.getElementById(sectionId);
            
            
            if (!checkbox || !section) return;
            
            if (checkbox.checked) {
                // Show the section
                section.style.display = 'block';
                
                // Special handling for info status
                if (statusType === 'info') {
                    // For info, create the first entry automatically if none exist
                    setTimeout(() => {
                        const infoEntriesContainer = document.getElementById(`info-entries-${storyId}`);
                        if (infoEntriesContainer) {
                            const existingEntries = infoEntriesContainer.querySelectorAll('.info-entry');
                            if (existingEntries.length === 0) {
                                addInfoEntry(storyId);
                            }
                        }
                    }, 100);
                } else {
                // Auto-fill today's date if date field is empty
                const dateField = document.getElementById(dateFieldId);
                if (dateField && !dateField.value) {
                    dateField.value = getTodaysDateEuropean();
                }
                
                // Focus on the date field for convenience
                setTimeout(() => {
                    if (dateField) {
                        dateField.focus({ preventScroll: true });
                    }
                }, 100);
                }
            } else {
                // Hide the section
                section.style.display = 'none';
            }
        }

        // Utility functions for status management
        const StatusUtils = {
            // Get all status checkboxes for a story
            getStatusCheckboxes(storyId) {
                const checkboxes = {};
                Object.keys(STATUS_CONFIG).forEach(statusType => {
                    checkboxes[statusType] = document.getElementById(`story-${statusType}-${storyId}`);
                });
                return checkboxes;
            },
            
            // Get status data for a story
            getStatusData(storyId) {
                const data = {};
                Object.keys(STATUS_CONFIG).forEach(statusType => {
                    const checkbox = document.getElementById(`story-${statusType}-${storyId}`);
                    const dateField = document.getElementById(`${statusType === 'atrisk' ? 'atrisk' : statusType === 'cancelled' ? 'cancel' : statusType}-date-${storyId}`);
                    const notesField = document.getElementById(`${statusType === 'atrisk' ? 'atrisk' : statusType === 'cancelled' ? 'cancel' : statusType}-notes-${storyId}`);
                    
                    data[statusType] = {
                        checked: checkbox ? checkbox.checked : false,
                        date: dateField ? dateField.value : '',
                        notes: notesField ? notesField.value : ''
                    };
                });
                return data;
            },
            
            // Set status data for a story
            setStatusData(storyId, statusType, checked, date = '', notes = '') {
                const checkbox = document.getElementById(`story-${statusType}-${storyId}`);
                const dateField = document.getElementById(`${statusType === 'atrisk' ? 'atrisk' : statusType === 'cancelled' ? 'cancel' : statusType}-date-${storyId}`);
                const notesField = document.getElementById(`${statusType === 'atrisk' ? 'atrisk' : statusType === 'cancelled' ? 'cancel' : statusType}-notes-${storyId}`);
                
                if (checkbox) {
                    checkbox.checked = checked;
                    handleStatusChange(storyId, statusType);
                }
                if (dateField) dateField.value = date;
                if (notesField) notesField.value = notes;
            },
            
            // Bulk set multiple status types at once
            setMultipleStatusData(storyId, statusConfigs) {
                Object.entries(statusConfigs).forEach(([statusType, config]) => {
                    if (config.checked) {
                        this.setStatusData(storyId, statusType, true, config.date || '', config.notes || '');
                    }
                });
            }
        };

        // ===== END OPTIMIZED CHECKBOX HANDLING SYSTEM =====

        function handleDoneChange(storyId) {
            handleStatusChange(storyId, 'done');
        }
        
        function handleCancelledChange(storyId) {
            handleStatusChange(storyId, 'cancelled');
        }
        
        function handleAtRiskChange(storyId) {
            handleStatusChange(storyId, 'atrisk');
        }
        
        function handleNewStoryChange(storyId) {
            handleStatusChange(storyId, 'newstory');
        }

        function handleInfoChange(storyId) {
            const checkbox = document.getElementById(`story-info-${storyId}`);
            const section = document.getElementById(`info-section-${storyId}`);
            
            if (!checkbox || !section) return;
            
            if (checkbox.checked) {
                // Show the section
                section.style.display = 'block';
                
                // For info, create the first entry automatically if none exist
                setTimeout(() => {
                    const infoEntriesContainer = document.getElementById(`info-entries-${storyId}`);
                    if (infoEntriesContainer) {
                        const existingEntries = infoEntriesContainer.querySelectorAll('.info-entry');
                        if (existingEntries.length === 0) {
                            addInfoEntry(storyId);
                        }
                    }
                }, 100);
            } else {
                // Hide the section
                section.style.display = 'none';
            }
            
            // Convert single info to multiple instances if needed
            setTimeout(() => {
                convertSingleInfoToMultiple(storyId);
            }, 100);
        }

        // Add new info entry
        function addInfoEntry(storyId) {
            const entriesContainer = document.getElementById(`info-entries-${storyId}`);
            const entryId = `info-entry-${storyId}-${Date.now()}`;
            
            // Count existing entries to get the next number
            const existingEntries = entriesContainer.querySelectorAll('.info-entry');
            const entryNumber = existingEntries.length + 1;
            
            const entryHtml = `
                <div id="${entryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong>Info Entry #${entryNumber}</strong>
                        <button type="button" onclick="removeInfoEntry('${entryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                    </div>
                    <div class="inline-group">
                        <div class="form-group">
                            <label for="info-date-${entryId}">Info Date:</label>
                            <input type="text" id="info-date-${entryId}" placeholder="15/01 or 15/01/25 or 15-01-2025">
                        </div>
                        <div class="form-group">
                            <label for="info-notes-${entryId}">Information Details:</label>
                            <textarea id="info-notes-${entryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;"></textarea>
                        </div>
                    </div>
                </div>
            `;
            
            entriesContainer.insertAdjacentHTML('beforeend', entryHtml);
            
            // Auto-fill today's date
            const dateField = document.getElementById(`info-date-${entryId}`);
            if (dateField) {
                dateField.value = getTodaysDateEuropean();
                dateField.focus({ preventScroll: true });
            }
            
            // Add auto-update listener
            const dateInput = document.getElementById(`info-date-${entryId}`);
            const notesInput = document.getElementById(`info-notes-${entryId}`);
            
            if (dateInput) {
                dateInput.addEventListener('input', () => generatePreview());
            }
            if (notesInput) {
                notesInput.addEventListener('input', () => generatePreview());
            }
        }

        // Remove info entry
        function removeInfoEntry(entryId) {
            const entry = document.getElementById(entryId);
            if (entry) {
                entry.remove();
                
                // Renumber remaining entries
                const storyId = entryId.split('-')[2]; // Extract storyId from entryId
                const entriesContainer = document.getElementById(`info-entries-${storyId}`);
                if (entriesContainer) {
                    const remainingEntries = entriesContainer.querySelectorAll('.info-entry');
                    remainingEntries.forEach((entry, index) => {
                        const header = entry.querySelector('strong');
                        if (header) {
                            header.textContent = `Info Entry #${index + 1}`;
                        }
                    });
                }
                
                generatePreview();
            }
        }

        // Convert single info entry to multiple instances format
        function convertSingleInfoToMultiple(storyId) {
            const infoEntriesContainer = document.getElementById(`info-entries-${storyId}`);
            if (!infoEntriesContainer) return;
            
            // Check if there are any existing entries
            const existingEntries = infoEntriesContainer.querySelectorAll('.info-entry');
            if (existingEntries.length > 0) return; // Already converted or has entries
            
            // Check if there's old single info data
            const oldInfoDateEl = document.getElementById(`info-date-${storyId}`);
            const oldInfoNotesEl = document.getElementById(`info-notes-${storyId}`);
            
            if (oldInfoDateEl && oldInfoNotesEl && (oldInfoDateEl.value || oldInfoNotesEl.value)) {
                // Convert the old single entry to the new format
                const entryId = `info-entry-${storyId}-${Date.now()}`;
                const entryHtml = `
                    <div id="${entryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong>Info Entry #${entryNumber}</strong>
                            <button type="button" onclick="removeInfoEntry('${entryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                        </div>
                        <div class="inline-group">
                            <div class="form-group">
                                <label for="info-date-${entryId}">Info Date:</label>
                                <input type="text" id="info-date-${entryId}" placeholder="15/01 or 15/01/25 or 15-01-2025" value="${oldInfoDateEl.value}">
                            </div>
                            <div class="form-group">
                                <label for="info-notes-${entryId}">Information Details:</label>
                                <textarea id="info-notes-${entryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;">${oldInfoNotesEl.value}</textarea>
                            </div>
                        </div>
                    </div>
                `;
                infoEntriesContainer.insertAdjacentHTML('beforeend', entryHtml);
                
                // Add auto-update listeners
                const dateInput = document.getElementById(`info-date-${entryId}`);
                const notesInput = document.getElementById(`info-notes-${entryId}`);
                if (dateInput) dateInput.addEventListener('input', () => generatePreview());
                if (notesInput) notesInput.addEventListener('input', () => generatePreview());
                
                // Clear the old fields
                oldInfoDateEl.value = '';
                oldInfoNotesEl.value = '';
            }
        }

        // Modal-specific info entry functions
        let editInfoEntryCounter = 0;

        function addEditInfoEntry() {
            const entriesContainer = document.getElementById('editInfoEntries');
            const entryId = `edit-info-entry-${editInfoEntryCounter++}`;
            
            // Count existing entries to get the next number
            const existingEntries = entriesContainer.querySelectorAll('.info-entry');
            const entryNumber = existingEntries.length + 1;
            
            const entryHtml = `
                <div id="${entryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong>Info Entry #${entryNumber}</strong>
                        <button type="button" onclick="removeEditInfoEntry('${entryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                    </div>
                    <div class="inline-group">
                        <div class="form-group">
                            <label for="edit-info-date-${entryId}">Info Date:</label>
                            <input type="text" id="edit-info-date-${entryId}" placeholder="15/01 or 15/01/25 or 15-01-2025">
                        </div>
                        <div class="form-group">
                            <label for="edit-info-notes-${entryId}">Information Details:</label>
                            <textarea id="edit-info-notes-${entryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;"></textarea>
                        </div>
                    </div>
                </div>
            `;
            
            entriesContainer.insertAdjacentHTML('beforeend', entryHtml);
            
            // Auto-fill today's date
            const dateField = document.getElementById(`edit-info-date-${entryId}`);
            if (dateField) {
                dateField.value = getTodaysDateEuropean();
                dateField.focus({ preventScroll: true });
            }
        }

        function removeEditInfoEntry(entryId) {
            const entry = document.getElementById(entryId);
            if (entry) {
                entry.remove();
            }
        }

        function handleTransferredOutChange(storyId) {
            handleStatusChange(storyId, 'transferredout');
        }

        function handleTransferredInChange(storyId) {
            handleStatusChange(storyId, 'transferredin');
        }

        function handleProposedChange(storyId) {
            handleStatusChange(storyId, 'proposed');
        }
        
        function addChange(storyId) {
            const container = document.getElementById(`changes-container-${storyId}`);
            
            // Check if we've reached the maximum of 5 changes (allowing for 4th delay)
            const existingChanges = container.querySelectorAll(`div[id^="change-${storyId}-change-"]`);
            if (existingChanges.length >= 5) {
                return; // Don't add more changes if limit is reached
            }
            
            // Get current story end date for auto-population
            const currentEndDateElement = document.getElementById(`story-end-${storyId}`);
            const currentEndDate = currentEndDateElement ? currentEndDateElement.value : '';
            
            // Count existing changes to get the next number
            const entryNumber = existingChanges.length + 1;
            
            changeCounter++;
            const changeId = `${storyId}-change-${Date.now()}-${changeCounter}`;
            
            const changeHtml = `
                <div class="form-group" id="change-${changeId}" style="border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong>Timeline #${entryNumber}</strong>
                        <button class="danger" onclick="removeChange('${changeId}', '${storyId}')" tabindex="-1">Remove</button>
                    </div>
                    
                    <div class="inline-group">
                        <div class="form-group">
                            <label>Change Date:</label>
                            <input type="text" id="change-date-${changeId}" placeholder="15/12 or 15/12/24 or 15-12-2024" value="${getTodaysDateEuropean()}">
                        </div>
                        <div class="form-group">
                            <label>Description:</label>
                            <input type="text" id="change-desc-${changeId}" placeholder="Reason for change">
                        </div>
                    </div>
                    
                    <div class="inline-group">
                        <div class="form-group">
                            <label>Previous End Date:</label>
                            <input type="text" id="change-prev-${changeId}" placeholder="31/03 or 31-03" style="margin-bottom: 1px;" value="${currentEndDate}">
                        </div>
                        <div class="form-group">
                            <label>New End Date:</label>
                            <input type="text" id="change-new-${changeId}" placeholder="15/04 or 15-04" style="margin-bottom: 1px;" value="${currentEndDate}">
                        </div>
                    </div>
                </div>
            `;
            
            container.insertAdjacentHTML('beforeend', changeHtml);
            
            // Add auto-update listeners to the new timeline change elements
            const changeFields = [
                `change-date-${changeId}`,
                `change-desc-${changeId}`,
                `change-prev-${changeId}`,
                `change-new-${changeId}`
            ];
            
            // Initialize immediately since timeline changes are only added within expanded EPICs
            changeFields.forEach(fieldId => {
                const element = document.getElementById(fieldId);
                if (element) {
                    addListenersToElement(element);
                    
                    // Initialize date pickers for timeline change date fields
                    if (fieldId.includes('-date-') || fieldId.includes('-prev-') || fieldId.includes('-new-')) {
                        // Timeline change dates are specific dates only
                        initializeDatePicker(element, false);
                    }
                }
            });
            
            // Update the Add Change button state
            updateChangeButton(storyId);
        }
        
        function removeChange(changeId, storyId) {
            document.getElementById(`change-${changeId}`).remove();
            
            // Renumber remaining timeline entries
            const container = document.getElementById(`changes-container-${storyId}`);
            if (container) {
                const remainingChanges = container.querySelectorAll(`div[id^="change-${storyId}-change-"]`);
                remainingChanges.forEach((change, index) => {
                    const header = change.querySelector('strong');
                    if (header) {
                        header.textContent = `Timeline #${index + 1}`;
                    }
                });
            }
            
            // Update the Add Change button state
            updateChangeButton(storyId);
        }
        
        function updateChangeButton(storyId) {
            const container = document.getElementById(`changes-container-${storyId}`);
            const addButton = document.getElementById(`add-change-btn-${storyId}`);
            
            if (!container || !addButton) return;
            
            const existingChanges = container.querySelectorAll(`div[id^="change-${storyId}-change-"]`);
            
            if (existingChanges.length >= 4) {
                addButton.disabled = true;
                addButton.textContent = '+ Add Change (Max 4 reached)';
                addButton.style.opacity = '0.5';
                addButton.style.cursor = 'not-allowed';
            } else {
                addButton.disabled = false;
                addButton.textContent = '+ Add Change';
                addButton.style.opacity = '1';
                addButton.style.cursor = 'pointer';
            }
        }
        
        // Story reordering with up/down arrows
        function moveStoryUp(storyId) {
            const storyElement = document.getElementById(`story-${storyId}`);
            const previousStory = storyElement.previousElementSibling;
            
            if (previousStory && previousStory.classList.contains('story-section')) {
                storyElement.parentNode.insertBefore(storyElement, previousStory);
                updateStoryNumbers(storyElement.closest('.epic-section'));
                
                // Keep focus on the moved story's up button
                setTimeout(() => {
                    const upButton = storyElement.querySelector('button[onclick*="moveStoryUp"]');
                    if (upButton) upButton.focus({ preventScroll: true });
                }, 10);
                
                setTimeout(generatePreview, 100);
            }
        }
        
        function moveStoryDown(storyId) {
            const storyElement = document.getElementById(`story-${storyId}`);
            const nextStory = storyElement.nextElementSibling;
            
            if (nextStory && nextStory.classList.contains('story-section')) {
                const afterNext = nextStory.nextElementSibling;
                if (afterNext) {
                    storyElement.parentNode.insertBefore(storyElement, afterNext);
                } else {
                    storyElement.parentNode.appendChild(storyElement);
                }
                updateStoryNumbers(storyElement.closest('.epic-section'));
                
                // Keep focus on the moved story's down button
                setTimeout(() => {
                    const downButton = storyElement.querySelector('button[onclick*="moveStoryDown"]');
                    if (downButton) downButton.focus({ preventScroll: true });
                }, 10);
                
                setTimeout(generatePreview, 100);
            }
        }
        
        function updateStoryNumbers(epicElement) {
            const stories = epicElement.querySelectorAll('.story-section');
            stories.forEach((story, index) => {
                const storyNumber = index + 1;
                const titleElement = story.querySelector('h4');
                if (titleElement) {
                    titleElement.textContent = `üìã Story ${storyNumber}`;
                }
            });
        }
        
        // Move story functions that work with epic name and story index from roadmap preview
        function moveStoryUpByEpic(epicName, storyIndex) {
            // Find the EPIC section by name
            const epicElements = document.querySelectorAll('.epic-section');
            let targetEpicElement = null;
            
            epicElements.forEach(epicEl => {
                const epicId = epicEl.id.split('-')[1];
                const epicNameEl = document.getElementById(`epic-name-${epicId}`);
                if (epicNameEl && epicNameEl.value.trim() === epicName) {
                    targetEpicElement = epicEl;
                }
            });
            
            if (!targetEpicElement) {
                console.error('Could not find EPIC:', epicName);
                return;
            }
            
            // Get all story elements in this EPIC
            const storyElements = targetEpicElement.querySelectorAll('.story-section');
            if (storyIndex <= 0 || storyIndex >= storyElements.length) {
                return;
            }
            
            // Get the story element to move and the one before it
            const storyToMove = storyElements[storyIndex];
            const previousStory = storyElements[storyIndex - 1];
            
            // Move the story up by inserting it before the previous story
            storyToMove.parentNode.insertBefore(storyToMove, previousStory);
            
            // Update story numbers
            updateStoryNumbers(targetEpicElement);
            
            // Regenerate preview after a short delay
            setTimeout(generatePreview, 100);
        }
        
        function moveStoryDownByEpic(epicName, storyIndex) {
            // Find the EPIC section by name
            const epicElements = document.querySelectorAll('.epic-section');
            let targetEpicElement = null;
            
            epicElements.forEach(epicEl => {
                const epicId = epicEl.id.split('-')[1];
                const epicNameEl = document.getElementById(`epic-name-${epicId}`);
                if (epicNameEl && epicNameEl.value.trim() === epicName) {
                    targetEpicElement = epicEl;
                }
            });
            
            if (!targetEpicElement) {
                return;
            }
            
            // Get all story elements in this EPIC
            const storyElements = targetEpicElement.querySelectorAll('.story-section');
            if (storyIndex < 0 || storyIndex >= storyElements.length - 1) {
                return;
            }
            
            // Get the story element to move and the one after it
            const storyToMove = storyElements[storyIndex];
            const nextStory = storyElements[storyIndex + 1];
            
            // Move the story down by inserting it after the next story
            const afterNext = nextStory.nextElementSibling;
            if (afterNext) {
                storyToMove.parentNode.insertBefore(storyToMove, afterNext);
            } else {
                storyToMove.parentNode.appendChild(storyToMove);
            }
            
            // Update story numbers
            updateStoryNumbers(targetEpicElement);
            
            // Regenerate preview after a short delay
            setTimeout(generatePreview, 100);
        }
        
        function generatePreview() {
            if (isGeneratingPreview) return;
            isGeneratingPreview = true;
            
            try {
                // Check if RoadmapGenerator is available
                if (typeof RoadmapGenerator === 'undefined') {
                    console.error('RoadmapGenerator is undefined');
                    const iframe = document.getElementById('preview-area');
                    iframe.srcdoc = `<html><body><div style="padding: 20px; text-align: center; color: red;">
                        <h3>RoadmapGenerator Not Loaded</h3>
                        <p>The roadmap-generator.js file failed to load. Please:</p>
                        <ul style="text-align: left; max-width: 400px; margin: 0 auto;">
                            <li>Make sure both files are in the same folder</li>
                            <li>Use a local web server (like <code>python3 -m http.server 8000</code>)</li>
                            <li>Check the browser console for JavaScript errors</li>
                            <li>Refresh the page and try again</li>
                        </ul>
                    </div></body></html>`;
                    return;
                }
                
                // Check if DateUtility is available 
                if (typeof DateUtility === 'undefined') {
                    console.error('DateUtility is undefined');
                    const iframe = document.getElementById('preview-area');
                    iframe.srcdoc = `<html><body><div style="padding: 20px; text-align: center; color: red;">
                        <h3>DateUtility Not Loaded</h3>
                        <p>The utilities/date-utility.js file failed to load properly. Please refresh the page.</p>
                    </div></body></html>`;
                    return;
                }
                

                
                const teamData = collectFormData();
                
                const generator = new RoadmapGenerator(teamData.roadmapYear);
                
                // Create roadmap for preview (no scaling needed with vertical layout)
                const previewHtml = generator.generateRoadmap(teamData, true, true); // embedded=true, enableEditing=true
                
                const iframe = document.getElementById('preview-area');
                iframe.srcdoc = previewHtml;
                
                // Setup iframe interaction after it loads
                iframe.onload = function() {
                    // Add a longer delay to ensure all content is fully rendered
                    setTimeout(() => {
                        initializeIframeInteraction(iframe);
                    }, 100);
                };
                
                // Store the teamData for fullscreen generation when needed, but don't generate it now
                window.currentTeamData = teamData;
                
                // Fallback: if srcdoc doesn't work, try data URL
                setTimeout(() => {
                    if (!iframe.contentDocument || !iframe.contentDocument.body || !iframe.contentDocument.body.innerHTML) {
                        const dataUrl = 'data:text/html;charset=utf-8,' + encodeURIComponent(previewHtml);
                        iframe.src = dataUrl;
                    }
                }, 100);
                
            } catch (error) {
                const iframe = document.getElementById('preview-area');
                iframe.srcdoc = `<html><body><div style="padding: 20px; text-align: center; color: red;">
                    <h3>Error generating roadmap</h3>
                    <p>${error.message}</p>
                    <p style="font-size: 12px; margin-top: 20px;">Please check your data and try again.</p>
                </div></body></html>`;
            } finally {
                isGeneratingPreview = false;
            }
        }
        
        function initializeIframeInteraction(iframe) {
            try {
                // Wait a bit for iframe content to fully load
                setTimeout(() => {
                    const setupStoryInteraction = () => {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        const storyItems = iframeDoc.querySelectorAll('.story-item, .ktlo-story');
                        
                        if (storyItems.length === 0) {
                            // Retry after 200ms  
                            setTimeout(setupStoryInteraction, 200);
                            return;
                        }
                        
                        // Setup January/December monthly box priming for iframe
                        setupMonthlyBoxPriming(iframeDoc, iframe.contentWindow);
                        
                        storyItems.forEach((story, index) => {
                            // Add single-click event listener to open edit modal
                            story.addEventListener('click', function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                
                                const storyData = {
                                    epicName: this.dataset.epicName,
                                    storyTitle: this.dataset.storyTitle,
                                    storyIndex: this.dataset.storyIndex
                                };
                                
                                // Call parent window function to open the edit modal
                                parent.openEditStoryModal(storyData);
                            });
                            
                            // Add double-click event listener to open edit modal (kept for consistency)
                            story.addEventListener('dblclick', function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                
                                const storyData = {
                                    epicName: this.dataset.epicName,
                                    storyTitle: this.dataset.storyTitle,
                                    storyIndex: this.dataset.storyIndex
                                };
                                
                                // Call parent window function to open the edit modal
                                parent.openEditStoryModal(storyData);
                            });
                            
                            // Add visual indicator that stories are clickable
                            story.style.cursor = 'pointer';
                        });
                    };
                    
                    // Start the setup process
                    setupStoryInteraction();
                    
                    // Add draggable alignment guide
                    addAlignmentGuide(iframe);
                    
                }, 500); // Wait 500ms for iframe content to fully render
                
            } catch (error) {
                // Story interaction initialization failed, continue without it
            }
        }
        
        function addAlignmentGuide(iframe) {
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                const roadmapContainer = iframeDoc.querySelector('.roadmap-container');
                
                if (!roadmapContainer) {
                    return; // No roadmap container found
                }
                
                // Create the alignment guide line
                const guideLine = iframeDoc.createElement('div');
                guideLine.id = 'alignment-guide';
                guideLine.style.cssText = `
                    position: absolute;
                    left: 0;
                    right: 0;
                    height: 2px;
                    background-color: #ff6b6b;
                    border: 1px solid #ff5252;
                    top: 50%;
                    z-index: 1000;
                    cursor: ns-resize;
                    opacity: 0.7;
                    box-shadow: 0 0 4px rgba(255, 107, 107, 0.5);
                    pointer-events: auto;
                    display: none;
                `;
                
                // Add a small handle in the center for easier grabbing
                const handle = iframeDoc.createElement('div');
                handle.style.cssText = `
                    position: absolute;
                    left: 50%;
                    top: -4px;
                    width: 40px;
                    height: 10px;
                    background-color: #ff6b6b;
                    border: 1px solid #ff5252;
                    border-radius: 5px;
                    transform: translateX(-50%);
                    cursor: ns-resize;
                `;
                guideLine.appendChild(handle);
                
                // Make the roadmap container relatively positioned if it isn't already
                const containerStyle = iframe.contentWindow.getComputedStyle(roadmapContainer);
                if (containerStyle.position === 'static') {
                    roadmapContainer.style.position = 'relative';
                }
                
                // Add the guide line to the roadmap container
                roadmapContainer.appendChild(guideLine);
                
                // Make it draggable
                let isDragging = false;
                let startY = 0;
                let startTop = 0;
                
                const onMouseDown = (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    const rect = roadmapContainer.getBoundingClientRect();
                    startTop = guideLine.offsetTop;
                    
                    // Change opacity while dragging
                    guideLine.style.opacity = '1';
                    
                    // Prevent text selection
                    iframeDoc.body.style.userSelect = 'none';
                    e.preventDefault();
                };
                
                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    
                    const deltaY = e.clientY - startY;
                    const newTop = startTop + deltaY;
                    const containerHeight = roadmapContainer.offsetHeight;
                    
                    // Constrain within roadmap container bounds
                    const clampedTop = Math.max(0, Math.min(newTop, containerHeight - 4));
                    guideLine.style.top = clampedTop + 'px';
                    
                    e.preventDefault();
                };
                
                const onMouseUp = (e) => {
                    if (isDragging) {
                        isDragging = false;
                        guideLine.style.opacity = '0.7';
                        iframeDoc.body.style.userSelect = '';
                    }
                };
                
                // Add event listeners
                guideLine.addEventListener('mousedown', onMouseDown);
                iframeDoc.addEventListener('mousemove', onMouseMove);
                iframeDoc.addEventListener('mouseup', onMouseUp);
                
                // Also listen on the parent window to handle mouse leaving iframe
                window.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        // Convert parent window coordinates to iframe coordinates
                        const iframeRect = iframe.getBoundingClientRect();
                        const iframeEvent = {
                            clientY: e.clientY - iframeRect.top
                        };
                        onMouseMove(iframeEvent);
                    }
                });
                
                window.addEventListener('mouseup', onMouseUp);
                
                // Toggle function for keyboard shortcut
                const toggleAlignmentGuide = () => {
                    const isVisible = guideLine.style.display !== 'none';
                    guideLine.style.display = isVisible ? 'none' : 'block';
                };
                
                // Keyboard shortcut handler (Cmd+Shift+L or Ctrl+Shift+L)
                const handleKeydown = (e) => {
                    if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'l') {
                        e.preventDefault();
                        toggleAlignmentGuide();
                    }
                };
                
                // Add keyboard listeners to both iframe and parent window
                iframeDoc.addEventListener('keydown', handleKeydown);
                window.addEventListener('keydown', handleKeydown);
                
                // Store the toggle function globally so it can be called from elsewhere if needed
                iframe.contentWindow.toggleAlignmentGuide = toggleAlignmentGuide;
                
                // Log the keyboard shortcut for user reference
                
                
            } catch (error) {
                
            }
        }
        
        function collectFormData() {
            const teamData = {
                roadmapYear: parseInt(document.getElementById('roadmapYear').value) || 2025,
                teamName: document.getElementById('teamName').value || 'My Team',
                directorVP: document.getElementById('directorVP').value || '',
                em: document.getElementById('em').value || 'Engineering Manager',
                pm: document.getElementById('pm').value || 'Product Manager',
                description: [],
                epics: []
            };
            
            // Collect description
            const description = document.getElementById('teamDescription').value;
            if (description && description.trim()) {
                teamData.description = description.trim();
            }
            
            // Collect EPICs
            const epicElements = document.querySelectorAll('.epic-section');
            epicElements.forEach(epicEl => {
                const epicId = epicEl.id.split('-')[1];
                const epicNameEl = document.getElementById(`epic-name-${epicId}`);
                const epicUniqueIdEl = document.getElementById(`epic-id-${epicId}`);
                
                // Ensure we always have a valid EPIC name
                let epicName = `EPIC ${epicId}`; // Default fallback
                if (epicNameEl && epicNameEl.value !== null && epicNameEl.value !== undefined) {
                    const inputValue = String(epicNameEl.value).trim();
                    if (inputValue.length > 0) {
                        epicName = inputValue;
                    }
                }
                
                // Skip invalid EPICs (missing name element or ID)
                if (!epicNameEl || !epicId || epicId === 'undefined' || epicId === 'null') {

                    return; // Skip this EPIC
                }
                
                const epic = {
                    name: epicName,
                    epicId: epicUniqueIdEl ? epicUniqueIdEl.value : null, // Add unique EPIC ID
                    stories: []
                };
                
                // Collect stories for this EPIC
                const storyElements = epicEl.querySelectorAll('.story-section');
                const stories = [];
                storyElements.forEach(storyEl => {
                    const storyId = storyEl.id.replace('story-', '');
                    try {
                        const story = collectStoryData(storyId);
                        // Add story as-is without modifying the title
                        stories.push(story);
                    } catch (error) {
                        // Add a basic story if collection fails
                        stories.push({
                            title: `Story ${stories.length + 1}`,
                            startMonth: 'JAN',
                            endMonth: 'MAR',
                            bullets: ['Default story']
                        });
                    }
                });
                
                // Sort stories if the feature is enabled
                const sortByStart = getConfigUtility().shouldSortStories() || getConfigUtility().shouldSortByStart();
                const sortByEnd = getConfigUtility().shouldSortByEnd();
                if (sortByStart || sortByEnd) {
                    stories.sort((a, b) => {
                        const aStart = a.startDate || a.startMonth || 'JAN';
                        const bStart = b.startDate || b.startMonth || 'JAN';
                        const aEnd = a.endDate || a.endMonth || 'MAR';
                        const bEnd = b.endDate || b.endMonth || 'MAR';
                        const year = parseInt(document.getElementById('roadmapYear').value) || 2025;
                        if (sortByEnd) {
                            const endComparison = getDateUtility().compareDateOrMonth(aEnd, bEnd, year);
                            if (endComparison !== 0) return endComparison;
                            return getDateUtility().compareDateOrMonth(aStart, bStart, year);
                        } else {
                            const startComparison = getDateUtility().compareDateOrMonth(aStart, bStart, year);
                            if (startComparison !== 0) return startComparison;
                            return getDateUtility().compareDateOrMonth(aEnd, bEnd, year);
                        }
                    });
                }
                
                epic.stories = stories;
                
                teamData.epics.push(epic);
            });
            
            // Collect KTLO data from form with fallback
            try {
                teamData.ktloSwimlane = collectKTLOData();
            } catch (error) {
                console.error('KTLO Collection Error:', error);
                
                // Provide fallback KTLO data
                teamData.ktloSwimlane = {
                    position: "bottom",
                    story: {
                        title: "KTLO",
                        bullets: ["Keep the Lights On", "Operational Excellence", "Infrastructure Maintenance"]
                    },
                    monthlyData: [
                        { month: "JAN", number: 15, percentage: 85, description: "Server Maintenance" },
                        { month: "FEB", number: 12, percentage: 90, description: "Database optimization" },
                        { month: "MAR", number: 18, percentage: 88, description: "Security patches and monitoring" },
                        { month: "APR", number: 14, percentage: 92, description: "Performance tuning" },
                        { month: "MAY", number: 16, percentage: 87, description: "Backup system upgrades" },
                        { month: "JUN", number: 13, percentage: 94, description: "Network infrastructure review" },
                        { month: "JUL", number: 17, percentage: 89, description: "Application health checks" },
                        { month: "AUG", number: 11, percentage: 93, description: "Documentation updates" },
                        { month: "SEP", number: 19, percentage: 86, description: "Disaster recovery testing" },
                        { month: "OCT", number: 15, percentage: 91, description: "Capacity planning review" },
                        { month: "NOV", number: 13, percentage: 95, description: "Year-end maintenance" },
                        { month: "DEC", number: 10, percentage: 88, description: "Holiday coverage" }
                    ]
                };
            }
            
            // Collect BTL data
            try {
                teamData.btlSwimlane = collectBTLData();
            } catch (error) {
                // Provide fallback BTL data
                teamData.btlSwimlane = {
                    stories: [] // Empty by default
                };
            }
            
            return teamData;
        }
        
        function collectStoryData(storyId) {
            const titleEl = document.getElementById(`story-title-${storyId}`);
            const storyUniqueIdEl = document.getElementById(`story-id-${storyId}`);
            const story = {
                title: titleEl ? titleEl.value || '' : '',
                storyId: storyUniqueIdEl ? storyUniqueIdEl.value : null, // Add unique Story ID
            };
            
            // Handle start/end dates
            const startEl = document.getElementById(`story-start-${storyId}`);
            const endEl = document.getElementById(`story-end-${storyId}`);
            const start = startEl ? startEl.value : '';
            const end = endEl ? endEl.value : '';
            
            // Helper function to ensure date has year and uses consistent "/" separator
            const ensureDateHasYear = (dateStr) => {
                if (!dateStr) return dateStr;
                // If date is in dd/mm or dd-mm format without year, normalize to "/" and add year
                if (/^\d{1,2}[\/\-]\d{1,2}$/.test(dateStr)) {
                    const roadmapYear = parseInt(document.getElementById('roadmapYear').value) || new Date().getFullYear();
                    // Replace all "-" with "/" for consistency, then add year
                    const normalizedDate = dateStr.replace(/-/g, '/');
                    return normalizedDate + '/' + roadmapYear;
                }
                return dateStr;
            };
            
            // Determine if it's a month or date format
            if (start) {
                // Check for date formats: ISO (YYYY-MM-DD) or European (DD/MM or DD/MM/YYYY)
                if (start.includes('-') || start.match(/^\d{1,2}[\/\-]\d{1,2}([\/\-]\d{2,4})?$/)) {
                    story.startDate = ensureDateHasYear(start);
                } else {
                    story.startMonth = start.toUpperCase();
                }
            } else {
                // Default start month if not provided
                story.startMonth = 'JAN';
            }
            
            if (end) {
                // Check for date formats: ISO (YYYY-MM-DD) or European (DD/MM or DD/MM/YYYY)
                if (end.includes('-') || end.match(/^\d{1,2}[\/\-]\d{1,2}([\/\-]\d{2,4})?$/)) {
                    story.endDate = ensureDateHasYear(end);
                } else {
                    story.endMonth = end.toUpperCase();
                }
            } else {
                // Default end month if not provided
                story.endMonth = 'MAR';
            }
            
            // Handle bullets
            const bulletsEl = document.getElementById(`story-bullets-${storyId}`);
            const bullets = bulletsEl ? bulletsEl.value : '';
            if (bullets) {
                story.bullets = bullets.split('\n').filter(line => line.trim());
            }
            
            // Handle IMO
            const imoEl = document.getElementById(`story-imo-${storyId}`);
            const imo = imoEl ? imoEl.value.trim() : '';
            if (imo) {
                story.imo = imo;
            }
            
            // Handle status flags
            const doneEl = document.getElementById(`story-done-${storyId}`);
            const cancelledEl = document.getElementById(`story-cancelled-${storyId}`);
            const atRiskEl = document.getElementById(`story-atrisk-${storyId}`);
            const newStoryEl = document.getElementById(`story-newstory-${storyId}`);
            const infoEl = document.getElementById(`story-info-${storyId}`);
            const transferredOutEl = document.getElementById(`story-transferredout-${storyId}`);
            const transferredInEl = document.getElementById(`story-transferredin-${storyId}`);
            const proposedEl = document.getElementById(`story-proposed-${storyId}`);
            
            story.isDone = doneEl ? doneEl.checked : false;
            story.isCancelled = cancelledEl ? cancelledEl.checked : false;
            story.isAtRisk = atRiskEl ? atRiskEl.checked : false;
            story.isNewStory = newStoryEl ? newStoryEl.checked : false;
            story.isInfo = infoEl ? infoEl.checked : false;
            story.isTransferredOut = transferredOutEl ? transferredOutEl.checked : false;
            story.isTransferredIn = transferredInEl ? transferredInEl.checked : false;
            story.isProposed = proposedEl ? proposedEl.checked : false;
            
            // Collect done info (regardless of timeline changes checkbox)
            const doneDateEl = document.getElementById(`done-date-${storyId}`);
            const doneNotesEl = document.getElementById(`done-notes-${storyId}`);
            const doneDate = doneDateEl ? doneDateEl.value : '';
            const doneNotes = doneNotesEl ? doneNotesEl.value : '';
            
            // Collect cancel info (regardless of timeline changes checkbox)  
            const cancelDateEl = document.getElementById(`cancel-date-${storyId}`);
            const cancelNotesEl = document.getElementById(`cancel-notes-${storyId}`);
            const cancelDate = cancelDateEl ? cancelDateEl.value : '';
            const cancelNotes = cancelNotesEl ? cancelNotesEl.value : '';
            
            // Collect at risk info (regardless of timeline changes checkbox)  
            const atRiskDateEl = document.getElementById(`atrisk-date-${storyId}`);
            const atRiskNotesEl = document.getElementById(`atrisk-notes-${storyId}`);
            const atRiskDate = atRiskDateEl ? atRiskDateEl.value : '';
            const atRiskNotes = atRiskNotesEl ? atRiskNotesEl.value : '';
            
            // Collect new story info (regardless of timeline changes checkbox)  
            const newStoryDateEl = document.getElementById(`newstory-date-${storyId}`);
            const newStoryNotesEl = document.getElementById(`newstory-notes-${storyId}`);
            const newStoryDate = newStoryDateEl ? newStoryDateEl.value : '';
            const newStoryNotes = newStoryNotesEl ? newStoryNotesEl.value : '';
            
            // Collect info info (regardless of timeline changes checkbox)  
            const infoEntries = [];
            const infoEntriesContainer = document.getElementById(`info-entries-${storyId}`);
            if (infoEntriesContainer) {
                const entryElements = infoEntriesContainer.querySelectorAll('.info-entry');
                entryElements.forEach(entry => {
                    const entryId = entry.id;
                    const dateEl = document.getElementById(`info-date-${entryId}`);
                    const notesEl = document.getElementById(`info-notes-${entryId}`);
                    if (dateEl && notesEl) {
                        // Include entry even if empty, but only if the entry exists
                        infoEntries.push({
                            date: dateEl.value || '',
                            notes: notesEl.value || ''
                        });
                    }
                });
            }
            
            // Fallback: check for old single info fields
            if (infoEntries.length === 0) {
                const oldInfoDateEl = document.getElementById(`info-date-${storyId}`);
                const oldInfoNotesEl = document.getElementById(`info-notes-${storyId}`);
                if (oldInfoDateEl && oldInfoNotesEl && (oldInfoDateEl.value || oldInfoNotesEl.value)) {
                    infoEntries.push({
                        date: oldInfoDateEl.value,
                        notes: oldInfoNotesEl.value
                    });
                }
            }
            
                        // Collect transferred out info (regardless of timeline changes checkbox)
            const transferredOutDateEl = document.getElementById(`transferredout-date-${storyId}`);
            const transferredOutNotesEl = document.getElementById(`transferredout-notes-${storyId}`);
            const transferredOutDate = transferredOutDateEl ? transferredOutDateEl.value : '';
            const transferredOutNotes = transferredOutNotesEl ? transferredOutNotesEl.value : '';
            
            // Collect transferred in info (regardless of timeline changes checkbox)
            const transferredInDateEl = document.getElementById(`transferredin-date-${storyId}`);
            const transferredInNotesEl = document.getElementById(`transferredin-notes-${storyId}`);
            const transferredInDate = transferredInDateEl ? transferredInDateEl.value : '';
            const transferredInNotes = transferredInNotesEl ? transferredInNotesEl.value : '';
            
            // Collect proposed info (regardless of timeline changes checkbox)
            const proposedDateEl = document.getElementById(`proposed-date-${storyId}`);
            const proposedNotesEl = document.getElementById(`proposed-notes-${storyId}`);
            const proposedDate = proposedDateEl ? proposedDateEl.value : '';
            const proposedNotes = proposedNotesEl ? proposedNotesEl.value : '';
            
            // Check if we need to create roadmap changes for timeline changes, done, cancel, at risk, new story, or transferred out
            const timelineChangesEl = document.getElementById(`story-changes-${storyId}`);
            const hasTimelineChanges = timelineChangesEl ? timelineChangesEl.checked : false;
            
            // FOR TEXT BOX WIDTH: Count only checked checkboxes (consistent with display logic)
            const hasDoneInfo = (doneEl ? doneEl.checked : false);
            const hasCancelInfo = (cancelledEl ? cancelledEl.checked : false);
            const hasAtRiskInfo = (atRiskEl ? atRiskEl.checked : false);
            const hasNewStoryInfo = (newStoryEl ? newStoryEl.checked : false);
            const hasInfoInfo = (infoEl ? infoEl.checked : false);
            const hasTransferredOutInfo = (transferredOutEl ? transferredOutEl.checked : false);
            const hasTransferredInInfo = (transferredInEl ? transferredInEl.checked : false);
            const hasProposedInfo = (proposedEl ? proposedEl.checked : false);
            
            if (hasTimelineChanges || hasDoneInfo || hasCancelInfo || hasAtRiskInfo || hasNewStoryInfo || hasInfoInfo || hasTransferredOutInfo || hasTransferredInInfo || hasProposedInfo) {
                story.hasRoadmapChanges = true;
                story.roadmapChanges = {
                    changes: [],
                    doneInfo: null,
                    cancelInfo: null,
                    atRiskInfo: null,
                    newStoryInfo: null,
                    infoInfo: null,
                    transferredOutInfo: null,
                    transferredInInfo: null,
                    proposedInfo: null
                };
                
                // Collect timeline changes (only if checkbox is checked)
                if (hasTimelineChanges) {
                    // Find only the container divs (not the individual input fields)
                    const changeContainers = document.querySelectorAll(`#changes-container-${storyId} > div[id^="change-${storyId}-change-"]`);

                    changeContainers.forEach((changeEl, index) => {
                        // Use the full ID minus the "change-" prefix: "1-4-change-1750523789967"
                        const changeId = changeEl.id.replace('change-', ''); // Get: "1-4-change-1750523789967"
                        const date = document.getElementById(`change-date-${changeId}`)?.value;
                        const prevEnd = document.getElementById(`change-prev-${changeId}`)?.value;
                        const newEnd = document.getElementById(`change-new-${changeId}`)?.value;
                        const desc = document.getElementById(`change-desc-${changeId}`)?.value;
                        
                        if (date && prevEnd && newEnd) {
                            story.roadmapChanges.changes.push({
                                date: ensureDateHasYear(date),
                                prevEndDate: ensureDateHasYear(prevEnd),
                                newEndDate: ensureDateHasYear(newEnd),
                                description: desc || 'Story timeline change'
                            });
                        }
                    });

                    // Update story's actual end date to reflect the most recent timeline change
                    if (story.roadmapChanges.changes.length > 0) {
                        // Sort timeline changes by date (most recent first)
                        const sortedChanges = [...story.roadmapChanges.changes].sort((a, b) => {
                            return DateUtility.compareDates(b.date, a.date); // Reverse order for most recent first
                        });
                        
                        // Get the newEndDate from the most recent change
                        const mostRecentChange = sortedChanges[0];
                        if (mostRecentChange && mostRecentChange.newEndDate) {
                            const newEndDate = mostRecentChange.newEndDate;
                            
                            // Determine if this is a date or month format and update accordingly
                            if (newEndDate.includes('-') || newEndDate.match(/^\d{1,2}[\/\-]\d{1,2}([\/\-]\d{2,4})?$/)) {
                                // It's a date format - update endDate and clear endMonth (already has year from ensureDateHasYear above)
                                story.endDate = newEndDate;
                                delete story.endMonth;
                                
                                // Update the form field so user sees the change
                                const endEl = document.getElementById(`story-end-${storyId}`);
                                if (endEl) endEl.value = newEndDate;
                            } else {
                                // It's a month format - update endMonth and clear endDate
                                story.endMonth = newEndDate.toUpperCase();
                                delete story.endDate;
                                
                                // Update the form field so user sees the change
                                const endEl = document.getElementById(`story-end-${storyId}`);
                                if (endEl) endEl.value = newEndDate.toUpperCase();
                            }
                        }
                    }
                }
                
                // FOR ROADMAP DATA: Only add if checkbox is checked (regardless of existing date/notes)
                if (story.isDone) {
                    story.roadmapChanges.doneInfo = {
                        date: ensureDateHasYear(doneDate) || '',
                        notes: doneNotes || ''
                    };
                }
                
                if (story.isCancelled) {
                    story.roadmapChanges.cancelInfo = {
                        date: ensureDateHasYear(cancelDate) || '',
                        notes: cancelNotes || ''
                    };
                }
                
                if (story.isAtRisk) {
                    story.roadmapChanges.atRiskInfo = {
                        date: ensureDateHasYear(atRiskDate) || '',
                        notes: atRiskNotes || ''
                    };
                }
                
                if (story.isNewStory) {
                    story.roadmapChanges.newStoryInfo = {
                        date: ensureDateHasYear(newStoryDate) || '',
                        notes: newStoryNotes || ''
                    };
                }
                
                if (story.isInfo) {
                    story.roadmapChanges.infoInfo = infoEntries.length > 0 ? infoEntries : [];
                }
                
                if (story.isTransferredOut) {
                    story.roadmapChanges.transferredOutInfo = {
                        date: ensureDateHasYear(transferredOutDate) || '',
                        notes: transferredOutNotes || ''
                    };
                }
                
                if (story.isTransferredIn) {
                    story.roadmapChanges.transferredInInfo = {
                        date: ensureDateHasYear(transferredInDate) || '',
                        notes: transferredInNotes || ''
                    };
                }
                
                if (story.isProposed) {
                    story.roadmapChanges.proposedInfo = {
                        date: ensureDateHasYear(proposedDate) || '',
                        notes: proposedNotes || ''
                    };
                }
            }
            
            return story;
        }
        
        function collectKTLOData() {
            const ktloTitleEl = document.getElementById('ktlo-title');
            const ktloBulletsEl = document.getElementById('ktlo-bullets');
            const ktloPositionEl = document.getElementById('ktlo-position-toggle');
            
            const ktloTitle = ktloTitleEl ? ktloTitleEl.value || 'KTLO' : 'KTLO';
            const ktloBulletsText = ktloBulletsEl ? ktloBulletsEl.value || 'Keep the Lights On\nOperational Excellence\nInfrastructure Maintenance' : 'Keep the Lights On\nOperational Excellence\nInfrastructure Maintenance';
            const ktloBullets = ktloBulletsText.split('\n').filter(line => line.trim());
            const ktloPosition = ktloPositionEl ? (ktloPositionEl.checked ? 'top' : 'bottom') : 'bottom';
            
            // Save currently displayed month before collecting data
            saveCurrentKTLOData();
            
            const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
            const monthlyData = [];
            
            months.forEach(month => {
                const monthLower = month.toLowerCase();
                const data = ktloMonthlyData[monthLower];
                
                const number = data && data.number ? parseInt(data.number) || 0 : 0;
                const percentageValue = data && data.percentage ? data.percentage : '';
                
                // Validate percentage before saving
                if (percentageValue !== '' && !validateKTLOPercentage(percentageValue)) {
                    throw new Error(`Invalid KTLO percentage for ${month}: "${percentageValue}". Must be blank or a multiple of 5 between 0 and 100.`);
                }
                
                const percentage = percentageValue !== '' ? parseInt(percentageValue) || 0 : 0;
                const description = data && data.description ? data.description : '';
                
                monthlyData.push({
                    month: month,
                    number: number,
                    percentage: percentage,
                    description: description
                });
            });
            
            return {
                position: ktloPosition,
                story: {
                    title: ktloTitle,
                    bullets: ktloBullets
                },
                monthlyData: monthlyData
            };
        }
        
        function collectBTLData() {
            const stories = [];
            
            // Collect all BTL stories
            const btlStoryElements = document.querySelectorAll('#btl-stories-container .story-section');
            btlStoryElements.forEach(storyEl => {
                const storyId = storyEl.id.replace('story-', '');
                
                const titleEl = document.getElementById(`btl-title-${storyId}`);
                const startEl = document.getElementById(`btl-start-${storyId}`);
                const endEl = document.getElementById(`btl-end-${storyId}`);
                const bulletsEl = document.getElementById(`btl-bullets-${storyId}`);
                const dateAddedEl = document.getElementById(`btl-dateadded-${storyId}`);
                const descriptionEl = document.getElementById(`btl-description-${storyId}`);
                
                const story = {
                    title: titleEl ? titleEl.value || '' : '',
                };
                
                // Handle start/end dates
                const start = startEl ? startEl.value : '';
                const end = endEl ? endEl.value : '';
                
                // Determine if it's a month or date format
                if (start) {
                    if (start.includes('-') || start.match(/^\d{1,2}[\/\-]\d{1,2}([\/\-]\d{2,4})?$/)) {
                        story.startDate = start;
                    } else {
                        story.startMonth = start.toUpperCase();
                    }
                } else {
                    story.startMonth = 'JAN';
                }
                
                if (end) {
                    if (end.includes('-') || end.match(/^\d{1,2}[\/\-]\d{1,2}([\/\-]\d{2,4})?$/)) {
                        story.endDate = end;
                    } else {
                        story.endMonth = end.toUpperCase();
                    }
                } else {
                    story.endMonth = 'MAR';
                }
                
                // Handle bullets
                const bullets = bulletsEl ? bulletsEl.value : '';
                if (bullets) {
                    story.bullets = bullets.split('\n').filter(line => line.trim());
                }
                
                // Handle date added
                const dateAdded = dateAddedEl ? dateAddedEl.value : '';
                if (dateAdded) {
                    story.dateAdded = dateAdded;
                }
                
                // Handle description
                const description = descriptionEl ? descriptionEl.value : '';
                if (description) {
                    story.dateAddedDescription = description;
                }
                
                // Handle IMO
                const imoEl = document.getElementById(`btl-imo-${storyId}`);
                const imo = imoEl ? imoEl.value.trim() : '';
                if (imo) {
                    story.imo = imo;
                }
                
                if (story.title) { // Only add stories with titles
                    stories.push(story);
                }
            });
            
            return {
                stories: stories
            };
        }
        
        /**
         * Update the filename display
         */
        function updateFilenameDisplay(filename) {
            const displayDiv = document.getElementById('currentFilenameDisplay');
            const filenameInput = document.getElementById('currentFilename');
            
            if (filename) {
                filenameInput.value = filename;
                displayDiv.style.display = 'block';
            } else {
                filenameInput.value = '';
                displayDiv.style.display = 'none';
            }
        }
        
        function newRoadmap() {
            // Set the current roadmap year as default in the modal
            const currentYear = getCurrentRoadmapYear();
            document.getElementById('newRoadmapYear').value = currentYear;
            
            // Show the new roadmap modal
            document.getElementById('newRoadmapModal').style.display = 'flex';
            
            // Focus on the year input
            setTimeout(() => {
                document.getElementById('newRoadmapYear').focus();
                document.getElementById('newRoadmapYear').select();
            }, 100);
        }
        
        function closeNewRoadmapModal() {
            document.getElementById('newRoadmapModal').style.display = 'none';
        }
        
        function confirmNewRoadmap() {
            const selectedYear = parseInt(document.getElementById('newRoadmapYear').value);
            if (!selectedYear || selectedYear < 2020 || selectedYear > 2030) {
                alert('Please enter a valid year between 2020 and 2030.');
                return;
            }
            
            // Close the modal
            closeNewRoadmapModal();
            
            // Set flag to prevent KTLO data corruption during new roadmap creation
            window.isCreatingNewRoadmap = true;
            
            // Set the selected roadmap year
            document.getElementById('roadmapYear').value = selectedYear;
            
            // Clear team information
            document.getElementById('teamName').value = '';
            document.getElementById('directorVP').value = '';
            document.getElementById('em').value = '';
            document.getElementById('pm').value = '';
            document.getElementById('teamDescription').value = '';
            
            // Set default filename for new roadmap
            const defaultFilename = `MyTeam.Teya-Roadmap.${selectedYear}.json`;
            updateFilenameDisplay(defaultFilename);
            
            // Remove all epics
            const epics = document.querySelectorAll('.epic-section');
            epics.forEach(epic => epic.remove());
            epicCounter = 0;
            storyCounters = {};
            
            // Clear date picker initialization tracking to allow new date pickers
            initializedDatePickers.clear();
            
            // Clear date picker initialization flags from any remaining elements
            document.querySelectorAll('[data-date-picker-initialized="true"]').forEach(element => {
                element.removeAttribute('data-date-picker-initialized');
            });
            
            // Clear BTL stories
            const btlContainer = document.getElementById('btl-stories-container');
            if (btlContainer) {
                btlContainer.innerHTML = '';
            }
            btlStoryCounter = 0;
            updateBTLAddButton();
            
            // Reset KTLO to defaults but keep it
            document.getElementById('ktlo-title').value = 'Keep the lights on';
            document.getElementById('ktlo-bullets').value = '';
            document.getElementById('ktlo-position-toggle').checked = false; // Default to bottom
            
            // Set default KTLO monthly data (10 and 25 for each month)
            ktloMonthlyData = {
                jan: { number: '10', percentage: '25', description: '' },
                feb: { number: '10', percentage: '25', description: '' },
                mar: { number: '10', percentage: '25', description: '' },
                apr: { number: '10', percentage: '25', description: '' },
                may: { number: '10', percentage: '25', description: '' },
                jun: { number: '10', percentage: '25', description: '' },
                jul: { number: '10', percentage: '25', description: '' },
                aug: { number: '10', percentage: '25', description: '' },
                sep: { number: '10', percentage: '25', description: '' },
                oct: { number: '10', percentage: '25', description: '' },
                nov: { number: '10', percentage: '25', description: '' },
                dec: { number: '10', percentage: '25', description: '' }
            };
            
            // Ensure the month selector is set to January and reload with defaults
            const selector = document.getElementById('ktlo-month-selector');
            if (selector) {
                // DON'T save current data - that overwrites our new defaults!
                
                // Reset selector to January
                selector.value = 'jan';
                selector.setAttribute('data-previous-month', 'jan');
                
                // Load January with the new default data
                loadKTLOMonth('jan');
                
                // Ensure form inputs show the default values
                setTimeout(() => {
                    const numberInput = document.getElementById('ktlo-current-number');
                    const percentageInput = document.getElementById('ktlo-current-percentage');
                    const descriptionInput = document.getElementById('ktlo-current-description');
                    
                    if (numberInput) numberInput.value = '10';
                    if (percentageInput) percentageInput.value = '25';
                    if (descriptionInput) descriptionInput.value = '';
                }, 100);
            }
            
            // Reset change counter
            changeCounter = 0;
            
            // Clear any pending timeline changes
            if (window.pendingTimelineChangesByIds) {
                window.pendingTimelineChangesByIds = {};
            }
            if (window.pendingTimelineChangesByReference) {
                window.pendingTimelineChangesByReference = {};
            }
            
            // Update date picker ranges for the new year
            updateAllDatePickerRanges();
            
            // Generate clean preview
            generatePreview();
            
            // Clear the flag after preview generation is complete
            setTimeout(() => {
                window.isCreatingNewRoadmap = false;
            }, 500);
        }
        
        async function saveRoadmap() {
            // Ensure current KTLO data is saved before export
            saveCurrentKTLOData();
            
            const teamData = collectFormData();
            
            // Add metadata for better file organization
            const roadmapData = {
                version: "1.0",
                created: new Date().toISOString(),
                teamData: teamData
            };
            
            const json = JSON.stringify(roadmapData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            
            // Use current filename if available, otherwise generate from team name and year
            const currentFilename = document.getElementById('currentFilename').value.trim();
            let defaultFileName;
            if (currentFilename) {
                // Use existing filename, ensure it has .json extension
                defaultFileName = currentFilename.endsWith('.json') ? currentFilename : `${currentFilename}.json`;
            } else {
                // Generate default filename based on team name and year
                defaultFileName = `${teamData.teamName || 'MyTeam'}.Teya-Roadmap.${teamData.roadmapYear || 2025}.json`;
            }
            
            // Try to use the File System Access API for native save dialog
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: defaultFileName,
                        types: [{
                            description: 'Teya Roadmap files',
                            accept: {
                                'application/json': ['.json']
                            }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    
                    return;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        // User cancelled the save dialog
                        return;
                    }
                    // File System Access API failed, fall back to download
                }
            }
            
            // Fallback to download method for browsers that don't support File System Access API
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = defaultFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Load roadmap function - JSON only
        function loadRoadmap() {
            document.getElementById('roadmapLoadInput').click();
        }
        
        // Handle roadmap file load (JSON only)
        function handleRoadmapLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const fileName = file.name.toLowerCase();
            
            if (fileName.endsWith('.json')) {
                // Handle as JSON roadmap file
                handleFileLoad(event);
            } else {
                alert('Unsupported file format. Please select a JSON (.json) file.');
            }
            
            // Reset the input value so the same file can be loaded again
            event.target.value = '';
        }
        
        /**
         * Fix dates without years when loading roadmap
         */
        function fixDatesOnLoad(teamData) {
            const roadmapYear = teamData.roadmapYear || new Date().getFullYear();
            
            // Helper function to fix a date string and normalize separator
            const fixDate = (dateStr) => {
                if (!dateStr || typeof dateStr !== 'string') return dateStr;
                // Match dd/mm or dd-mm format (without year)
                if (/^\d{1,2}[\/\-]\d{1,2}$/.test(dateStr)) {
                    // Replace all "-" with "/" for consistency, then add year
                    const normalizedDate = dateStr.replace(/-/g, '/');
                    return normalizedDate + '/' + roadmapYear;
                }
                return dateStr;
            };
            
            // Fix dates in all epics and stories
            if (teamData.epics) {
                teamData.epics.forEach(epic => {
                    if (epic.stories) {
                        epic.stories.forEach(story => {
                            // Fix story start/end dates
                            if (story.startDate) story.startDate = fixDate(story.startDate);
                            if (story.endDate) story.endDate = fixDate(story.endDate);
                            
                            // Fix timeline change dates
                            if (story.roadmapChanges && story.roadmapChanges.changes) {
                                story.roadmapChanges.changes.forEach(change => {
                                    if (change.date) change.date = fixDate(change.date);
                                    if (change.prevEndDate) change.prevEndDate = fixDate(change.prevEndDate);
                                    if (change.newEndDate) change.newEndDate = fixDate(change.newEndDate);
                                });
                            }
                            
                            // Fix status info dates
                            if (story.roadmapChanges) {
                                if (story.roadmapChanges.doneInfo && story.roadmapChanges.doneInfo.date) {
                                    story.roadmapChanges.doneInfo.date = fixDate(story.roadmapChanges.doneInfo.date);
                                }
                                if (story.roadmapChanges.cancelInfo && story.roadmapChanges.cancelInfo.date) {
                                    story.roadmapChanges.cancelInfo.date = fixDate(story.roadmapChanges.cancelInfo.date);
                                }
                                if (story.roadmapChanges.atRiskInfo && story.roadmapChanges.atRiskInfo.date) {
                                    story.roadmapChanges.atRiskInfo.date = fixDate(story.roadmapChanges.atRiskInfo.date);
                                }
                                if (story.roadmapChanges.newStoryInfo && story.roadmapChanges.newStoryInfo.date) {
                                    story.roadmapChanges.newStoryInfo.date = fixDate(story.roadmapChanges.newStoryInfo.date);
                                }
                                if (story.roadmapChanges.infoInfo) {
                                    if (Array.isArray(story.roadmapChanges.infoInfo)) {
                                        // Multiple info entries
                                        story.roadmapChanges.infoInfo.forEach(entry => {
                                            if (entry && entry.date) {
                                                entry.date = fixDate(entry.date);
                                            }
                                        });
                                    } else if (story.roadmapChanges.infoInfo.date) {
                                        // Single info entry (backward compatibility)
                                    story.roadmapChanges.infoInfo.date = fixDate(story.roadmapChanges.infoInfo.date);
                                    }
                                }
                                if (story.roadmapChanges.transferredOutInfo && story.roadmapChanges.transferredOutInfo.date) {
                                    story.roadmapChanges.transferredOutInfo.date = fixDate(story.roadmapChanges.transferredOutInfo.date);
                                }
                                if (story.roadmapChanges.transferredInInfo && story.roadmapChanges.transferredInInfo.date) {
                                    story.roadmapChanges.transferredInInfo.date = fixDate(story.roadmapChanges.transferredInInfo.date);
                                }
                                if (story.roadmapChanges.proposedInfo && story.roadmapChanges.proposedInfo.date) {
                                    story.roadmapChanges.proposedInfo.date = fixDate(story.roadmapChanges.proposedInfo.date);
                                }
                            }
                        });
                    }
                });
            }
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Handle both new format (with metadata) and legacy format (direct teamData)
                    const teamData = data.teamData || data;
                    
                    // Validate basic structure
                    if (!teamData || typeof teamData !== 'object') {
                        throw new Error('Invalid roadmap data structure');
                    }
                    
                    // Fix dates without years by adding current roadmap year
                    fixDatesOnLoad(teamData);
                    
                    loadTeamData(teamData);
                    
                    // Update filename display
                    updateFilenameDisplay(file.name);
                    
                    // Add a longer delay to ensure all DOM elements are ready and stories are loaded, then auto-generate preview
                    setTimeout(() => {
                        // Refresh date pickers to sync with loaded data
                        refreshAllDatePickers();
                        generatePreview();
                    }, 500);
                    

                } catch (error) {
                    console.error('Error loading roadmap:', error);
                    let errorMessage = 'Error loading roadmap file.';
                    
                    if (error.name === 'SyntaxError') {
                        errorMessage += ' The file is not valid JSON format.';
                    } else if (error.message.includes('Invalid roadmap data')) {
                        errorMessage += ' The file does not contain valid roadmap data.';
                    } else {
                        errorMessage += ' Please check the file format and try again.';
                    }
                    
                    alert(errorMessage + '\n\nError details: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Reset the file input so the same file can be loaded again
            event.target.value = '';
        }
        
        // Stats modal controls
        function openStatsModal() {
            try {
            const teamData = collectFormData();
                const stats = computeRoadmapStats(teamData);
                const body = document.getElementById('statsModalBody');
                body.innerHTML = renderStatsHtml(stats);
                const modal = document.getElementById('statsModal');
                modal.style.display = 'flex';
                // Make stats available for interactive breakdown
                window.__roadmapStats = stats;
                
                // Add tooltip functionality after DOM is updated
                setTimeout(setupTooltips, 100);
            } catch (e) {
                
            }
        }
        
        function setupTooltips() {
            const tooltipElements = document.querySelectorAll('[data-tooltip]');
            tooltipElements.forEach(element => {
                // Remove old listener if it exists to prevent duplicates
                element.removeEventListener('click', toggleDelayBreakdown);
                element.addEventListener('click', toggleDelayBreakdown);
            });
        }
        
        function toggleDelayBreakdown(e) {
            e.preventDefault();
            e.stopPropagation();

            const container = e.currentTarget || e.target.closest('[data-tooltip]');
            if (!container) return;

            const breakdownType = container.getAttribute('data-breakdown-type');
            if (!breakdownType) return;
            
            const breakdownId = `${breakdownType}-breakdown`;

            // Toggle only this specific breakdown
            const existing = document.getElementById(breakdownId);
            
            // Find the chevron icon - the container itself should be the bar-chart-container
            const barChartContainer = container.classList.contains('bar-chart-container') ? container : container.closest('.bar-chart-container');
            const chevron = barChartContainer ? barChartContainer.querySelector('.expand-chevron') : null;
            
            if (existing) {
                existing.remove();
                // Rotate chevron back to collapsed state (pointing right)
                if (chevron) {
                    chevron.style.transform = 'rotate(0deg)';
                }
                return; // Just close it, don't reopen
            }

            // Rotate chevron to expanded state (pointing down)
            if (chevron) {
                chevron.style.transform = 'rotate(90deg)';
            }

            const stats = window.__roadmapStats || { delayBreakdown: {}, delayStories: {}, totalStories: 0, cancelled: 0 };
            const activeStories = (stats.totalStories || 0) - (stats.cancelled || 0);

            // Create breakdown container
            const breakdown = document.createElement('div');
            breakdown.id = breakdownId;
            breakdown.__for = container;
            breakdown.style.cssText = `
                margin-top: 10px;
                padding: 12px;
                background: #f8f9fa;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                font-size: 12px;
                color: #374151;
            `;
            
            if (breakdownType === 'delayed') {
                breakdown.innerHTML = renderDelayBreakdown(stats, stats.totalStories);
            } else if (breakdownType === 'ontime') {
                breakdown.innerHTML = renderOntimeBreakdown(stats, stats.totalStories);
            } else if (breakdownType === 'accelerated') {
                breakdown.innerHTML = renderAcceleratedBreakdown(stats, stats.totalStories);
            } else if (breakdownType === 'cancelled') {
                breakdown.innerHTML = renderCancelledBreakdown(stats);
            }

            // Insert directly after the clicked container
            container.parentNode.insertBefore(breakdown, container.nextSibling);

            // Enable expand/collapse on rows
            setupDelayBreakdownInteractions();
        }

        function renderOntimeBreakdown(stats, totalStories) {
            const done = stats.onTimeDone || 0;
            const notDone = stats.onTimeNotDone || 0;
            const doneStories = (stats.onTimeStories && stats.onTimeStories.done) || [];
            const notDoneStories = (stats.onTimeStories && stats.onTimeStories.notDone) || [];
            
            if (done === 0 && notDone === 0) {
                return '<div style="color:#6b7280;">No on-time projects</div>';
            }
            
            const donePct = totalStories ? ((done / totalStories) * 100).toFixed(1) : 0;
            const notDonePct = totalStories ? ((notDone / totalStories) * 100).toFixed(1) : 0;
            
            return (
                '<div class="delay-row" id="ontime-done-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Done (' + done + ' / ' + donePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="ontime-done-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #28a745;">' +
                        renderDelayDetails(doneStories) +
                    '</div>' +
                '</div>' +
                '<div class="delay-row" id="ontime-notdone-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Not Done (' + notDone + ' / ' + notDonePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="ontime-notdone-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #ffc107;">' +
                        renderDelayDetails(notDoneStories) +
                    '</div>' +
                '</div>'
            );
        }
        
        function renderAcceleratedBreakdown(stats, totalStories) {
            const acceleratedStories = stats.acceleratedStories || { done: [], notDone: [] };
            
            // Handle backward compatibility: if acceleratedStories is an array (old format), convert it
            if (Array.isArray(acceleratedStories)) {
                const doneStories = acceleratedStories.filter(s => s.isDone);
                const notDoneStories = acceleratedStories.filter(s => !s.isDone);
                acceleratedStories = { done: doneStories, notDone: notDoneStories };
            }
            
            const done = acceleratedStories.done ? acceleratedStories.done.length : 0;
            const notDone = acceleratedStories.notDone ? acceleratedStories.notDone.length : 0;
            const doneStories = acceleratedStories.done || [];
            const notDoneStories = acceleratedStories.notDone || [];
            
            if (done === 0 && notDone === 0) {
                return '<div style="color:#6b7280;">No accelerated projects</div>';
            }
            
            const donePct = totalStories ? ((done / totalStories) * 100).toFixed(1) : 0;
            const notDonePct = totalStories ? ((notDone / totalStories) * 100).toFixed(1) : 0;
            
            return (
                '<div class="delay-row" id="accelerated-done-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Done (' + done + ' / ' + donePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="accelerated-done-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #28a745;">' +
                        renderDelayDetails(doneStories) +
                    '</div>' +
                '</div>' +
                '<div class="delay-row" id="accelerated-notdone-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Not Done (' + notDone + ' / ' + notDonePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="accelerated-notdone-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #ffc107;">' +
                        renderDelayDetails(notDoneStories) +
                    '</div>' +
                '</div>'
            );
        }

        function renderCancelledBreakdown(stats) {
            const cancelled = Array.isArray(stats.cancelledStories) ? stats.cancelledStories : [];
            if (cancelled.length === 0) {
                return '<div style="color:#6b7280;">No cancelled projects</div>';
            }
            const items = cancelled.map(s => {
                const title = (s.title || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const epic = (s.epicName || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const team = (s.teamName || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                return '<div style="font-size:12px; color:#374151; padding:2px 0;">' +
                    (team ? '<span style="color:#6b7280;">[' + team + ']</span> ' : '') +
                    (epic ? '<span style="color:#6b7280;">[' + epic + ']</span> ' : '') +
                    title +
                '</div>';
            }).join('');
            return '<div style="display:block; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #dc3545;">' + items + '</div>';
        }
        
        function renderDelayBreakdown(stats, totalStories) {
            const counts = stats.delayBreakdown || {};
            const sorted = Object.keys(counts).map(n => parseInt(n, 10)).sort((a, b) => a - b);
            if (sorted.length === 0) {
                return '<div style="color:#6b7280;">No delays recorded</div>';
            }
            
            const rows = sorted.map(delayCount => {
                const value = counts[delayCount] || 0;
                const pct = totalStories ? ((value / totalStories) * 100).toFixed(1) : 0;
                const delayGroup = (stats.delayStories && stats.delayStories[delayCount]) || { done: [], notDone: [] };
                const doneCount = delayGroup.done ? delayGroup.done.length : 0;
                const notDoneCount = delayGroup.notDone ? delayGroup.notDone.length : 0;
                const rowId = `delay-row-${delayCount}`;
                const detailsId = `delay-details-${delayCount}`;
                
                return (
                    '<div class="delay-row" id="' + rowId + '" style="margin-bottom: 8px; margin-left: 10px;">' +
                        '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                            '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                            '<span style="font-size:13px; color:#374151;">' + delayCount + ' delay' + (delayCount > 1 ? 's' : '') + ' (' + value + ' / ' + pct + '%)</span>' +
                        '</div>' +
                        '<div class="delay-row-details" id="' + detailsId + '" style="display:none; margin-left: 20px;">' +
                            renderDelaySubBreakdown(delayGroup, delayCount, value) +
                        '</div>' +
                    '</div>'
                );
            }).join('');
            return rows;
        }
        
        function renderDelaySubBreakdown(delayGroup, delayCount, totalCount) {
            // Handle backward compatibility: if delayGroup is an array (old format), convert it
            if (Array.isArray(delayGroup)) {
                const doneStories = delayGroup.filter(s => s.isDone);
                const notDoneStories = delayGroup.filter(s => !s.isDone);
                delayGroup = { done: doneStories, notDone: notDoneStories };
            }
            
            const doneStories = delayGroup.done || [];
            const notDoneStories = delayGroup.notDone || [];
            const doneCount = doneStories.length;
            const notDoneCount = notDoneStories.length;
            
            const donePct = totalCount ? ((doneCount / totalCount) * 100).toFixed(1) : 0;
            const notDonePct = totalCount ? ((notDoneCount / totalCount) * 100).toFixed(1) : 0;
            
            return (
                '<div class="delay-row" id="delay-' + delayCount + '-done-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Done (' + doneCount + ' / ' + donePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="delay-' + delayCount + '-done-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #28a745;">' +
                        renderDelayDetails(doneStories) +
                    '</div>' +
                '</div>' +
                '<div class="delay-row" id="delay-' + delayCount + '-notdone-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Not Done (' + notDoneCount + ' / ' + notDonePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="delay-' + delayCount + '-notdone-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #ffc107;">' +
                        renderDelayDetails(notDoneStories) +
                    '</div>' +
                '</div>'
            );
        }

        function compareByTeamEpicTitle(a, b) {
            const ta = (a.teamName || '').toLowerCase();
            const tb = (b.teamName || '').toLowerCase();
            if (ta !== tb) return ta < tb ? -1 : 1;
            const ea = (a.epicName || '').toLowerCase();
            const eb = (b.epicName || '').toLowerCase();
            if (ea !== eb) return ea < eb ? -1 : 1;
            const sa = (a.title || '').toLowerCase();
            const sb = (b.title || '').toLowerCase();
            if (sa !== sb) return sa < sb ? -1 : 1;
            return 0;
        }

        function renderDelayDetails(stories) {
            if (!stories || !stories.length) return '<div style="color:#6b7280;">No items</div>';
            const sorted = [...stories].sort(compareByTeamEpicTitle);
            return sorted.map(s => {
                const title = (s.title || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const epic = (s.epicName || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const team = (s.teamName || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                return '<div style="font-size:12px; color:#374151; padding:2px 0;">' +
                    (team ? '<span style="color:#6b7280;">[' + team + ']</span> ' : '') +
                    (epic ? '<span style="color:#6b7280;">[' + epic + ']</span> ' : '') +
                    title +
                '</div>';
            }).join('');
        }

        function setupDelayBreakdownInteractions() {
            const rows = document.querySelectorAll('[id$="-breakdown"] .delay-row');
            rows.forEach(row => {
                const details = row.querySelector('.delay-row-details');
                const header = row.querySelector('.delay-row-header');
                const arrow = header ? header.querySelector('span:first-child') : null;
                
                // Remove any existing click handler to prevent duplicates
                if (header && header._toggleHandler) {
                    header.removeEventListener('click', header._toggleHandler);
                }
                
                const toggle = () => {
                    if (!details) return;
                    const isOpen = details.style.display !== 'none';
                    details.style.display = isOpen ? 'none' : 'block';
                    if (arrow) {
                        arrow.textContent = isOpen ? '‚ñ∂' : '‚ñº';
                    }
                };
                
                // Store the handler reference for later removal
                if (header) {
                    header._toggleHandler = toggle;
                    header.addEventListener('click', toggle);
                }
            });
        }
        function closeStatsModal() {
            const modal = document.getElementById('statsModal');
            if (modal) modal.style.display = 'none';
        }

        // Compute roadmap stats
        function computeRoadmapStats(teamData) {
            const result = {
                totalEpics: 0,
                totalStories: 0,
                onTime: 0,
                onTimeDone: 0,
                onTimeNotDone: 0,
                delayedOnce: 0,
                delayedTwiceOrMore: 0,
                accelerated: 0,
                cancelled: 0,
                totalDelayed: 0,
                delayBreakdown: {}, // Track exact delay counts
                delayStories: {},
                acceleratedStories: { done: [], notDone: [] },
                onTimeStories: { done: [], notDone: [] },
                cancelledStories: []
            };
            if (!teamData || !Array.isArray(teamData.epics)) return result;
            result.totalEpics = teamData.epics.length;
            for (const epic of teamData.epics) {
                if (!Array.isArray(epic.stories)) continue;
                for (const story of epic.stories) {
                    result.totalStories++;
                    if (story.isCancelled) {
                        result.cancelled++;
                        const teamName = (teamData && teamData.teamName) ? teamData.teamName : '';
                        result.cancelledStories.push({ title: story.title, epicName: epic.name, teamName });
                        continue;
                    }
                    const changes = story.roadmapChanges?.changes || [];
                    
                    // Count only ACTUAL delays (new date > prev date)
                    let actualDelayCount = 0;
                    let hasAcceleration = false;
                    
                    if (Array.isArray(changes) && changes.length > 0) {
                        for (const change of changes) {
                            if (change.prevEndDate && change.newEndDate) {
                                // Parse dates properly - they might be in DD/MM/YY or ISO format
                                const roadmapYear = teamData.roadmapYear || new Date().getFullYear();
                                const prevISO = DateUtility.parseTextValue(change.prevEndDate, true, roadmapYear);
                                const newISO = DateUtility.parseTextValue(change.newEndDate, true, roadmapYear);
                                
                                if (prevISO && newISO) {
                                    if (newISO > prevISO) {
                                        actualDelayCount++; // Actual delay
                                    } else if (newISO < prevISO) {
                                        hasAcceleration = true; // Pulled forward
                                    }
                                }
                            }
                        }
                    }
                    
                    if (actualDelayCount === 0 && !hasAcceleration) {
                        // No timeline changes at all
                        result.onTime++;
                        const isDone = story.isDone || false;
                        if (isDone) {
                            result.onTimeDone++;
                            result.onTimeStories.done.push({ title: story.title, epicName: epic.name });
                        } else {
                            result.onTimeNotDone++;
                            result.onTimeStories.notDone.push({ title: story.title, epicName: epic.name });
                        }
                    } else if (hasAcceleration && actualDelayCount === 0) {
                        // Only accelerations, no delays
                        result.accelerated++;
                        const acceleratedStory = { title: story.title, epicName: epic.name };
                        if (story.isDone) {
                            result.acceleratedStories.done.push(acceleratedStory);
                        } else {
                            result.acceleratedStories.notDone.push(acceleratedStory);
                        }
                    } else if (actualDelayCount > 0) {
                        // Has at least one actual delay
                        result.totalDelayed++;
                        if (actualDelayCount === 1) {
                            result.delayedOnce++;
                        } else {
                            result.delayedTwiceOrMore++;
                        }
                        
                    // Track exact delay count for breakdown
                    result.delayBreakdown[actualDelayCount] = (result.delayBreakdown[actualDelayCount] || 0) + 1;
                    if (!result.delayStories[actualDelayCount]) {
                        result.delayStories[actualDelayCount] = { done: [], notDone: [] };
                    }
                    const delayedStory = { title: story.title, epicName: epic.name };
                    if (story.isDone) {
                        result.delayStories[actualDelayCount].done.push(delayedStory);
                    } else {
                        result.delayStories[actualDelayCount].notDone.push(delayedStory);
                    }
                    }
                }
            }
            return result;
        }

        function isDelayChange(change) {
            // Consider a delay if newEndDate > prevEndDate or explicit type/description suggests delay
            try {
                if (!change) return false;
                if (change.type && /delay|slip/i.test(change.type)) return true;
                if (change.description && /delay|slip|pushed/i.test(change.description)) return true;
                if (change.newEndDate && change.prevEndDate) {
                    const n = Date.parse(change.newEndDate);
                    const p = Date.parse(change.prevEndDate);
                    if (!isNaN(n) && !isNaN(p) && n > p) return true;
                }
            } catch (_) {}
            return false;
        }

        function renderStatsHtml(s) {
            const pct = (num, den) => (den ? ((num / den) * 100).toFixed(1) : 0);
            const activeStories = s.totalStories - s.cancelled;
            
            return (
                '<div style="padding: 20px;">' +
                    '<h3 style="margin: 0 0 20px 0; color: #333; text-align: center;">üìä Project Status Overview</h3>' +
                    '<div style="margin-bottom: 20px; text-align: center; font-size: 14px; color: #666;">' +
                        `${s.totalStories} Total Stories across ${s.totalEpics} EPICs` +
                    '</div>' +
                    '<div style="max-width: 600px; margin: 0 auto;">' +
                        barChart('On-time Projects', s.onTime, s.totalStories, '#28a745', s, 'ontime') +
                        barChart('Delayed Projects', s.totalDelayed, s.totalStories, '#dc3545', s, 'delayed') +
                        barChart('Accelerated Projects', s.accelerated, s.totalStories, '#17a2b8', s, 'accelerated') +
                        barChart('Cancelled', s.cancelled, s.totalStories, '#6c757d', s, 'cancelled') +
                    '</div>' +
                '</div>'
            );
        }
        
        function barChart(label, value, total, color, stats, breakdownType) {
            const percentage = total ? ((value / total) * 100).toFixed(1) : 0;
            
            let tooltipContent = '';
            let expandIcon = '';
            let cursorStyle = 'default';
            if (stats && breakdownType) {
                tooltipContent = `data-tooltip="breakdown" data-breakdown-type="${breakdownType}"`;
                cursorStyle = 'pointer';
                // Add expand/collapse chevron icon on the LEFT
                expandIcon = `<span class="expand-chevron" style="margin-right: 8px; font-size: 12px; color: #6b7280; transition: transform 0.2s ease; pointer-events: none;">‚ñ∂</span>`;
            }
            
            return (
                '<div style="margin-bottom: 12px; padding: 8px 12px; border-radius: 6px; background: #f9fafb; cursor: ' + cursorStyle + '; transition: all 0.2s ease;" class="bar-chart-container" ' + tooltipContent + '>' +
                    '<div style="display: flex; justify-content: space-between; align-items: center; pointer-events: none;">' +
                        `<span style="font-size: 14px; font-weight: 500; color: #374151; display: flex; align-items: center;">${expandIcon}${label}</span>` +
                        `<span style="font-size: 14px; font-weight: 600; color: ${color};">${value} (${percentage}%)</span>` +
                    '</div>' +
                '</div>'
            );
        }
        
        function getDelayBreakdown(stats) {
            let result = 'Delay Breakdown:\\n';
            
            // Sort delay counts for better display
            const sortedDelays = Object.keys(stats.delayBreakdown || {})
                .map(Number)
                .sort((a, b) => a - b);
            
            if (sortedDelays.length === 0) {
                result += 'No delays recorded';
            } else {
                sortedDelays.forEach(delayCount => {
                    const count = stats.delayBreakdown[delayCount];
                    result += `${delayCount} delay${delayCount > 1 ? 's' : ''}: ${count}\\n`;
                });
            }
            
            return result;
        }

        function card(label, value) {
            return (
                '<div style="border:1px solid #e5e7eb; border-radius:8px; padding:12px; background:#fafafa;">' +
                    `<div style="font-size:12px; color:#6b7280; margin-bottom:6px;">${label}</div>` +
                    `<div style="font-size:20px; font-weight:600; color:#111827;">${value}</div>` +
                '</div>'
            );
        }


        
        
        
        function updateIdCountersAfterImport() {
            // Update ID counters to avoid conflicts with imported IDs
            let maxEpicIdNumber = 0;
            let maxStoryIdNumber = 0;
            
            // Scan all EPIC IDs to find the highest number
            const epicElements = document.querySelectorAll('.epic-section');
            epicElements.forEach(epicEl => {
                const epicIdEl = epicEl.querySelector('input[id^="epic-id-"]');
                if (epicIdEl && epicIdEl.value) {
                    const epicId = epicIdEl.value;
                    // Extract number from format like "0xE0000001"
                    if (epicId.startsWith('0xE')) {
                        const idNumber = parseInt(epicId.substring(3), 16);
                        if (!isNaN(idNumber) && idNumber > maxEpicIdNumber) {
                            maxEpicIdNumber = idNumber;
                        }
                    }
                }
            });
            
            // Scan all Story IDs to find the highest number
            const storyElements = document.querySelectorAll('.story-section');
            storyElements.forEach(storyEl => {
                const storyIdEl = storyEl.querySelector('input[id^="story-id-"]');
                if (storyIdEl && storyIdEl.value) {
                    const storyId = storyIdEl.value;
                    // Extract number from format like "0x50000001"
                    if (storyId.startsWith('0x5')) {
                        const idNumber = parseInt(storyId.substring(3), 16);
                        if (!isNaN(idNumber) && idNumber > maxStoryIdNumber) {
                            maxStoryIdNumber = idNumber;
                        }
                    }
                }
            });
            
            // Update counters to match the maximum found (since we increment before use)
            epicIdCounter = maxEpicIdNumber;
            storyIdCounter = maxStoryIdNumber;
            

        }
        
        
        
        function applyPendingTimelineChanges(callback) {
            const hasIdBasedChanges = window.pendingTimelineChangesByIds && Object.keys(window.pendingTimelineChangesByIds).length > 0;
            const hasStringBasedChanges = window.pendingTimelineChanges && Object.keys(window.pendingTimelineChanges).length > 0;
            
            if (!hasIdBasedChanges && !hasStringBasedChanges) {
                if (callback) callback();
                return;
            }
            
            try {
                // Find all stories and match them with timeline changes
                const storyElements = document.querySelectorAll('.story-section');
                
                let matchCount = 0;
                let pendingOperations = 0;
                
                storyElements.forEach((storyEl, index) => {
                    const storyId = storyEl.id.replace('story-', '');
                    const titleEl = document.getElementById(`story-title-${storyId}`);
                    
                    if (!titleEl) {
                        return;
                    }
                    
                    // Get story and epic IDs for ID-based matching
                    const storyIdEl = document.getElementById(`story-id-${storyId}`);
                    const actualStoryId = storyIdEl ? storyIdEl.value : '';
                    
                    const epicEl = storyEl.closest('.epic-section');
                    const epicIdEl = epicEl ? epicEl.querySelector('input[id^="epic-id-"]') : null;
                    const actualEpicId = epicIdEl ? epicIdEl.value : '';
                    
                    // Get story title and epic name for string-based matching (fallback)
                    const storyTitle = titleEl.value;
                    const epicTitleEl = epicEl ? epicEl.querySelector('input[id^="epic-name-"]') : null;
                    const epicName = epicTitleEl ? epicTitleEl.value : '';
                    const storyReference = `${epicName} - ${storyTitle}`;
                    
                    let changes = null;
                    let matchType = '';
                    
                    // Try ID-based matching first (preferred)
                    if (hasIdBasedChanges && actualEpicId && actualStoryId) {
                        const idKey = `${actualEpicId}:${actualStoryId}`;
                        if (window.pendingTimelineChangesByIds[idKey]) {
                            changes = window.pendingTimelineChangesByIds[idKey];
                            matchType = 'ID-based';
                        }
                    }
                    
                    // Fall back to string-based matching if no ID match found
                    if (!changes && hasStringBasedChanges && window.pendingTimelineChanges[storyReference]) {
                        changes = window.pendingTimelineChanges[storyReference];
                        matchType = 'string-based';
                    }
                    
                    // Apply timeline changes if found
                    if (changes) {
                        matchCount++;
                        pendingOperations++;
                        
                        // Enable timeline changes checkbox
                        const changesCheckbox = document.getElementById(`story-changes-${storyId}`);
                        if (changesCheckbox) {
                            changesCheckbox.checked = true;
                            toggleChanges(storyId); // Show the changes section
                            
                            // Clear any existing timeline changes before importing new ones
                            const container = document.getElementById(`changes-container-${storyId}`);
                            if (container) {
                                container.innerHTML = '';
                            }
                            
                            // Wait for DOM elements to be created, then add the changes
                            setTimeout(() => {
                                changes.forEach((change, changeIndex) => {
                                    addChange(storyId);
                                    
                                    // Find the most recently added change element
                                    const changeContainers = document.querySelectorAll(`#changes-container-${storyId} > div[id^="change-${storyId}-change-"]`);
                                    const latestContainer = changeContainers[changeContainers.length - 1];
                                    
                                    if (latestContainer) {
                                        const fullChangeId = latestContainer.id.replace('change-', '');
                                        
                                        const dateEl = document.getElementById(`change-date-${fullChangeId}`);
                                        const prevEl = document.getElementById(`change-prev-${fullChangeId}`);
                                        const newEl = document.getElementById(`change-new-${fullChangeId}`);
                                        const descEl = document.getElementById(`change-desc-${fullChangeId}`);
                                        
                                        if (dateEl) {
                                            dateEl.value = change.date;
                                        }
                                        if (prevEl) {
                                            prevEl.value = change.prevEndDate;
                                        }
                                        if (newEl) {
                                            newEl.value = change.newEndDate;
                                        }
                                        if (descEl) {
                                            descEl.value = change.description;
                                        }
                                    }
                                });
                                
                                // Update button state after loading all changes
                                updateChangeButton(storyId);
                                
                                // Mark this operation as complete
                                pendingOperations--;
                                if (pendingOperations === 0) {
                                    // All timeline changes have been applied, call the callback
                                    
                                    // Clean up
                                    delete window.pendingTimelineChanges;
                                    delete window.pendingTimelineChangesByIds;
                                    delete window.loadedEpicIds;
                                    delete window.loadedStoryIds;
                                    
                                    if (callback) callback();
                                }
                            }, 100);
                        } else {
                            pendingOperations--;
                            if (pendingOperations === 0 && callback) callback();
                        }
                    }
                });
                
                // If no pending operations, call callback immediately
                if (pendingOperations === 0) {
                    // Clean up
                    delete window.pendingTimelineChanges;
                    delete window.pendingTimelineChangesByIds;
                    delete window.loadedEpicIds;
                    delete window.loadedStoryIds;
                    
                    if (callback) callback();
                }
                
            } catch (error) {
                if (callback) callback(); // Call callback even on error to prevent hanging
            }
        }
        
                function loadTeamData(teamData) {
            // Clear existing EPICs first
            document.getElementById('epics-container').innerHTML = '';
            epicCounter = 0;
            storyCounters = {};
            
            // Always clear BTL stories during JSON import
            document.getElementById('btl-stories-container').innerHTML = '';
            btlStoryCounter = 0;
            
            // Reset sorting preferences and UI toggles on load
            try {
                const startToggle = document.getElementById('story-sorting-toggle');
                const endToggle = document.getElementById('story-sorting-end-toggle');
                const textBelowToggle = document.getElementById('force-text-below-toggle');
                if (startToggle) startToggle.checked = false;
                if (endToggle) endToggle.checked = false;
                if (textBelowToggle) textBelowToggle.checked = false;
                // Reset temporary force text below variable
                tempForceTextBelow = false;
                // Persist cleared state
                getConfigUtility().setSortStories(false);
                getConfigUtility().setSortByStart(false);
                getConfigUtility().setSortByEnd(false);
                getConfigUtility().setForceTextBelow(false);
            } catch (_) {}
            
            // Load roadmap year
            document.getElementById('roadmapYear').value = teamData.roadmapYear || 2025;
            
            // Load team information
            document.getElementById('teamName').value = teamData.teamName || 'My Team';
            document.getElementById('directorVP').value = teamData.directorVP || '';
            document.getElementById('em').value = teamData.em || 'Engineering Manager';
            document.getElementById('pm').value = teamData.pm || 'Product Manager';
            

            
            // Load description - handle both old array format and new string format for backward compatibility
            let descriptionValue = '';
            if (teamData.description) {
                if (Array.isArray(teamData.description)) {
                    // Old format: convert array to multi-line string
                    descriptionValue = teamData.description.filter(line => line && line.trim()).join('\n');
                } else if (typeof teamData.description === 'string') {
                    // New format: use string directly
                    descriptionValue = teamData.description;
                }
            }
            document.getElementById('teamDescription').value = descriptionValue;
            
            // Load EPICs and stories
            let totalStoryLoadOperations = 0;
            let completedStoryLoadOperations = 0;
            
            if (teamData.epics && Array.isArray(teamData.epics)) {
                // Count total operations first
                teamData.epics.forEach(epic => {
                    if (epic.stories && Array.isArray(epic.stories)) {
                        totalStoryLoadOperations += epic.stories.length;
                    }
                });
                
                                teamData.epics.forEach((epic, epicIndex) => {
                    addEpic();
                    const currentEpicId = epicCounter;
                    
                    // Set EPIC name
                    document.getElementById(`epic-name-${currentEpicId}`).value = epic.name || `EPIC ${currentEpicId}`;
                    
                    // Remove the default story that gets added
                    const defaultStoryId = `${currentEpicId}-1`;
                    const defaultStoryElement = document.getElementById(`story-${defaultStoryId}`);
                    if (defaultStoryElement) {
                        defaultStoryElement.remove();
                        storyCounters[currentEpicId] = 0;
                    }
                    
                    // Load stories for this EPIC
                    if (epic.stories && Array.isArray(epic.stories)) {
                        epic.stories.forEach((story, storyIndex) => {
                            addStory(currentEpicId);
                            const currentStoryId = `${currentEpicId}-${storyCounters[currentEpicId]}`;
                            
                            // Add a small delay to ensure DOM elements are fully created before populating
                            setTimeout(() => {
                                loadStoryData(currentStoryId, story);
                                
                                // Track completion
                                completedStoryLoadOperations++;
                                
                                // If all stories are loaded, generate preview
                                if (completedStoryLoadOperations === totalStoryLoadOperations) {
                                    setTimeout(() => {
                                        // Store the loaded order as the "original" order for this session
                                        const epicElements = document.querySelectorAll('.epic-section');
                                        epicElements.forEach(epicEl => {
                                            const epicId = epicEl.id.split('-')[1];
                                            storeOriginalStoryOrder(epicId);
                                        });
                                        
                                        collapseAllSections();
                                        // Refresh date pickers to sync with loaded data
                                        refreshAllDatePickers();
                                        generatePreview();
                                        // Update document title with loaded team name
                                        updateDocumentTitle();
                                    }, 100);
                                }
                            }, 10 + (storyIndex * 5)); // Stagger each story by 5ms
                        });
                    }
                });
            }
            
            // Ensure KTLO forms are initialized before loading data
            initializeKTLOMonths();
            
            // Load KTLO data if it exists, otherwise set default position
            if (teamData.ktloSwimlane) {
                loadKTLOData(teamData.ktloSwimlane);
            } else {
                // Set default KTLO position to 'bottom' when no KTLO data exists
                const positionToggle = document.getElementById('ktlo-position-toggle');
                if (positionToggle) {
                    positionToggle.checked = false;
                    // Reposition the KTLO section to default position
                    setTimeout(repositionKTLOSection, 50);
                }
            }
            
            // Load BTL data if it exists
            if (teamData.btlSwimlane) {
                loadBTLData(teamData.btlSwimlane);
            }
            
            // Handle case where there are no stories to load
            if (totalStoryLoadOperations === 0) {
                setTimeout(() => {
                    collapseAllSections();
                    // Refresh date pickers to sync with loaded data
                    refreshAllDatePickers();
                    generatePreview();
                    // Update document title with loaded team name
                    updateDocumentTitle();
                }, 100);
            }
        }
        
        // Helper function to round percentage to nearest multiple of 5
        function roundToNearestFive(percentage) {
            if (!percentage) return '';
            const num = parseInt(percentage);
            if (isNaN(num)) return '';
            return Math.round(num / 5) * 5;
        }

        function loadKTLOData(ktloData) {
            try {
                // Load KTLO position setting
                const position = ktloData.position || 'bottom';
                const positionToggle = document.getElementById('ktlo-position-toggle');
                if (positionToggle) {
                    positionToggle.checked = (position === 'top');
                    // Reposition the KTLO section in the builder based on loaded data
                    setTimeout(repositionKTLOSection, 50);
                }
                
                // Load KTLO story info
                if (ktloData.story) {
                    const titleEl = document.getElementById('ktlo-title');
                    if (titleEl) titleEl.value = ktloData.story.title || 'KTLO';
                    
                    const bulletsEl = document.getElementById('ktlo-bullets');
                    if (bulletsEl && ktloData.story.bullets && Array.isArray(ktloData.story.bullets)) {
                        bulletsEl.value = ktloData.story.bullets.join('\n');
                    }
                }
                
                // Load monthly data
                if (ktloData.monthlyData && Array.isArray(ktloData.monthlyData)) {
                    ktloData.monthlyData.forEach(monthData => {
                        const monthLower = monthData.month.toLowerCase();
                        
                        // Round percentage to nearest multiple of 5 (legacy data fix)
                        const roundedPercentage = roundToNearestFive(monthData.percentage);
                        
                        // Store in the in-memory data structure
                        ktloMonthlyData[monthLower] = {
                            number: monthData.number || '',
                            percentage: roundedPercentage,
                            description: monthData.description || ''
                        };
                    });
                    
                    // Refresh the currently displayed month
                    const selector = document.getElementById('ktlo-month-selector');
                    if (selector) {
                        loadKTLOMonth(selector.value);
                    }
                }
            } catch (error) {
                // Don't throw the error, just continue so loading can complete
            }
        }
        
        function loadBTLData(btlData) {
            try {
                // Clear existing BTL stories
                document.getElementById('btl-stories-container').innerHTML = '';
                btlStoryCounter = 0;
                
                // Load BTL stories if they exist
                if (btlData.stories && Array.isArray(btlData.stories)) {
                    let loadedBTLCount = 0;
                    btlData.stories.forEach((story, index) => {
                        // Only load first 3 BTL stories, ignore the rest
                        if (loadedBTLCount >= 3) {
        
                            return;
                        }
                        
                        addBTLStory();
                        loadedBTLCount++;
                        const currentStoryId = `btl-${btlStoryCounter}`;
                        
                        // Set story data
                        const titleEl = document.getElementById(`btl-title-${currentStoryId}`);
                        const startEl = document.getElementById(`btl-start-${currentStoryId}`);
                        const endEl = document.getElementById(`btl-end-${currentStoryId}`);
                        const bulletsEl = document.getElementById(`btl-bullets-${currentStoryId}`);
                        const dateAddedEl = document.getElementById(`btl-dateadded-${currentStoryId}`);
                        const descriptionEl = document.getElementById(`btl-description-${currentStoryId}`);
                        
                        if (titleEl) titleEl.value = story.title || '';
                        
                        if (startEl) {
                            if (story.startDate) {
                                startEl.value = story.startDate;
                            } else if (story.startMonth) {
                                startEl.value = DateUtility.convertMonthToStartDate(story.startMonth);
                            }
                        }
                        
                        if (endEl) {
                            if (story.endDate) {
                                endEl.value = story.endDate;
                            } else if (story.endMonth) {
                                endEl.value = DateUtility.convertMonthToEndDate(story.endMonth);
                            }
                            // Clear any previous error styling when loading data
                            endEl.style.borderColor = '';
                            endEl.style.backgroundColor = '';
                        }
                        
                        if (bulletsEl && story.bullets && Array.isArray(story.bullets)) {
                            bulletsEl.value = story.bullets.join('\n');
                        }
                        
                        if (dateAddedEl) {
                            dateAddedEl.value = story.dateAdded || '';
                        }
                        
                        if (descriptionEl) {
                            descriptionEl.value = story.dateAddedDescription || '';
                        }
                        
                        // Set IMO field
                        const imoEl = document.getElementById(`btl-imo-${currentStoryId}`);
                        if (imoEl) {
                            imoEl.value = story.imo || '';
                        }
                    });
                }
                
                // Notify user if some BTL stories were skipped
                if (btlData.stories && btlData.stories.length > loadedBTLCount) {
                    const skippedCount = btlData.stories.length - loadedBTLCount;
    
                    if (skippedCount > 0) {
                        alert(`Note: ${skippedCount} BTL ${skippedCount === 1 ? 'story was' : 'stories were'} skipped during import due to the 3-story maximum limit.`);
                    }
                }
                
                updateBTLAddButton(); // Update button state after loading from JSON
            } catch (error) {
                // Don't throw the error, just continue so loading can complete
            }
        }
        


        function loadStoryData(storyId, story) {
            try {
                // Load basic story info with error checking
                const titleEl = document.getElementById(`story-title-${storyId}`);
                if (titleEl) {
                    titleEl.value = story.title || '';
                } else {
                    console.error(`Title element not found for story ${storyId}`);
                }
                
                // Load start/end dates with error checking and month conversion
                const startEl = document.getElementById(`story-start-${storyId}`);
                if (startEl) {
                    if (story.startDate) {
                        startEl.value = story.startDate;
                    } else if (story.startMonth) {
                        startEl.value = DateUtility.convertMonthToStartDate(story.startMonth);
                    }
                }
                
                const endEl = document.getElementById(`story-end-${storyId}`);
                if (endEl) {
                    if (story.endDate) {
                        endEl.value = story.endDate;
                    } else if (story.endMonth) {
                        endEl.value = DateUtility.convertMonthToEndDate(story.endMonth);
                    }
                    // Clear any previous error styling when loading data
                    endEl.style.borderColor = '';
                    endEl.style.backgroundColor = '';
                }
                
                // Load bullets with error checking
                if (story.bullets && Array.isArray(story.bullets)) {
                    const bulletsEl = document.getElementById(`story-bullets-${storyId}`);
                    if (bulletsEl) bulletsEl.value = story.bullets.join('\n');
                }
                
                // Load IMO field with error checking
                const imoEl = document.getElementById(`story-imo-${storyId}`);
                if (imoEl) {
                    imoEl.value = story.imo || '';
                }
                
                // Load status flags with error checking
                const doneEl = document.getElementById(`story-done-${storyId}`);
                const cancelledEl = document.getElementById(`story-cancelled-${storyId}`);
                const atRiskEl = document.getElementById(`story-atrisk-${storyId}`);
                const newStoryEl = document.getElementById(`story-newstory-${storyId}`);
                const infoEl = document.getElementById(`story-info-${storyId}`);
                const transferredOutEl = document.getElementById(`story-transferredout-${storyId}`);
                const transferredInEl = document.getElementById(`story-transferredin-${storyId}`);
                const proposedEl = document.getElementById(`story-proposed-${storyId}`);
                if (doneEl) doneEl.checked = story.isDone || false;
                if (cancelledEl) cancelledEl.checked = story.isCancelled || false;
                if (atRiskEl) atRiskEl.checked = story.isAtRisk || false;
                if (newStoryEl) newStoryEl.checked = story.isNewStory || false;
                if (infoEl) infoEl.checked = story.isInfo || false;
                // Backward compatibility: map old isHandedOver to new isTransferredOut property
                if (transferredOutEl) transferredOutEl.checked = story.isTransferredOut || story.isHandedOver || false;
                if (transferredInEl) transferredInEl.checked = story.isTransferredIn || false;
                if (proposedEl) proposedEl.checked = story.isProposed || false;
            
                // Load timeline changes with error checking
                if (story.hasRoadmapChanges && story.roadmapChanges) {
                    // Load timeline changes if they exist
                    if (story.roadmapChanges.changes && Array.isArray(story.roadmapChanges.changes) && story.roadmapChanges.changes.length > 0) {
                        const changesCheckbox = document.getElementById(`story-changes-${storyId}`);
                        const changesSection = document.getElementById(`changes-section-${storyId}`);
                        
                        if (changesCheckbox && changesSection) {
                            // Manually show the timeline changes section without triggering toggleChanges
                            changesSection.style.display = 'block';
                            
                            // Wait a moment for DOM elements to be created, then load the changes
                            setTimeout(() => {
                                story.roadmapChanges.changes.forEach((change, index) => {
                                    addChange(storyId);
                                    
                                    // Find the most recently added change element (container)
                                    const changeContainers = document.querySelectorAll(`#changes-container-${storyId} > div[id^="change-${storyId}-change-"]`);
                                    const latestContainer = changeContainers[changeContainers.length - 1];
                                    if (latestContainer) {
                                        // Use the full ID pattern that matches collection logic: "1-4-change-1750523457266"
                                        const fullChangeId = latestContainer.id.replace('change-', '');
                                        
                                        const dateEl = document.getElementById(`change-date-${fullChangeId}`);
                                        const prevEl = document.getElementById(`change-prev-${fullChangeId}`);
                                        const newEl = document.getElementById(`change-new-${fullChangeId}`);
                                        const descEl = document.getElementById(`change-desc-${fullChangeId}`);
                                        
                                        if (dateEl) dateEl.value = change.date || '';
                                        if (prevEl) prevEl.value = change.prevEndDate || '';
                                        if (newEl) newEl.value = change.newEndDate || '';
                                        if (descEl) descEl.value = change.description || '';
                                        
                                        // Update the header to show the correct number
                                        const header = latestContainer.querySelector('strong');
                                        if (header) {
                                            header.textContent = `Timeline #${index + 1}`;
                                        }
                                    }
                                });
                                
                                // Update button state after loading all changes
                                updateChangeButton(storyId);
                                
                                // Only AFTER loading all the changes, set the checkbox to checked
                                changesCheckbox.checked = true;
                            }, 50);
                        }
                    }
                    
                    // Load done info and show done section if needed
                    if (story.roadmapChanges.doneInfo) {
                        const doneDateEl = document.getElementById(`done-date-${storyId}`);
                        const doneNotesEl = document.getElementById(`done-notes-${storyId}`);
                        if (doneDateEl) doneDateEl.value = story.roadmapChanges.doneInfo.date || '';
                        if (doneNotesEl) doneNotesEl.value = story.roadmapChanges.doneInfo.notes || '';
                        
                        // Show the done section if there's done info
                        if (story.isDone) {
                            const doneSectionEl = document.getElementById(`done-section-${storyId}`);
                            if (doneSectionEl) doneSectionEl.style.display = 'block';
                        }
                    }
                    
                    // Load cancel info and show cancelled section if needed
                    if (story.roadmapChanges.cancelInfo) {
                        const cancelDateEl = document.getElementById(`cancel-date-${storyId}`);
                        const cancelNotesEl = document.getElementById(`cancel-notes-${storyId}`);
                        if (cancelDateEl) cancelDateEl.value = story.roadmapChanges.cancelInfo.date || '';
                        if (cancelNotesEl) cancelNotesEl.value = story.roadmapChanges.cancelInfo.notes || '';
                        
                        // Show the cancelled section if there's cancel info
                        if (story.isCancelled) {
                            const cancelSectionEl = document.getElementById(`cancelled-section-${storyId}`);
                            if (cancelSectionEl) cancelSectionEl.style.display = 'block';
                        }
                    }
                    
                    // Load at risk info and show at risk section if needed
                    if (story.roadmapChanges.atRiskInfo) {
                        const atRiskDateEl = document.getElementById(`atrisk-date-${storyId}`);
                        const atRiskNotesEl = document.getElementById(`atrisk-notes-${storyId}`);
                        if (atRiskDateEl) atRiskDateEl.value = story.roadmapChanges.atRiskInfo.date || '';
                        if (atRiskNotesEl) atRiskNotesEl.value = story.roadmapChanges.atRiskInfo.notes || '';
                        
                        // Show the at risk section if there's at risk info (regardless of checkbox state)
                        const atRiskSectionEl = document.getElementById(`atrisk-section-${storyId}`);
                        if (atRiskSectionEl) atRiskSectionEl.style.display = 'block';
                        
                        // Also ensure the checkbox is checked if there's data
                        const atRiskCheckbox = document.getElementById(`story-atrisk-${storyId}`);
                        if (atRiskCheckbox && (story.roadmapChanges.atRiskInfo.date || story.roadmapChanges.atRiskInfo.notes)) {
                            atRiskCheckbox.checked = true;
                        }
                    }
                    
                    // Load new story info and show new story section if needed
                    if (story.roadmapChanges.newStoryInfo) {
                        const newStoryDateEl = document.getElementById(`newstory-date-${storyId}`);
                        const newStoryNotesEl = document.getElementById(`newstory-notes-${storyId}`);
                        if (newStoryDateEl) newStoryDateEl.value = story.roadmapChanges.newStoryInfo.date || '';
                        if (newStoryNotesEl) newStoryNotesEl.value = story.roadmapChanges.newStoryInfo.notes || '';
                        
                        // Show the new story section if there's new story info
                        if (story.isNewStory) {
                            const newStorySectionEl = document.getElementById(`newstory-section-${storyId}`);
                            if (newStorySectionEl) newStorySectionEl.style.display = 'block';
                        }
                    }
                    
                    // Load info info and show info section if needed
                    if (story.roadmapChanges.infoInfo) {
                        const infoEntriesContainer = document.getElementById(`info-entries-${storyId}`);
                        if (infoEntriesContainer) {
                            // Clear existing entries
                            infoEntriesContainer.innerHTML = '';
                            
                            if (Array.isArray(story.roadmapChanges.infoInfo)) {
                                // Multiple info entries
                                story.roadmapChanges.infoInfo.forEach((entry, index) => {
                                    const entryId = `info-entry-${storyId}-${Date.now()}-${index}`;
                                    const entryHtml = `
                                        <div id="${entryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                                <strong>Info Entry #${index + 1}</strong>
                                                <button type="button" onclick="removeInfoEntry('${entryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                                            </div>
                                            <div class="inline-group">
                                                <div class="form-group">
                                                    <label for="info-date-${entryId}">Info Date:</label>
                                                    <input type="text" id="info-date-${entryId}" placeholder="15/01 or 15/01/25 or 15-01-2025" value="${entry.date || ''}">
                                                </div>
                                                <div class="form-group">
                                                    <label for="info-notes-${entryId}">Information Details:</label>
                                                    <textarea id="info-notes-${entryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;">${entry.notes || ''}</textarea>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                    infoEntriesContainer.insertAdjacentHTML('beforeend', entryHtml);
                                    
                                    // Add auto-update listeners
                                    const dateInput = document.getElementById(`info-date-${entryId}`);
                                    const notesInput = document.getElementById(`info-notes-${entryId}`);
                                    if (dateInput) dateInput.addEventListener('input', () => generatePreview());
                                    if (notesInput) notesInput.addEventListener('input', () => generatePreview());
                                });
                            } else {
                                // Single info entry (backward compatibility)
                                const entryId = `info-entry-${storyId}-${Date.now()}`;
                                const entryHtml = `
                                    <div id="${entryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                            <strong>Info Entry #1</strong>
                                            <button type="button" onclick="removeInfoEntry('${entryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                                        </div>
                                        <div class="inline-group">
                                            <div class="form-group">
                                                <label for="info-date-${entryId}">Info Date:</label>
                                                <input type="text" id="info-date-${entryId}" placeholder="15/01 or 15/01/25 or 15-01-2025" value="${story.roadmapChanges.infoInfo.date || ''}">
                                            </div>
                                            <div class="form-group">
                                                <label for="info-notes-${entryId}">Information Details:</label>
                                                <textarea id="info-notes-${entryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;">${story.roadmapChanges.infoInfo.notes || ''}</textarea>
                                            </div>
                                        </div>
                                    </div>
                                `;
                                infoEntriesContainer.insertAdjacentHTML('beforeend', entryHtml);
                                
                                // Add auto-update listeners
                                const dateInput = document.getElementById(`info-date-${entryId}`);
                                const notesInput = document.getElementById(`info-notes-${entryId}`);
                                if (dateInput) dateInput.addEventListener('input', () => generatePreview());
                                if (notesInput) notesInput.addEventListener('input', () => generatePreview());
                                
                                // Convert the data structure from old single format to new multiple format
                                story.roadmapChanges.infoInfo = [{
                                    date: story.roadmapChanges.infoInfo.date,
                                    notes: story.roadmapChanges.infoInfo.notes
                                }];
                            }
                        }
                        
                        // Show the info section if there's info info
                        if (story.isInfo) {
                            const infoSectionEl = document.getElementById(`info-section-${storyId}`);
                            if (infoSectionEl) infoSectionEl.style.display = 'block';
                        }
                    }
                    
                    // Load transferred out info and show transferred out section if needed
                    // Backward compatibility: check both old handedOverInfo and new transferredOutInfo
                    const transferredOutData = story.roadmapChanges.transferredOutInfo || story.roadmapChanges.handedOverInfo;
                    if (transferredOutData) {
                        const transferredOutDateEl = document.getElementById(`transferredout-date-${storyId}`);
                        const transferredOutNotesEl = document.getElementById(`transferredout-notes-${storyId}`);
                        if (transferredOutDateEl) transferredOutDateEl.value = transferredOutData.date || '';
                        if (transferredOutNotesEl) transferredOutNotesEl.value = transferredOutData.notes || '';
                        
                        // Show the transferred out section if there's transferred out info
                        if (story.isTransferredOut) {
                            const transferredOutSectionEl = document.getElementById(`transferredout-section-${storyId}`);
                            if (transferredOutSectionEl) transferredOutSectionEl.style.display = 'block';
                        }
                    }
                    
                    // Load transferred in info and show transferred in section if needed
                    if (story.roadmapChanges.transferredInInfo) {
                        const transferredInDateEl = document.getElementById(`transferredin-date-${storyId}`);
                        const transferredInNotesEl = document.getElementById(`transferredin-notes-${storyId}`);
                        if (transferredInDateEl) transferredInDateEl.value = story.roadmapChanges.transferredInInfo.date || '';
                        if (transferredInNotesEl) transferredInNotesEl.value = story.roadmapChanges.transferredInInfo.notes || '';
                        
                        // Show the transferred in section if there's transferred in info
                        if (story.isTransferredIn) {
                            const transferredInSectionEl = document.getElementById(`transferredin-section-${storyId}`);
                            if (transferredInSectionEl) transferredInSectionEl.style.display = 'block';
                        }
                    }
                    
                    // Load proposed info and show proposed section if needed
                    if (story.roadmapChanges.proposedInfo) {
                        const proposedDateEl = document.getElementById(`proposed-date-${storyId}`);
                        const proposedNotesEl = document.getElementById(`proposed-notes-${storyId}`);
                        if (proposedDateEl) proposedDateEl.value = story.roadmapChanges.proposedInfo.date || '';
                        if (proposedNotesEl) proposedNotesEl.value = story.roadmapChanges.proposedInfo.notes || '';
                        
                        // Show the proposed section if there's proposed info
                        if (story.isProposed) {
                            const proposedSectionEl = document.getElementById(`proposed-section-${storyId}`);
                            if (proposedSectionEl) proposedSectionEl.style.display = 'block';
                        }
                    }
                }
            } catch (error) {
                // Continue loading other stories even if this one fails
            }
        }
        
        async function exportHTML() {
            const teamData = collectFormData();
            const generator = new RoadmapGenerator(teamData.roadmapYear);
            const html = generator.generateRoadmap(teamData, false, false); // standalone export with editing disabled
            const blob = new Blob([html], { type: 'text/html' });
            
            // Generate default filename
            const defaultFileName = `${teamData.teamName || 'MyTeam'}.Teya-Roadmap.${teamData.roadmapYear || 2025}.html`;
            
            // Try to use the File System Access API for native save dialog
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: defaultFileName,
                        types: [{
                            description: 'HTML Roadmap files',
                            accept: {
                                'text/html': ['.html']
                            }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    
                    return;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        // User cancelled the save dialog
                        return;
                    }
                    // File System Access API failed, fall back to download
                }
            }
            
            // Fallback to download method for browsers that don't support File System Access API
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = defaultFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        
        function showFullscreen() {
            // Generate fullscreen version only when needed
            if (window.currentTeamData) {
                const generator = new RoadmapGenerator(window.currentTeamData.roadmapYear);
                const fullscreenHtml = generator.generateRoadmap(window.currentTeamData, false, false); // fullscreen preview with editing disabled
                const fullscreenIframe = document.getElementById('fullscreen-preview');
                fullscreenIframe.srcdoc = fullscreenHtml;
            }
            
            const overlay = document.getElementById('fullscreen-overlay');
            overlay.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }
        
        function hideFullscreen() {
            const overlay = document.getElementById('fullscreen-overlay');
            overlay.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restore scrolling
        }
        
        function toggleFullscreen() {
            const previewPanel = document.querySelector('.preview-panel');
            
            if (!document.fullscreenElement) {
                // Enter fullscreen
                if (previewPanel.requestFullscreen) {
                    previewPanel.requestFullscreen();
                } else if (previewPanel.mozRequestFullScreen) {
                    previewPanel.mozRequestFullScreen();
                } else if (previewPanel.webkitRequestFullscreen) {
                    previewPanel.webkitRequestFullscreen();
                } else if (previewPanel.msRequestFullscreen) {
                    previewPanel.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Check if user is currently typing in an editable element
            const activeElement = document.activeElement;
            const isEditable = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.contentEditable === 'true'
            );
            
            // Always allow Escape key to work (to close modals)
            if (event.key === 'Escape') {
                hideFullscreen();
                closeEditModal();
                closeEditMonthlyKTLOModal();
                closeNewRoadmapModal();
                return;
            }
            
            // Don't handle other shortcuts when user is typing in an editable field
            if (isEditable) {
                return;
            }
            
            // Shift-B to toggle builder
            if (event.shiftKey && event.key === 'B') {
                event.preventDefault();
                toggleBuilderCollapse();
            }
            
            // Shift-F to toggle file explorer
            if (event.shiftKey && event.key === 'F') {
                event.preventDefault();
                toggleFileBrowser();
            }
        });

        // Modal functions
        let currentEditingStory = null;
        let modalFocusTrap = null;

        function setupModalFocusTrap(modalId) {
            const modal = document.getElementById(modalId);
            if (!modal) return;

            // Get all focusable elements within the modal
            const getFocusableElements = () => {
                const focusableSelectors = [
                    'input:not([disabled]):not([type="hidden"]):not([tabindex="-1"])',
                    'select:not([disabled]):not([tabindex="-1"])',
                    'textarea:not([disabled]):not([tabindex="-1"])',
                    'button:not([disabled]):not([tabindex="-1"])',
                    'a[href]:not([tabindex="-1"])',
                    '[tabindex]:not([tabindex="-1"])'
                ];

                return Array.from(modal.querySelectorAll(focusableSelectors.join(', ')))
                    .filter(el => {
                        // Additional visibility check
                        const style = window.getComputedStyle(el);
                        const rect = el.getBoundingClientRect();
                        return (
                            style.display !== 'none' &&
                            style.visibility !== 'hidden' &&
                            style.opacity !== '0' &&
                            rect.width > 0 &&
                            rect.height > 0 &&
                            !(el.closest('[style*="display: none"]') || el.closest('[style*="display:none"]'))
                        );
                    });
            };

            const trapFocus = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    // Close the appropriate modal
                    if (modalId === 'editStoryModal') {
                        closeEditModal();
                    } else if (modalId === 'editMonthlyKTLOModal') {
                        closeEditMonthlyKTLOModal();
                    }
                    return;
                }

                if (e.key !== 'Tab') return;

                const focusableElements = getFocusableElements();
                if (focusableElements.length === 0) return;

                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];

                if (e.shiftKey) {
                    // Shift+Tab: going backwards
                    if (document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    }
                } else {
                    // Tab: going forwards
                    if (document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            };

            // Set up the focus trap
            modal.addEventListener('keydown', trapFocus);
            
            // Focus the first focusable element
            setTimeout(() => {
                const focusableElements = getFocusableElements();
                if (focusableElements.length > 0) {
                    focusableElements[0].focus();
                }
            }, 100);

            return {
                remove: () => {
                    modal.removeEventListener('keydown', trapFocus);
                }
            };
        }

        function removeModalFocusTrap() {
            if (modalFocusTrap) {
                modalFocusTrap.remove();
                modalFocusTrap = null;
            }
        }

        function openEditStoryModal(storyData) {
            currentEditingStory = storyData;
            
            // Find the actual story data in the form
            const foundStory = findStoryInForm(storyData.epicName, storyData.storyTitle, storyData.storyIndex);
            if (!foundStory) {
                alert('Could not find story data in form. Epic: "' + storyData.epicName + '", Story: "' + storyData.storyTitle + '", Index: ' + storyData.storyIndex + '. Please try editing from the main form instead.');
                return;
            }
            
            // Set modal title
            document.getElementById('editStoryTitle').textContent = `Edit Story: ${storyData.storyTitle}`;
            
            // Populate form fields
            document.getElementById('editTitle').value = foundStory.title || '';
            
            // Handle both startDate/startMonth and start property formats
            const startValue = foundStory.startDate || foundStory.startMonth || foundStory.start || '';
            const endValue = foundStory.endDate || foundStory.endMonth || foundStory.end || '';
            document.getElementById('editStart').value = startValue;
            const editEndField = document.getElementById('editEnd');
            editEndField.value = endValue;
            // Clear any previous error styling when loading data
            editEndField.style.borderColor = '';
            editEndField.style.backgroundColor = '';
            
            document.getElementById('editBullets').value = foundStory.bullets || '';
            document.getElementById('editIMO').value = foundStory.imo || '';
            
            // Special handling for KTLO and BTL - disable fields that don't apply
            const isKTLO = storyData.epicName === 'KTLO';
            const isBTL = storyData.epicName === 'Below the Line';
            
            // Show/hide KTLO position toggle
            document.getElementById('editKTLOPositionGroup').style.display = isKTLO ? 'block' : 'none';
            if (isKTLO && foundStory.position !== undefined) {
                document.getElementById('editKTLOPosition').checked = foundStory.position;
            }
            
            // Show/hide KTLO monthly data section
            document.getElementById('editKTLOMonthlySection').style.display = isKTLO ? 'block' : 'none';
            if (isKTLO) {
                initializeEditKTLOMonths();
            }
            
            // Show/hide BTL Date Added section
            document.getElementById('editBTLDateAddedGroup').style.display = isBTL ? 'block' : 'none';
            document.getElementById('editBTLDescriptionGroup').style.display = isBTL ? 'block' : 'none';
            if (isBTL) {
                document.getElementById('editBTLDateAdded').value = foundStory.dateAdded || '';
                document.getElementById('editBTLDescription').value = foundStory.dateAddedDescription || '';
            }
            
            // Disable start/end dates for KTLO (it spans full year)
            document.getElementById('editStart').disabled = isKTLO;
            document.getElementById('editEnd').disabled = isKTLO;
            
            // Hide status checkboxes for KTLO and BTL
            const statusCheckboxes = document.querySelectorAll('#editStoryModal .checkbox-group');
            statusCheckboxes.forEach(checkboxGroup => {
                checkboxGroup.style.display = (isKTLO || isBTL) ? 'none' : 'flex';
            });
            
            // Hide status fields for KTLO and BTL
            document.getElementById('editStatusFields').style.display = (isKTLO || isBTL) ? 'none' : 'block';
            document.getElementById('editTimelineChangesSection').style.display = (isKTLO || isBTL) ? 'none' : 'block';
            
            // Hide move buttons for KTLO (it can't be reordered) but show for BTL
            const moveButtons = document.querySelectorAll('button[onclick*="moveCurrentStory"]');
            moveButtons.forEach(button => {
                button.style.display = isKTLO ? 'none' : 'inline-block';
            });
            
            // Set checkboxes
            document.getElementById('editDone').checked = foundStory.isDone || false;
            document.getElementById('editCancelled').checked = foundStory.isCancelled || false;
            document.getElementById('editAtRisk').checked = foundStory.isAtRisk || false;
            document.getElementById('editNewStory').checked = foundStory.isNewStory || false;
            document.getElementById('editInfo').checked = foundStory.isInfo || false;
            document.getElementById('editTransferredOut').checked = foundStory.isTransferredOut || false;
            document.getElementById('editTransferredIn').checked = foundStory.isTransferredIn || false;
            document.getElementById('editProposed').checked = foundStory.isProposed || false;
            document.getElementById('editTimelineChanges').checked = foundStory.hasTimelineChanges || false;
            
            // Set status information
            document.getElementById('editDoneDate').value = foundStory.doneDate || '';
            document.getElementById('editDoneNotes').value = foundStory.doneNotes || '';
            document.getElementById('editCancelDate').value = foundStory.cancelDate || '';
            document.getElementById('editCancelNotes').value = foundStory.cancelNotes || '';
            document.getElementById('editAtRiskDate').value = foundStory.atRiskDate || '';
            document.getElementById('editAtRiskNotes').value = foundStory.atRiskNotes || '';
            document.getElementById('editNewStoryDate').value = foundStory.newStoryDate || '';
            document.getElementById('editNewStoryNotes').value = foundStory.newStoryNotes || '';
            // Load info entries (multiple instances)
            const editInfoEntriesContainer = document.getElementById('editInfoEntries');
            if (editInfoEntriesContainer) {
                // Clear existing entries
                editInfoEntriesContainer.innerHTML = '';
                editInfoEntryCounter = 0;
                
                if (foundStory.roadmapChanges && foundStory.roadmapChanges.infoInfo) {
                    if (Array.isArray(foundStory.roadmapChanges.infoInfo)) {
                        // Multiple info entries
                        foundStory.roadmapChanges.infoInfo.forEach((entry, index) => {
                            const entryId = `edit-info-entry-${editInfoEntryCounter++}`;
                            const entryHtml = `
                                <div id="${entryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <strong>Info Entry #${index + 1}</strong>
                                        <button type="button" onclick="removeEditInfoEntry('${entryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                                    </div>
                                    <div class="inline-group">
                                        <div class="form-group">
                                            <label for="edit-info-date-${entryId}">Info Date:</label>
                                            <input type="text" id="edit-info-date-${entryId}" placeholder="15/01 or 15/01/25 or 15-01-2025" value="${entry.date || ''}">
                                        </div>
                                        <div class="form-group">
                                            <label for="edit-info-notes-${entryId}">Information Details:</label>
                                            <textarea id="edit-info-notes-${entryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;">${entry.notes || ''}</textarea>
                                        </div>
                                    </div>
                                </div>
                            `;
                            editInfoEntriesContainer.insertAdjacentHTML('beforeend', entryHtml);
                        });
                    } else {
                        // Single info entry (backward compatibility)
                        const entryId = `edit-info-entry-${editInfoEntryCounter++}`;
                        const entryHtml = `
                            <div id="${entryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <strong>Info Entry #1</strong>
                                    <button type="button" onclick="removeEditInfoEntry('${entryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                                </div>
                                <div class="inline-group">
                                    <div class="form-group">
                                        <label for="edit-info-date-${entryId}">Info Date:</label>
                                        <input type="text" id="edit-info-date-${entryId}" placeholder="15/01 or 15/01/25 or 15-01-2025" value="${foundStory.roadmapChanges.infoInfo.date || ''}">
                                    </div>
                                    <div class="form-group">
                                        <label for="edit-info-notes-${entryId}">Information Details:</label>
                                        <textarea id="edit-info-notes-${entryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;">${foundStory.roadmapChanges.infoInfo.notes || ''}</textarea>
                                    </div>
                                </div>
                            </div>
                        `;
                        editInfoEntriesContainer.insertAdjacentHTML('beforeend', entryHtml);
                        
                        // Convert the data structure from old single format to new multiple format
                        foundStory.roadmapChanges.infoInfo = [{
                            date: foundStory.roadmapChanges.infoInfo.date,
                            notes: foundStory.roadmapChanges.infoInfo.notes
                        }];
                    }
                } else {
                    // Check if data has been converted in the main form
                    const mainFormInfoEntries = [];
                    const mainFormInfoContainer = document.getElementById(`info-entries-${foundStory.storyId}`);
                    if (mainFormInfoContainer) {
                        const mainFormEntries = mainFormInfoContainer.querySelectorAll('.info-entry');
                        mainFormEntries.forEach(entry => {
                            const entryId = entry.id;
                            const dateEl = document.getElementById(`info-date-${entryId}`);
                            const notesEl = document.getElementById(`info-notes-${entryId}`);
                            if (dateEl && notesEl && (dateEl.value || notesEl.value)) {
                                mainFormInfoEntries.push({
                                    date: dateEl.value,
                                    notes: notesEl.value
                                });
                            }
                        });
                    }
                    
                    if (mainFormInfoEntries.length > 0) {
                        // Use converted data from main form
                        mainFormInfoEntries.forEach((entry, index) => {
                            const entryId = `edit-info-entry-${editInfoEntryCounter++}`;
                            const entryHtml = `
                                <div id="${entryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <strong>Info Entry #${index + 1}</strong>
                                        <button type="button" onclick="removeEditInfoEntry('${entryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                                    </div>
                                    <div class="inline-group">
                                        <div class="form-group">
                                            <label for="edit-info-date-${entryId}">Info Date:</label>
                                            <input type="text" id="edit-info-date-${entryId}" placeholder="15/01 or 15/01/25 or 15-01-2025" value="${entry.date || ''}">
                                        </div>
                                        <div class="form-group">
                                            <label for="edit-info-notes-${entryId}">Information Details:</label>
                                            <textarea id="edit-info-notes-${entryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;">${entry.notes || ''}</textarea>
                                        </div>
                                    </div>
                                </div>
                            `;
                            editInfoEntriesContainer.insertAdjacentHTML('beforeend', entryHtml);
                        });
                    } else if (foundStory.infoDate || foundStory.infoNotes) {
                        // Fallback to old single info format
                        const entryId = `edit-info-entry-${editInfoEntryCounter++}`;
                        const entryHtml = `
                            <div id="${entryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <strong>Info Entry #1</strong>
                                    <button type="button" onclick="removeEditInfoEntry('${entryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                                </div>
                                <div class="inline-group">
                                    <div class="form-group">
                                        <label for="edit-info-date-${entryId}">Info Date:</label>
                                        <input type="text" id="edit-info-date-${entryId}" placeholder="15/01 or 15/01/25 or 15-01-2025" value="${foundStory.infoDate || ''}">
                                    </div>
                                    <div class="form-group">
                                        <label for="edit-info-notes-${entryId}">Information Details:</label>
                                        <textarea id="edit-info-notes-${entryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;">${foundStory.infoNotes || ''}</textarea>
                                    </div>
                                </div>
                            </div>
                        `;
                        editInfoEntriesContainer.insertAdjacentHTML('beforeend', entryHtml);
                    }
                }
            }
            // Backward compatibility: handle both old handedOver and new transferredOut properties
            document.getElementById('editTransferredOutDate').value = foundStory.transferredOutDate || foundStory.handedOverDate || '';
            document.getElementById('editTransferredOutNotes').value = foundStory.transferredOutNotes || foundStory.handedOverNotes || '';
            document.getElementById('editTransferredInDate').value = foundStory.transferredInDate || '';
            document.getElementById('editTransferredInNotes').value = foundStory.transferredInNotes || '';
            document.getElementById('editProposedDate').value = foundStory.proposedDate || '';
            document.getElementById('editProposedNotes').value = foundStory.proposedNotes || '';
            
            // Load existing timeline changes FIRST (before calling toggle functions)
            if (foundStory.hasTimelineChanges && foundStory.timelineChanges && foundStory.timelineChanges.length > 0) {
                // Clear existing changes first
                document.getElementById('editChangesContainer').innerHTML = '';
                editChangeCounter = 0;
                
                // Sort timeline changes by date before displaying in modal
                const sortedTimelineChanges = sortTimelineChangesByDate([...foundStory.timelineChanges]);
                
                // Add each timeline change in chronological order
                sortedTimelineChanges.forEach(change => {
                    addEditChange();
                    const changeId = `edit-change-${editChangeCounter}`;
                    document.getElementById(`${changeId}-date`).value = change.date || '';
                    document.getElementById(`${changeId}-desc`).value = change.description || '';
                    document.getElementById(`${changeId}-prev`).value = change.prevEndDate || '';
                    document.getElementById(`${changeId}-new`).value = change.newEndDate || '';
                });
                
                // Update button state after loading all changes
                updateEditChangeButton();
            } else {
                // Clear any existing changes
                document.getElementById('editChangesContainer').innerHTML = '';
                editChangeCounter = 0;
                
                // Update button state after clearing changes
                updateEditChangeButton();
            }
            
            // Show/hide appropriate status fields (after timeline changes are loaded)
            toggleEditStatusFields();
            toggleEditTimelineChanges();
            
            // Clear date picker initialization flags to allow re-initialization
            const modalDateFields = [
                'editStart', 'editEnd', 'editDoneDate', 'editCancelDate', 
                'editAtRiskDate', 'editNewStoryDate', 'editTransferredOutDate', 'editBTLDateAdded'
            ];
            
            modalDateFields.forEach(fieldId => {
                const element = document.getElementById(fieldId);
                if (element) {
                    element.dataset.datePickerInitialized = 'false';
                    if (element.id) {
                        initializedDatePickers.delete(element.id);
                    }
                }
            });
            
            // Initialize date pickers for modal fields immediately (no setTimeout needed)
            const initializeModalDatePickers = () => {
                // Main modal date fields
                initializeDatePicker(document.getElementById('editStart'), true);
                initializeDatePicker(document.getElementById('editEnd'), true);
                initializeDatePicker(document.getElementById('editDoneDate'), false);
                initializeDatePicker(document.getElementById('editCancelDate'), false);
                initializeDatePicker(document.getElementById('editAtRiskDate'), false);
                initializeDatePicker(document.getElementById('editNewStoryDate'), false);
                initializeDatePicker(document.getElementById('editTransferredOutDate'), false);
                
                // BTL date added field
                initializeDatePicker(document.getElementById('editBTLDateAdded'), false);
                
                // Timeline change date fields in modal
                document.querySelectorAll('#editChangesContainer input[id*="-date"], #editChangesContainer input[id*="-prev"], #editChangesContainer input[id*="-new"]').forEach(input => {
                    input.dataset.datePickerInitialized = 'false';
                    if (input.id) {
                        initializedDatePickers.delete(input.id);
                    }
                    initializeDatePicker(input, false);
                });
            };
            
            // Initialize immediately and again after a small delay for any dynamic fields
            initializeModalDatePickers();
            setTimeout(initializeModalDatePickers, 100);
            
            // Initialize BTL date picker if this is a BTL story
            if (isBTL) {
                setTimeout(() => {
                    initializeDatePicker(document.getElementById('editBTLDateAdded'), false);
                }, 150);
            }
            
            // Show modal
            document.getElementById('editStoryModal').style.display = 'flex';
            
            // Set up focus trap
            modalFocusTrap = setupModalFocusTrap('editStoryModal');
            
            // Add Enter key listener for Save Changes
            const editStoryModal = document.getElementById('editStoryModal');
            const handleEnterKey = (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    // Check if user is currently typing in an editable element
                    const activeElement = document.activeElement;
                    const isEditable = activeElement && (
                        activeElement.tagName === 'INPUT' ||
                        activeElement.tagName === 'TEXTAREA' ||
                        activeElement.contentEditable === 'true'
                    );
                    
                    // Don't trigger save when user is typing in a form field
                    if (isEditable) {
                        return;
                    }
                    
                    event.preventDefault();
                    saveStoryChanges();
                }
            };
            editStoryModal.addEventListener('keydown', handleEnterKey);
            
            // Store the handler so we can remove it later
            editStoryModal._enterKeyHandler = handleEnterKey;
        }

        function closeEditModal() {
            const editStoryModal = document.getElementById('editStoryModal');
            editStoryModal.style.display = 'none';
            currentEditingStory = null;
            
            // Remove Enter key listener
            if (editStoryModal._enterKeyHandler) {
                editStoryModal.removeEventListener('keydown', editStoryModal._enterKeyHandler);
                delete editStoryModal._enterKeyHandler;
            }
            
            // Remove focus trap
            removeModalFocusTrap();
            
            // Reset form fields to their enabled/visible state for next use
            document.getElementById('editStart').disabled = false;
            document.getElementById('editEnd').disabled = false;
            document.getElementById('editKTLOPositionGroup').style.display = 'none';
            document.getElementById('editKTLOMonthlySection').style.display = 'none';
            document.getElementById('editBTLDateAddedGroup').style.display = 'none';
            document.getElementById('editBTLDescriptionGroup').style.display = 'none';
            
            // Reset monthly KTLO data visibility
            const monthlyContainer = document.getElementById('editKTLOMonthsContainer');
            if (monthlyContainer) {
                monthlyContainer.style.display = 'block';
            }
            
            const statusCheckboxes = document.querySelector('#editStoryModal .checkbox-group');
            if (statusCheckboxes) {
                statusCheckboxes.style.display = 'flex';
            }
            
            document.getElementById('editStatusFields').style.display = 'block';
            document.getElementById('editTimelineChangesSection').style.display = 'block';
            
            const moveButtons = document.querySelectorAll('button[onclick*="moveCurrentStory"]');
            moveButtons.forEach(button => {
                button.style.display = 'inline-block';
            });
        }

        function toggleEditStatusFields() {
            const doneChecked = document.getElementById('editDone').checked;
            const cancelledChecked = document.getElementById('editCancelled').checked;
            const atRiskChecked = document.getElementById('editAtRisk').checked;
            const newStoryChecked = document.getElementById('editNewStory').checked;
            const infoChecked = document.getElementById('editInfo').checked;
            const transferredOutChecked = document.getElementById('editTransferredOut').checked;
            const transferredInChecked = document.getElementById('editTransferredIn').checked;
            const proposedChecked = document.getElementById('editProposed').checked;
            
            document.getElementById('editDoneFields').style.display = doneChecked ? 'block' : 'none';
            document.getElementById('editCancelFields').style.display = cancelledChecked ? 'block' : 'none';
            document.getElementById('editAtRiskFields').style.display = atRiskChecked ? 'block' : 'none';
            document.getElementById('editNewStoryFields').style.display = newStoryChecked ? 'block' : 'none';
            document.getElementById('editInfoFields').style.display = infoChecked ? 'block' : 'none';
            document.getElementById('editTransferredOutFields').style.display = transferredOutChecked ? 'block' : 'none';
            document.getElementById('editTransferredInFields').style.display = transferredInChecked ? 'block' : 'none';
            document.getElementById('editProposedFields').style.display = proposedChecked ? 'block' : 'none';
            
            // Reinitialize date pickers for newly visible fields
            setTimeout(() => {
                if (doneChecked) initializeDatePicker(document.getElementById('editDoneDate'), false);
                if (cancelledChecked) initializeDatePicker(document.getElementById('editCancelDate'), false);
                if (atRiskChecked) initializeDatePicker(document.getElementById('editAtRiskDate'), false);
                if (newStoryChecked) initializeDatePicker(document.getElementById('editNewStoryDate'), false);
                // Info entries are handled dynamically, no single date picker needed
                if (transferredOutChecked) initializeDatePicker(document.getElementById('editTransferredOutDate'), false);
                if (transferredInChecked) initializeDatePicker(document.getElementById('editTransferredInDate'), false);
                if (proposedChecked) initializeDatePicker(document.getElementById('editProposedDate'), false);
            }, 10);
            
            // Auto-fill today's date if fields are empty and checkboxes are checked
            if (doneChecked) {
                const doneDateField = document.getElementById('editDoneDate');
                if (doneDateField && !doneDateField.value) {
                    doneDateField.value = getTodaysDateEuropean();
                }
            }
            
            if (cancelledChecked) {
                const cancelDateField = document.getElementById('editCancelDate');
                if (cancelDateField && !cancelDateField.value) {
                    cancelDateField.value = getTodaysDateEuropean();
                }
            }
            
            if (atRiskChecked) {
                const atRiskDateField = document.getElementById('editAtRiskDate');
                if (atRiskDateField && !atRiskDateField.value) {
                    atRiskDateField.value = getTodaysDateEuropean();
                }
            }
            
            if (newStoryChecked) {
                const newStoryDateField = document.getElementById('editNewStoryDate');
                if (newStoryDateField && !newStoryDateField.value) {
                    newStoryDateField.value = getTodaysDateEuropean();
                }
            }
            
            // Info entries are handled dynamically with addEditInfoEntry function
            if (infoChecked) {
                // Auto-create first info entry if none exist
                setTimeout(() => {
                    const editInfoEntriesContainer = document.getElementById('editInfoEntries');
                    if (editInfoEntriesContainer) {
                        const existingEntries = editInfoEntriesContainer.querySelectorAll('.info-entry');
                        if (existingEntries.length === 0) {
                            addEditInfoEntry();
                        }
                    }
                }, 100);
            }
            
            if (transferredOutChecked) {
                const transferredOutDateField = document.getElementById('editTransferredOutDate');
                if (transferredOutDateField && !transferredOutDateField.value) {
                    transferredOutDateField.value = getTodaysDateEuropean();
                }
            }
            
            if (transferredInChecked) {
                const transferredInDateField = document.getElementById('editTransferredInDate');
                if (transferredInDateField && !transferredInDateField.value) {
                    transferredInDateField.value = getTodaysDateEuropean();
                }
            }
            
            if (proposedChecked) {
                const proposedDateField = document.getElementById('editProposedDate');
                if (proposedDateField && !proposedDateField.value) {
                    proposedDateField.value = getTodaysDateEuropean();
                }
            }
        }

        function toggleEditTimelineChanges() {
            const timelineChecked = document.getElementById('editTimelineChanges').checked;

            const section = document.getElementById('editTimelineChangesSection');
            
            if (timelineChecked) {
                section.style.display = 'block';
                
                // Automatically add one timeline change if none exist
                const existingChanges = document.querySelectorAll('#editChangesContainer > div[id^="edit-change-"]');
                if (existingChanges.length === 0) {
                    addEditChange();
                }
                
                // Reinitialize date pickers for any existing timeline changes
                setTimeout(() => {
                    document.querySelectorAll('#editChangesContainer input[id*="-date"], #editChangesContainer input[id*="-prev"], #editChangesContainer input[id*="-new"]').forEach(input => {
                        input.dataset.datePickerInitialized = 'false';
                        if (input.id) {
                            initializedDatePickers.delete(input.id);
                        }
                        initializeDatePicker(input, false);
                    });
                }, 10);
            } else {
                section.style.display = 'none';
                // Clear existing changes when hiding
                document.getElementById('editChangesContainer').innerHTML = '';
                editChangeCounter = 0;
                // Update button state after clearing changes
                updateEditChangeButton();
            }
        }

        let editChangeCounter = 0;



        function initializeEditKTLOMonths() {
            // Initialize the modal month selector to January and load its data
            const selector = document.getElementById('edit-ktlo-month-selector');
            if (selector) {
                selector.value = 'jan';
                selector.setAttribute('data-previous-month', 'jan');
                loadEditKTLOMonth('jan');
            }
        }
        
        function switchEditKTLOMonth() {
            // Save current month's data before switching
            const modalSelector = document.getElementById('edit-ktlo-month-selector');
            if (modalSelector) {
                // Get the OLD month value (before the dropdown changes)
                const oldMonth = modalSelector.getAttribute('data-previous-month') || modalSelector.value;
                const modalNumberEl = document.getElementById('edit-ktlo-current-number');
                const modalPercentageEl = document.getElementById('edit-ktlo-current-percentage');
                const modalDescriptionEl = document.getElementById('edit-ktlo-current-description');
                
                // Save current modal data to main data store
                ktloMonthlyData[oldMonth] = {
                    number: modalNumberEl ? modalNumberEl.value : '',
                    percentage: modalPercentageEl ? modalPercentageEl.value : '',
                    description: modalDescriptionEl ? modalDescriptionEl.value : ''
                };
                
                // Store the new month as the "previous" for next time
                modalSelector.setAttribute('data-previous-month', modalSelector.value);
            }
            
            const selector = document.getElementById('edit-ktlo-month-selector');
            const selectedMonth = selector.value;
            loadEditKTLOMonth(selectedMonth);
        }
        
        function loadEditKTLOMonth(month) {
            const data = ktloMonthlyData[month];
            const numberInput = document.getElementById('edit-ktlo-current-number');
            const percentageInput = document.getElementById('edit-ktlo-current-percentage');
            const descriptionInput = document.getElementById('edit-ktlo-current-description');
            
            if (numberInput) numberInput.value = data.number;
            if (percentageInput) percentageInput.value = data.percentage;
            if (descriptionInput) descriptionInput.value = data.description;
        }

        function addEditChange() {
            const container = document.getElementById('editChangesContainer');
            
            // Check if we've reached the maximum of 5 changes (allowing for 4th delay)
            const existingChanges = container.querySelectorAll('div[id^="edit-change-"]');
            if (existingChanges.length >= 5) {
                return; // Don't add more changes if limit is reached
            }
            
            // Get current story end date for auto-population from edit modal
            const currentEndDateElement = document.getElementById('editEnd');
            const currentEndDate = currentEndDateElement ? currentEndDateElement.value : '';
            
            editChangeCounter++;
            const changeId = `edit-change-${editChangeCounter}`;
            
            // Count existing changes to get the next number
            const entryNumber = existingChanges.length + 1;

            
            const changeHtml = `
                <div class="form-group" id="${changeId}" style="border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 4px; background-color: #f8f9fa;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong>Timeline #${entryNumber}</strong>
                        <button type="button" class="danger" onclick="removeEditChange('${changeId}')" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;" tabindex="-1">Remove</button>
                    </div>
                    
                    <div class="inline-group">
                        <div class="form-group">
                            <label>Change Date:</label>
                            <input type="text" id="${changeId}-date" placeholder="15/12/24" value="${getTodaysDateEuropean()}">
                        </div>
                        <div class="form-group">
                            <label>Description:</label>
                            <input type="text" id="${changeId}-desc" placeholder="Reason for change">
                        </div>
                    </div>
                    
                    <div class="inline-group">
                        <div class="form-group">
                            <label>Previous End Date:</label>
                            <input type="text" id="${changeId}-prev" placeholder="31/03" style="margin-bottom: 1px;" value="${currentEndDate}">
                        </div>
                        <div class="form-group">
                            <label>New End Date:</label>
                            <input type="text" id="${changeId}-new" placeholder="15/04" style="margin-bottom: 1px;" value="${currentEndDate}">
                        </div>
                    </div>
                </div>
            `;
            
            container.insertAdjacentHTML('beforeend', changeHtml);
            
            // Initialize date pickers for the new timeline change fields in modal
            setTimeout(() => {
                const dateField = document.getElementById(`${changeId}-date`);
                const prevField = document.getElementById(`${changeId}-prev`);
                const newField = document.getElementById(`${changeId}-new`);
                
                // Clear any existing initialization flags first
                [dateField, prevField, newField].forEach(field => {
                    if (field) {
                        field.dataset.datePickerInitialized = 'false';
                        if (field.id) {
                            initializedDatePickers.delete(field.id);
                        }
                    }
                });
                
                if (dateField) initializeDatePicker(dateField, false);
                if (prevField) initializeDatePicker(prevField, false);
                if (newField) initializeDatePicker(newField, false);
            }, 10);
            
            // Update the Add Change button state
            updateEditChangeButton();
        }

                function removeEditChange(changeId) {
            document.getElementById(changeId).remove();
            
            // Update the Add Change button state
            updateEditChangeButton();
        }
        


        // Utility function to sort timeline changes by date
        function sortTimelineChangesByDate(timelineChanges) {
            return timelineChanges.sort((a, b) => {
                if (!a.date && !b.date) return 0;
                if (!a.date) return 1; // Empty dates go to end
                if (!b.date) return -1;
                
                const dateA = DateUtility.parseEuropeanDateForTimeline(a.date);
                const dateB = DateUtility.parseEuropeanDateForTimeline(b.date);
                return dateA - dateB;
            });
        }

        function updateEditChangeButton() {
            const container = document.getElementById('editChangesContainer');
            const addButton = document.getElementById('add-edit-change-btn');
            
            if (!container || !addButton) return;
            
            const existingChanges = container.querySelectorAll('div[id^="edit-change-"]');
            
            if (existingChanges.length >= 5) {
                addButton.disabled = true;
                addButton.textContent = '+ Add Timeline Entry (Max 5 reached)';
                addButton.style.opacity = '0.5';
                addButton.style.cursor = 'not-allowed';
            } else {
                addButton.disabled = false;
                addButton.textContent = '+ Add Timeline Entry';
                addButton.style.opacity = '1';
                addButton.style.cursor = 'pointer';
            }
        }
        
        // Monthly KTLO Edit Modal Functions
        let currentEditingMonth = null;
        
        function openEditMonthlyKTLOModal(month) {
            currentEditingMonth = month;
            
            // Update modal title
            const monthName = month.charAt(0).toUpperCase() + month.slice(1);
            document.getElementById('editMonthlyKTLOTitle').textContent = `Edit ${monthName} KTLO`;
            
            // Set month dropdown
            document.getElementById('editMonthlyKTLOMonth').value = month;
            
            // Load current data for this month
            const monthData = ktloMonthlyData[month];
            document.getElementById('editMonthlyKTLONumber').value = monthData.number || '';
            document.getElementById('editMonthlyKTLOPercentage').value = monthData.percentage || '';
            document.getElementById('editMonthlyKTLODescription').value = monthData.description || '';
            
            // Show modal
            document.getElementById('editMonthlyKTLOModal').style.display = 'flex';
            
            // Set up focus trap
            modalFocusTrap = setupModalFocusTrap('editMonthlyKTLOModal');
            
            // Add Enter key listener for Save Changes
            const editMonthlyKTLOModal = document.getElementById('editMonthlyKTLOModal');
            const handleEnterKey = (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    // Check if user is currently typing in an editable element
                    const activeElement = document.activeElement;
                    const isEditable = activeElement && (
                        activeElement.tagName === 'INPUT' ||
                        activeElement.tagName === 'TEXTAREA' ||
                        activeElement.contentEditable === 'true'
                    );
                    
                    // Don't trigger save when user is typing in a form field
                    if (isEditable) {
                        return;
                    }
                    
                    event.preventDefault();
                    saveMonthlyKTLOChanges();
                }
            };
            editMonthlyKTLOModal.addEventListener('keydown', handleEnterKey);
            
            // Store the handler so we can remove it later
            editMonthlyKTLOModal._enterKeyHandler = handleEnterKey;
        }
        
        function closeEditMonthlyKTLOModal() {
            try {
                const modal = document.getElementById('editMonthlyKTLOModal');
                if (modal) {
                    modal.style.display = 'none';
                    
                    // Remove Enter key listener
                    if (modal._enterKeyHandler) {
                        modal.removeEventListener('keydown', modal._enterKeyHandler);
                        delete modal._enterKeyHandler;
                    }
                }
                currentEditingMonth = null;
                
                // Remove focus trap
                removeModalFocusTrap();
            } catch (error) {
                console.error('Error closing monthly KTLO modal:', error);
                // Force close by removing the modal from view
                const modal = document.getElementById('editMonthlyKTLOModal');
                if (modal) {
                    modal.style.display = 'none';
                }
                
                // Remove focus trap
                removeModalFocusTrap();
            }
        }
        
        function saveMonthlyKTLOChanges() {
            if (!currentEditingMonth) return;
            
            // Get values from modal
            const number = document.getElementById('editMonthlyKTLONumber').value;
            let percentage = document.getElementById('editMonthlyKTLOPercentage').value;
            const description = document.getElementById('editMonthlyKTLODescription').value;
            
            // Validate percentage directly - don't save if invalid
            if (percentage !== '' && !validateKTLOPercentage(percentage)) {
                return; // Prevent saving when percentage is invalid
            }
            
            // Save to main data store
            ktloMonthlyData[currentEditingMonth] = {
                number: number,
                percentage: percentage,
                description: description
            };
            
            // Update the main form if currently viewing this month
            const mainSelector = document.getElementById('ktlo-month-selector');
            if (mainSelector && mainSelector.value === currentEditingMonth) {
                document.getElementById('ktlo-current-number').value = number;
                document.getElementById('ktlo-current-percentage').value = percentage;
                document.getElementById('ktlo-current-description').value = description;
            }
            
            // Update the modal form if currently editing this month
            const modalSelector = document.getElementById('edit-ktlo-month-selector');
            if (modalSelector && modalSelector.value === currentEditingMonth) {
                document.getElementById('edit-ktlo-current-number').value = number;
                document.getElementById('edit-ktlo-current-percentage').value = percentage;
                document.getElementById('edit-ktlo-current-description').value = description;
            }
            
            // Close modal
            closeEditMonthlyKTLOModal();
            
            // Regenerate preview to show changes
            generatePreview();
        }

        function findStoryInForm(epicName, storyTitle, storyIndex) {
            try {
                // Special handling for KTLO
                if (epicName === 'KTLO') {
                    const titleEl = document.getElementById('ktlo-title');
                    const bulletsEl = document.getElementById('ktlo-bullets');
                    const positionEl = document.getElementById('ktlo-position-toggle');
                    
                    return {
                        storyId: 'ktlo', // Special ID for KTLO
                        title: titleEl ? titleEl.value : '',
                        start: 'JAN', // KTLO spans full year
                        end: 'DEC',
                        bullets: bulletsEl ? bulletsEl.value : '',
                        position: positionEl ? positionEl.checked : false, // true = top, false = bottom
                        isDone: false, // KTLO doesn't have status flags
                        isCancelled: false,
                        isAtRisk: false,
                        isNewStory: false,
                        isTransferredOut: false,
                        isProposed: false,
                        doneDate: '',
                        doneNotes: '',
                        cancelDate: '',
                        cancelNotes: '',
                        atRiskDate: '',
                        atRiskNotes: '',
                        newStoryDate: '',
                        newStoryNotes: '',
                        transferredOutDate: '',
                        transferredOutNotes: '',
                        proposedDate: '',
                        proposedNotes: '',
                        hasTimelineChanges: false,
                        timelineChanges: []
                    };
                }

                // Special handling for BTL (Below the Line) stories
                if (epicName === 'Below the Line') {
                    const btlStoryElements = document.querySelectorAll('#btl-stories-container .story-section');
                    const targetStoryIndex = parseInt(storyIndex);
                    
                    if (targetStoryIndex >= 0 && targetStoryIndex < btlStoryElements.length) {
                        const storyEl = btlStoryElements[targetStoryIndex];
                        const storyId = storyEl.id.replace('story-', '');
                        
                        // Extract BTL story data
                        const titleEl = document.getElementById(`btl-title-${storyId}`);
                        const startEl = document.getElementById(`btl-start-${storyId}`);
                        const endEl = document.getElementById(`btl-end-${storyId}`);
                        const bulletsEl = document.getElementById(`btl-bullets-${storyId}`);
                        const dateAddedEl = document.getElementById(`btl-dateadded-${storyId}`);
                        const descriptionEl = document.getElementById(`btl-description-${storyId}`);
                        const imoEl = document.getElementById(`btl-imo-${storyId}`);
                        
                        return {
                            storyId: storyId,
                            title: titleEl ? titleEl.value : '',
                            start: startEl ? startEl.value : '',
                            end: endEl ? endEl.value : '',
                            bullets: bulletsEl ? bulletsEl.value : '',
                            dateAdded: dateAddedEl ? dateAddedEl.value : '',
                            dateAddedDescription: descriptionEl ? descriptionEl.value : '',
                            imo: imoEl ? imoEl.value : '',
                            isDone: false, // BTL stories don't have status flags
                            isCancelled: false,
                            isAtRisk: false,
                            isNewStory: false,
                            isTransferredOut: false,
                            isTransferredIn: false,
                            isProposed: false,
                            doneDate: '',
                            doneNotes: '',
                            cancelDate: '',
                            cancelNotes: '',
                            atRiskDate: '',
                            atRiskNotes: '',
                            newStoryDate: '',
                            newStoryNotes: '',
                            transferredOutDate: '',
                            transferredOutNotes: '',
                            transferredInDate: '',
                            transferredInNotes: '',
                            proposedDate: '',
                            proposedNotes: '',
                            hasTimelineChanges: false,
                            timelineChanges: []
                        };
                    }
                    
                    return null;
                }

                
                // Find the EPIC by name
                const epicElements = document.querySelectorAll('.epic-section');

                let targetEpic = null;
                
                for (let epicEl of epicElements) {
                    const epicId = epicEl.id.split('-')[1];
                    const epicNameEl = document.getElementById(`epic-name-${epicId}`);
                    if (epicNameEl && epicNameEl.value.trim() === epicName.trim()) {
                        targetEpic = epicEl;
                        break;
                    }
                }
                
                if (!targetEpic) {
                    return null;
                }
                
                // Find the story within the EPIC
                const storyElements = targetEpic.querySelectorAll('.story-section');
                const targetStoryIndex = parseInt(storyIndex);
                if (targetStoryIndex >= 0 && targetStoryIndex < storyElements.length) {
                    const storyEl = storyElements[targetStoryIndex];
                    const storyId = storyEl.id.replace('story-', '');
                    
                    // Extract story data
                    const titleEl = document.getElementById(`story-title-${storyId}`);
                    const startEl = document.getElementById(`story-start-${storyId}`);
                    const endEl = document.getElementById(`story-end-${storyId}`);
                    const bulletsEl = document.getElementById(`story-bullets-${storyId}`);
                    const imoEl = document.getElementById(`story-imo-${storyId}`);
                    
                    const doneEl = document.getElementById(`story-done-${storyId}`);
                    const cancelledEl = document.getElementById(`story-cancelled-${storyId}`);
                    const atRiskEl = document.getElementById(`story-atrisk-${storyId}`);
                    const newStoryEl = document.getElementById(`story-newstory-${storyId}`);
                    const infoEl = document.getElementById(`story-info-${storyId}`);
                    const transferredOutEl = document.getElementById(`story-transferredout-${storyId}`);
                    const transferredInEl = document.getElementById(`story-transferredin-${storyId}`);
                    const proposedEl = document.getElementById(`story-proposed-${storyId}`);
                    
                    const doneDateEl = document.getElementById(`done-date-${storyId}`);
                    const doneNotesEl = document.getElementById(`done-notes-${storyId}`);
                    const cancelDateEl = document.getElementById(`cancel-date-${storyId}`);
                    const cancelNotesEl = document.getElementById(`cancel-notes-${storyId}`);
                    const atRiskDateEl = document.getElementById(`atrisk-date-${storyId}`);
                    const atRiskNotesEl = document.getElementById(`atrisk-notes-${storyId}`);
                    const newStoryDateEl = document.getElementById(`newstory-date-${storyId}`);
                    const newStoryNotesEl = document.getElementById(`newstory-notes-${storyId}`);
                    const infoDateEl = document.getElementById(`info-date-${storyId}`);
                    const infoNotesEl = document.getElementById(`info-notes-${storyId}`);
                    const transferredOutDateEl = document.getElementById(`transferredout-date-${storyId}`);
                    const transferredOutNotesEl = document.getElementById(`transferredout-notes-${storyId}`);
                    const transferredInDateEl = document.getElementById(`transferredin-date-${storyId}`);
                    const transferredInNotesEl = document.getElementById(`transferredin-notes-${storyId}`);
                    const proposedDateEl = document.getElementById(`proposed-date-${storyId}`);
                    const proposedNotesEl = document.getElementById(`proposed-notes-${storyId}`);
                    
                    // Get timeline changes - check both checkbox state AND actual DOM elements
                    const timelineChangesEl = document.getElementById(`story-changes-${storyId}`);
                    const checkboxChecked = timelineChangesEl ? timelineChangesEl.checked : false;
                    
                    // Always check for existing timeline change elements
                    const changeContainers = document.querySelectorAll(`#changes-container-${storyId} > div[id^="change-${storyId}-change-"]`);
                    let timelineChanges = [];
                    
                    changeContainers.forEach(changeEl => {
                        const changeId = changeEl.id.replace('change-', '');
                        const dateEl = document.getElementById(`change-date-${changeId}`);
                        const prevEl = document.getElementById(`change-prev-${changeId}`);
                        const newEl = document.getElementById(`change-new-${changeId}`);
                        const descEl = document.getElementById(`change-desc-${changeId}`);
                        
                        if (dateEl && prevEl && newEl) {
                            timelineChanges.push({
                                date: dateEl.value || '',
                                prevEndDate: prevEl.value || '',
                                newEndDate: newEl.value || '',
                                description: descEl ? descEl.value || '' : ''
                            });
                        }
                    });
                    
                    // Sort timeline changes by date (chronological order)
                    sortTimelineChangesByDate(timelineChanges);
                    
                    // hasTimelineChanges should be true if either checkbox is checked OR timeline changes exist
                    const hasTimelineChanges = checkboxChecked || timelineChanges.length > 0;
                    
                    return {
                        storyId: storyId,
                        title: titleEl ? titleEl.value : '',
                        start: startEl ? startEl.value : '',
                        end: endEl ? endEl.value : '',
                        bullets: bulletsEl ? bulletsEl.value : '',
                        imo: imoEl ? imoEl.value : '',
                        isDone: doneEl ? doneEl.checked : false,
                        isCancelled: cancelledEl ? cancelledEl.checked : false,
                        isAtRisk: atRiskEl ? atRiskEl.checked : false,
                        isNewStory: newStoryEl ? newStoryEl.checked : false,
                        isInfo: infoEl ? infoEl.checked : false,
                        isTransferredOut: transferredOutEl ? transferredOutEl.checked : false,
                        isTransferredIn: transferredInEl ? transferredInEl.checked : false,
                        isProposed: proposedEl ? proposedEl.checked : false,
                        doneDate: doneDateEl ? doneDateEl.value : '',
                        doneNotes: doneNotesEl ? doneNotesEl.value : '',
                        cancelDate: cancelDateEl ? cancelDateEl.value : '',
                        cancelNotes: cancelNotesEl ? cancelNotesEl.value : '',
                        atRiskDate: atRiskDateEl ? atRiskDateEl.value : '',
                        atRiskNotes: atRiskNotesEl ? atRiskNotesEl.value : '',
                        newStoryDate: newStoryDateEl ? newStoryDateEl.value : '',
                        newStoryNotes: newStoryNotesEl ? newStoryNotesEl.value : '',
                        infoDate: infoDateEl ? infoDateEl.value : '',
                        infoNotes: infoNotesEl ? infoNotesEl.value : '',
                        transferredOutDate: transferredOutDateEl ? transferredOutDateEl.value : '',
                        transferredOutNotes: transferredOutNotesEl ? transferredOutNotesEl.value : '',
                        transferredInDate: transferredInDateEl ? transferredInDateEl.value : '',
                        transferredInNotes: transferredInNotesEl ? transferredInNotesEl.value : '',
                        proposedDate: proposedDateEl ? proposedDateEl.value : '',
                        proposedNotes: proposedNotesEl ? proposedNotesEl.value : '',
                        hasTimelineChanges: hasTimelineChanges,
                        timelineChanges: timelineChanges
                    };
                }
                

                return null;
                
            } catch (error) {
                return null;
            }
        }

        function saveStoryChanges() {
            if (!currentEditingStory) {
                alert('No story selected for editing.');
                return;
            }
            
            try {
                // Find the story in the form
                const foundStory = findStoryInForm(currentEditingStory.epicName, currentEditingStory.storyTitle, currentEditingStory.storyIndex);
                if (!foundStory) {
                    alert('Could not find story in form to update.');
                    return;
                }
                
                const storyId = foundStory.storyId;
                
                // Special handling for KTLO
                if (currentEditingStory.epicName === 'KTLO') {
                    // Update KTLO form fields
                    const titleEl = document.getElementById('ktlo-title');
                    const bulletsEl = document.getElementById('ktlo-bullets');
                    const positionEl = document.getElementById('ktlo-position-toggle');
                    
                    if (titleEl) titleEl.value = document.getElementById('editTitle').value;
                    if (bulletsEl) bulletsEl.value = document.getElementById('editBullets').value;
                    
                    // Update KTLO position if it changed
                    const newPosition = document.getElementById('editKTLOPosition').checked;
                    if (positionEl && positionEl.checked !== newPosition) {
                        positionEl.checked = newPosition;
                        
                        // Trigger the repositioning logic
                        repositionKTLOSection();
                    }
                    
                    // Update KTLO monthly data from modal back to main data store
                    // First, save the currently displayed month in the modal
                    const modalSelector = document.getElementById('edit-ktlo-month-selector');
                    if (modalSelector) {
                        const currentModalMonth = modalSelector.value;
                        const modalNumberEl = document.getElementById('edit-ktlo-current-number');
                        const modalPercentageEl = document.getElementById('edit-ktlo-current-percentage');
                        const modalDescriptionEl = document.getElementById('edit-ktlo-current-description');
                        
                        if (modalNumberEl || modalPercentageEl || modalDescriptionEl) {
                            ktloMonthlyData[currentModalMonth] = {
                                number: modalNumberEl ? modalNumberEl.value : '',
                                percentage: modalPercentageEl ? modalPercentageEl.value : '',
                                description: modalDescriptionEl ? modalDescriptionEl.value : ''
                            };
                        }
                    }
                    
                    // Refresh the main form to show the updated values
                    const mainSelector = document.getElementById('ktlo-month-selector');
                    if (mainSelector) {
                        loadKTLOMonth(mainSelector.value);
                    }
                    
                    // Close modal and regenerate preview
                    closeEditModal();
                    
                    setTimeout(() => {
                        generatePreview();
                    }, 100);
                    return;
                }
                
                // Special handling for BTL stories
                if (currentEditingStory.epicName === 'Below the Line') {
                    // Update BTL form fields
                    const titleEl = document.getElementById(`btl-title-${storyId}`);
                    const startEl = document.getElementById(`btl-start-${storyId}`);
                    const endEl = document.getElementById(`btl-end-${storyId}`);
                    const bulletsEl = document.getElementById(`btl-bullets-${storyId}`);
                    const dateAddedEl = document.getElementById(`btl-dateadded-${storyId}`);
                    const descriptionEl = document.getElementById(`btl-description-${storyId}`);
                    const imoEl = document.getElementById(`btl-imo-${storyId}`);
                    
                    if (titleEl) titleEl.value = document.getElementById('editTitle').value;
                    if (startEl) startEl.value = document.getElementById('editStart').value;
                    if (endEl) endEl.value = document.getElementById('editEnd').value;
                    if (bulletsEl) bulletsEl.value = document.getElementById('editBullets').value;
                    if (dateAddedEl) dateAddedEl.value = document.getElementById('editBTLDateAdded').value;
                    if (descriptionEl) descriptionEl.value = document.getElementById('editBTLDescription').value;
                    if (imoEl) imoEl.value = document.getElementById('editIMO').value;
                    
                    // Close modal and regenerate preview
                    closeEditModal();
                    
                    setTimeout(() => {
                        generatePreview();
                    }, 100);
                    return;
                }
                
                // Update form fields with modal values (for regular stories)
                const titleEl = document.getElementById(`story-title-${storyId}`);
                const startEl = document.getElementById(`story-start-${storyId}`);
                const endEl = document.getElementById(`story-end-${storyId}`);
                const bulletsEl = document.getElementById(`story-bullets-${storyId}`);
                const imoEl = document.getElementById(`story-imo-${storyId}`);
                
                if (titleEl) titleEl.value = document.getElementById('editTitle').value;
                if (startEl) startEl.value = document.getElementById('editStart').value;
                if (endEl) endEl.value = document.getElementById('editEnd').value;
                if (bulletsEl) bulletsEl.value = document.getElementById('editBullets').value;
                if (imoEl) imoEl.value = document.getElementById('editIMO').value;
                
                // Update checkboxes
                const doneEl = document.getElementById(`story-done-${storyId}`);
                const cancelledEl = document.getElementById(`story-cancelled-${storyId}`);
                const atRiskEl = document.getElementById(`story-atrisk-${storyId}`);
                const newStoryEl = document.getElementById(`story-newstory-${storyId}`);
                const infoEl = document.getElementById(`story-info-${storyId}`);
                const transferredOutEl = document.getElementById(`story-transferredout-${storyId}`);
                const transferredInEl = document.getElementById(`story-transferredin-${storyId}`);
                const proposedEl = document.getElementById(`story-proposed-${storyId}`);
                
                const doneChecked = document.getElementById('editDone').checked;
                const cancelledChecked = document.getElementById('editCancelled').checked;
                const atRiskChecked = document.getElementById('editAtRisk').checked;
                const newStoryChecked = document.getElementById('editNewStory').checked;
                const infoChecked = document.getElementById('editInfo').checked;
                const transferredOutChecked = document.getElementById('editTransferredOut').checked;
                const transferredInChecked = document.getElementById('editTransferredIn').checked;
                const proposedChecked = document.getElementById('editProposed').checked;
                const timelineChangesChecked = document.getElementById('editTimelineChanges').checked;
                
                if (doneEl) {
                    doneEl.checked = doneChecked;
                    handleDoneChange(storyId); // Show/hide done section
                }
                if (cancelledEl) {
                    cancelledEl.checked = cancelledChecked;
                    handleCancelledChange(storyId); // Show/hide cancelled section
                }
                if (atRiskEl) {
                    atRiskEl.checked = atRiskChecked;
                    handleAtRiskChange(storyId); // Show/hide at risk section
                }
                if (newStoryEl) {
                    newStoryEl.checked = newStoryChecked;
                    handleNewStoryChange(storyId); // Show/hide new story section
                }
                if (infoEl) {
                    infoEl.checked = infoChecked;
                    handleInfoChange(storyId); // Show/hide info section
                }
                if (transferredOutEl) {
                    transferredOutEl.checked = transferredOutChecked;
                    handleTransferredOutChange(storyId); // Show/hide transferred out section
                }
                if (transferredInEl) {
                    transferredInEl.checked = transferredInChecked;
                    handleTransferredInChange(storyId); // Show/hide transferred in section
                }
                if (proposedEl) {
                    proposedEl.checked = proposedChecked;
                    handleProposedChange(storyId); // Show/hide proposed section
                }
                
                // Update timeline changes checkbox
                const timelineChangesEl = document.getElementById(`story-changes-${storyId}`);
                if (timelineChangesEl) {
                    timelineChangesEl.checked = timelineChangesChecked;
                    toggleChanges(storyId); // Show/hide timeline changes section
                }
                
                // Update status information
                setTimeout(() => {
                    const doneDateEl = document.getElementById(`done-date-${storyId}`);
                    const doneNotesEl = document.getElementById(`done-notes-${storyId}`);
                    const cancelDateEl = document.getElementById(`cancel-date-${storyId}`);
                    const cancelNotesEl = document.getElementById(`cancel-notes-${storyId}`);
                    const atRiskDateEl = document.getElementById(`atrisk-date-${storyId}`);
                    const atRiskNotesEl = document.getElementById(`atrisk-notes-${storyId}`);
                    const newStoryDateEl = document.getElementById(`newstory-date-${storyId}`);
                    const newStoryNotesEl = document.getElementById(`newstory-notes-${storyId}`);
                    const infoDateEl = document.getElementById(`info-date-${storyId}`);
                    const infoNotesEl = document.getElementById(`info-notes-${storyId}`);
                    const transferredOutDateEl = document.getElementById(`transferredout-date-${storyId}`);
                    const transferredOutNotesEl = document.getElementById(`transferredout-notes-${storyId}`);
                    const transferredInDateEl = document.getElementById(`transferredin-date-${storyId}`);
                    const transferredInNotesEl = document.getElementById(`transferredin-notes-${storyId}`);
                    const proposedDateEl = document.getElementById(`proposed-date-${storyId}`);
                    const proposedNotesEl = document.getElementById(`proposed-notes-${storyId}`);
                    
                    if (doneDateEl) doneDateEl.value = document.getElementById('editDoneDate').value;
                    if (doneNotesEl) doneNotesEl.value = document.getElementById('editDoneNotes').value;
                    if (cancelDateEl) cancelDateEl.value = document.getElementById('editCancelDate').value;
                    if (cancelNotesEl) cancelNotesEl.value = document.getElementById('editCancelNotes').value;
                    if (atRiskDateEl) atRiskDateEl.value = document.getElementById('editAtRiskDate').value;
                    if (atRiskNotesEl) atRiskNotesEl.value = document.getElementById('editAtRiskNotes').value;
                    if (newStoryDateEl) newStoryDateEl.value = document.getElementById('editNewStoryDate').value;
                    if (newStoryNotesEl) newStoryNotesEl.value = document.getElementById('editNewStoryNotes').value;
                    // Handle multiple info entries
                    const infoEntriesContainer = document.getElementById(`info-entries-${storyId}`);
                    if (infoEntriesContainer) {
                        // Clear existing entries
                        infoEntriesContainer.innerHTML = '';
                        
                        // Collect info entries from modal
                        const editInfoEntries = document.querySelectorAll('#editInfoEntries > div[id^="edit-info-entry-"]');
                        editInfoEntries.forEach((editEntryEl, index) => {
                            const entryId = editEntryEl.id;
                            const dateEl = document.getElementById(`edit-info-date-${entryId}`);
                            const notesEl = document.getElementById(`edit-info-notes-${entryId}`);
                            
                            if (dateEl && notesEl && (dateEl.value || notesEl.value)) {
                                // Create new entry in the main form
                                const newEntryId = `info-entry-${storyId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                const entryNumber = index + 1;
                                const entryHtml = `
                                    <div id="${newEntryId}" class="info-entry" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                            <strong>Info Entry #${entryNumber}</strong>
                                            <button type="button" onclick="removeInfoEntry('${newEntryId}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 12px;">Remove</button>
                                        </div>
                                        <div class="inline-group">
                                            <div class="form-group">
                                                <label for="info-date-${newEntryId}">Info Date:</label>
                                                <input type="text" id="info-date-${newEntryId}" placeholder="15/01 or 15/01/25 or 15-01-2025" value="${dateEl.value}">
                                            </div>
                                            <div class="form-group">
                                                <label for="info-notes-${newEntryId}">Information Details:</label>
                                                <textarea id="info-notes-${newEntryId}" placeholder="Additional information about this story (multiple lines supported)" rows="3" style="height: 60px;">${notesEl.value}</textarea>
                                            </div>
                                        </div>
                                    </div>
                                `;
                                infoEntriesContainer.insertAdjacentHTML('beforeend', entryHtml);
                                
                                // Add auto-update listeners
                                const dateInput = document.getElementById(`info-date-${newEntryId}`);
                                const notesInput = document.getElementById(`info-notes-${newEntryId}`);
                                if (dateInput) dateInput.addEventListener('input', () => generatePreview());
                                if (notesInput) notesInput.addEventListener('input', () => generatePreview());
                            }
                        });
                    }
                    if (transferredOutDateEl) transferredOutDateEl.value = document.getElementById('editTransferredOutDate').value;
                    if (transferredOutNotesEl) transferredOutNotesEl.value = document.getElementById('editTransferredOutNotes').value;
                    if (transferredInDateEl) transferredInDateEl.value = document.getElementById('editTransferredInDate').value;
                    if (transferredInNotesEl) transferredInNotesEl.value = document.getElementById('editTransferredInNotes').value;
                    if (proposedDateEl) proposedDateEl.value = document.getElementById('editProposedDate').value;
                    if (proposedNotesEl) proposedNotesEl.value = document.getElementById('editProposedNotes').value;
                    
                    // Handle timeline changes
                    if (timelineChangesChecked) {
                        // Clear existing timeline changes first
                        const existingChanges = document.querySelectorAll(`#changes-container-${storyId} > div[id^="change-${storyId}-change-"]`);
                        existingChanges.forEach(changeEl => changeEl.remove());
                        
                        // Collect timeline changes from modal and sort by date
                        const editChanges = document.querySelectorAll('#editChangesContainer > div[id^="edit-change-"]');
                        const modalTimelineChanges = [];
                        
                        editChanges.forEach((editChangeEl) => {
                            const editChangeId = editChangeEl.id;
                            const dateValue = document.getElementById(`${editChangeId}-date`).value;
                            const descValue = document.getElementById(`${editChangeId}-desc`).value;
                            const prevValue = document.getElementById(`${editChangeId}-prev`).value;
                            const newValue = document.getElementById(`${editChangeId}-new`).value;
                            
                            if (dateValue || descValue || prevValue || newValue) {
                                modalTimelineChanges.push({
                                    date: dateValue,
                                    description: descValue,
                                    prevEndDate: prevValue,
                                    newEndDate: newValue
                                });
                            }
                        });
                        
                        // Sort timeline changes by date
                        sortTimelineChangesByDate(modalTimelineChanges);
                        
                        // Add sorted timeline changes to the main form
                        modalTimelineChanges.forEach((change) => {
                            addChange(storyId);
                            
                            // IMMEDIATE population without setTimeout to avoid race conditions
                            const changeContainers = document.querySelectorAll(`#changes-container-${storyId} > div[id^="change-${storyId}-change-"]`);
                            const latestContainer = changeContainers[changeContainers.length - 1];
                            if (latestContainer) {
                                const fullChangeId = latestContainer.id.replace('change-', '');
                                const dateEl = document.getElementById(`change-date-${fullChangeId}`);
                                const descEl = document.getElementById(`change-desc-${fullChangeId}`);
                                const prevEl = document.getElementById(`change-prev-${fullChangeId}`);
                                const newEl = document.getElementById(`change-new-${fullChangeId}`);
                                
                                if (dateEl) dateEl.value = change.date;
                                if (descEl) descEl.value = change.description;
                                if (prevEl) prevEl.value = change.prevEndDate;
                                if (newEl) newEl.value = change.newEndDate;
                            }
                        });
                        
                        // Update story's actual end date to reflect the most recent timeline change from modal
                        if (modalTimelineChanges.length > 0) {
                            // Get the newEndDate from the most recent change (modalTimelineChanges is already sorted)
                            const mostRecentChange = modalTimelineChanges[modalTimelineChanges.length - 1];
                            if (mostRecentChange && mostRecentChange.newEndDate) {
                                const newEndDate = mostRecentChange.newEndDate;
                                
                                // Update the main form's end date field
                                const endEl = document.getElementById(`story-end-${storyId}`);
                                if (endEl) {
                                    endEl.value = newEndDate;
                                }
                                
                                // Also update the edit modal's end date field for consistency
                                const editEndEl = document.getElementById('editEnd');
                                if (editEndEl) {
                                    editEndEl.value = newEndDate;
                                }
                            }
                        }
                    } else {
                        // Clear all existing timeline changes if unchecked
                        const existingChanges = document.querySelectorAll(`#changes-container-${storyId} > div[id^="change-${storyId}-change-"]`);
                        existingChanges.forEach(changeEl => changeEl.remove());
                    }
                    
                    // Update button state after loading/clearing changes
                    updateChangeButton(storyId);
                    
                    // Close modal
                    closeEditModal();
                    
                    // Regenerate preview to show changes - add a longer delay to ensure all DOM updates are complete
                    setTimeout(() => {
                        generatePreview();
                    }, 200);
                }, 100);
                
            } catch (error) {
                alert('Error saving changes: ' + error.message);
            }
        }

        // Move story functions for modal
        function moveCurrentStoryUp() {
            if (!currentEditingStory) {
                alert('No story selected for editing.');
                return;
            }
            
            // Use the existing function with epic name and story index
            moveStoryUpByEpic(currentEditingStory.epicName, currentEditingStory.storyIndex);
            
            // Update the currentEditingStory index since the story moved up
            if (currentEditingStory.storyIndex > 0) {
                currentEditingStory.storyIndex--;
            }
        }
        
        function moveCurrentStoryDown() {
            if (!currentEditingStory) {
                alert('No story selected for editing.');
                return;
            }
            
            // Find the EPIC to check if this is the last story
            const epicElements = document.querySelectorAll('.epic-section');
            let targetEpicElement = null;
            
            epicElements.forEach(epicEl => {
                const epicId = epicEl.id.split('-')[1];
                const epicNameEl = document.getElementById(`epic-name-${epicId}`);
                if (epicNameEl && epicNameEl.value.trim() === currentEditingStory.epicName) {
                    targetEpicElement = epicEl;
                }
            });
            
            if (targetEpicElement) {
                const storyElements = targetEpicElement.querySelectorAll('.story-section');
                // Only move if not the last story
                if (currentEditingStory.storyIndex < storyElements.length - 1) {
                    moveStoryDownByEpic(currentEditingStory.epicName, currentEditingStory.storyIndex);
                    currentEditingStory.storyIndex++;
                }
            }
        }

        function deleteCurrentStory() {
            if (!currentEditingStory) {
                alert('No story selected for editing.');
                return;
            }
            
            // Handle BTL (Below the Line) stories differently
            if (currentEditingStory.epicName === 'Below the Line') {
                // BTL stories are stored in btl-stories-container
                const btlContainer = document.getElementById('btl-stories-container');
                const btlStories = btlContainer.querySelectorAll('.story-section');
                
                if (currentEditingStory.storyIndex >= 0 && currentEditingStory.storyIndex < btlStories.length) {
                    const storyToDelete = btlStories[currentEditingStory.storyIndex];
                    storyToDelete.remove();
                    
                    // Update BTL add button state
                    updateBTLAddButton();
                    
                    // Close the modal
                    closeEditModal();
                    
                    // Refresh the roadmap preview
                    generatePreview();
                } else {
                    alert('Could not find BTL story to delete');
                }
                return;
            }
            
            // Handle regular EPIC stories
            const epicElements = document.querySelectorAll('.epic-section');
            let targetEpicElement = null;
            
            epicElements.forEach(epicEl => {
                const epicId = epicEl.id.split('-')[1];
                const epicNameEl = document.getElementById(`epic-name-${epicId}`);
                if (epicNameEl && epicNameEl.value.trim() === currentEditingStory.epicName) {
                    targetEpicElement = epicEl;
                }
            });
            
            if (targetEpicElement) {
                const storyElements = targetEpicElement.querySelectorAll('.story-section');
                if (currentEditingStory.storyIndex >= 0 && currentEditingStory.storyIndex < storyElements.length) {
                    const storyToDelete = storyElements[currentEditingStory.storyIndex];
                    storyToDelete.remove();
                    
                    // Update story numbers in the EPIC
                    updateStoryNumbers(targetEpicElement);
                    
                    // Close the modal
                    closeEditModal();
                    
                    // Refresh the roadmap preview
                    generatePreview();
                } else {
                    alert('Could not find EPIC story to delete');
                }
            } else {
                alert('Could not find EPIC for story');
            }
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('editStoryModal');
            if (event.target === modal) {
                closeEditModal();
            }
            
            const monthlyKTLOModal = document.getElementById('editMonthlyKTLOModal');
            if (event.target === monthlyKTLOModal) {
                closeEditMonthlyKTLOModal();
            }
        });
        
        // Prevent form submission in modal to avoid page jumping
        document.addEventListener('DOMContentLoaded', function() {
            const modalForm = document.getElementById('editStoryForm');
            if (modalForm) {
                modalForm.addEventListener('submit', function(event) {
                    event.preventDefault();
                    return false;
                });
            }
        });

                // Enable hover for all monthly boxes including January/December
        function setupMonthlyBoxPriming(doc, windowContext) {
            // Override the embedded CSS to allow January/December hover
            const style = doc.createElement('style');
            style.textContent = `
                /* Fix KTLO story blocking monthly boxes - using higher specificity */
                body iframe .roadmap-container .ktlo-story {
                    pointer-events: none;
                }
                
                body iframe .roadmap-container .ktlo-story .task-title,
                body iframe .roadmap-container .ktlo-story .task-bullets,
                body iframe .roadmap-container .ktlo-story .edit-icon {
                    pointer-events: auto;
                }
                
                /* 
                 * CONSOLIDATED MONTHLY BOX HOVER EFFECTS 
                 * Using iframe-specific high specificity to avoid !important
                 * These rules apply within the iframe only
                 */
                body iframe .roadmap-container .monthly-boxes-container .monthly-box .monthly-box-content:hover {
                    z-index: 1000;
                    position: relative;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    transform: scale(1.3);
                }
                
                /* Specific month transforms with iframe specificity */
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-january .monthly-box-content:hover {
                    transform: translateX(-2px) scale(1.3);
                }
                
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-february .monthly-box-content:hover,
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-march .monthly-box-content:hover,
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-october .monthly-box-content:hover,
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-november .monthly-box-content:hover {
                    transform: scale(1.3);
                }
                
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-april .monthly-box-content:hover {
                    transform: translateX(2px) scale(1.3);
                }
                
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-may .monthly-box-content:hover,
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-june .monthly-box-content:hover {
                    transform: translateX(4px) scale(1.3);
                }
                
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-july .monthly-box-content:hover,
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-august .monthly-box-content:hover {
                    transform: translateX(6px) scale(1.3);
                }
                
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-september .monthly-box-content:hover {
                    transform: translateX(7px) scale(1.3);
                }
                
                body iframe .roadmap-container .monthly-boxes-container .monthly-box-december .monthly-box-content:hover {
                    transform: translateX(1px) scale(1.3);
                }
            `;
            doc.head.appendChild(style);
        }

        // KTLO Percentage Validation Functions
        function validateKTLOPercentage(value) {
            // Empty/blank values are allowed
            if (value === '' || value === null || value === undefined) {
                return true;
            }
            
            // Convert to number and check if it's valid
            const numValue = parseFloat(value);
            
            // Must be a valid number
            if (isNaN(numValue)) {
                return false;
            }
            
            // Must be between 0 and 100
            if (numValue < 0 || numValue > 100) {
                return false;
            }
            
            // Must be a multiple of 5
            return numValue % 5 === 0;
        }

        function showKTLOValidationError(inputElement, message) {
            // Add error class to input
            inputElement.classList.add('ktlo-percentage-error');
            
            // Remove any existing error message
            removeKTLOValidationError(inputElement);
            
            // Create and add error message
            const errorSpan = document.createElement('span');
            errorSpan.className = 'ktlo-percentage-error-message';
            errorSpan.textContent = message;
            
            // Insert error message after the input element
            inputElement.parentNode.appendChild(errorSpan);
        }

        function removeKTLOValidationError(inputElement) {
            // Remove error class from input
            inputElement.classList.remove('ktlo-percentage-error');
            
            // Remove error message
            const errorMessage = inputElement.parentNode.querySelector('.ktlo-percentage-error-message');
            if (errorMessage) {
                errorMessage.remove();
            }
        }

        function handleKTLOPercentageValidation(event) {
            const inputElement = event.target;
            const value = inputElement.value.trim();
            
            if (validateKTLOPercentage(value)) {
                removeKTLOValidationError(inputElement);
                return true;
            } else {
                showKTLOValidationError(inputElement, 'Value must be blank or a multiple of 5 between 0 and 100');
                
                // For blur events, prevent the user from leaving the field with invalid value
                if (event.type === 'blur') {
                    event.preventDefault();
                    // Refocus the field after a short delay to allow the error message to show
                    setTimeout(() => {
                        inputElement.focus();
                    }, 100);
                }
                return false;
            }
        }

        // Initialize KTLO percentage validation when DOM is loaded
        function initializeKTLOValidation() {
            const ktloPercentageInputs = [
                'ktlo-current-percentage',
                'edit-ktlo-current-percentage', 
                'editMonthlyKTLOPercentage'
            ];
            
            ktloPercentageInputs.forEach(inputId => {
                const inputElement = document.getElementById(inputId);
                if (inputElement) {
                    // Add blur event listener for validation when leaving field
                    inputElement.addEventListener('blur', handleKTLOPercentageValidation);
                    
                    // Add input event listener for immediate feedback
                    inputElement.addEventListener('input', handleKTLOPercentageValidation);
                }
            });
        }

        // Initialize validation when page loads
        document.addEventListener('DOMContentLoaded', initializeKTLOValidation);
        
        // Also initialize immediately in case DOM is already loaded
        if (document.readyState === 'loading') {
            // Do nothing, DOMContentLoaded will fire
        } else {
            // DOM is already loaded
            initializeKTLOValidation();
        }

        // Drag and Drop Functionality - entire builder panel
        function initializeDragAndDrop() {
            const builderPanel = document.querySelector('.builder-panel');
            
            if (!builderPanel) {
                console.warn('Builder panel not found');
                return;
            }

            // Builder panel drag events
            builderPanel.addEventListener('dragenter', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                if (e.dataTransfer && e.dataTransfer.types.includes('Files')) {
                    builderPanel.classList.add('drag-over');
                }
            });

            builderPanel.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                if (e.dataTransfer && e.dataTransfer.types.includes('Files')) {
                    e.dataTransfer.dropEffect = 'copy';
                }
            });

            builderPanel.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Only remove drag-over if leaving the builder panel entirely
                if (!builderPanel.contains(e.relatedTarget)) {
                    builderPanel.classList.remove('drag-over');
                }
            });

            builderPanel.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                builderPanel.classList.remove('drag-over');
                handleFileDrop(e);
            });
        }

        function handleFileDrop(e) {
            const files = e.dataTransfer.files;
            
            if (files.length === 0) {
                return;
            }

            // Only process the first file
            const file = files[0];
            const fileName = file.name.toLowerCase();
            
            // Check file type
            if (fileName.endsWith('.json')) {
                // Handle JSON file - create synthetic event for existing handler
                const syntheticEvent = {
                    target: {
                        files: [file],
                        value: '' // Reset value to allow same file to be loaded again
                    }
                };
                
                try {
                    handleFileLoad(syntheticEvent);
                } catch (error) {
                    console.error('Error handling dropped JSON file:', error);
                    alert('Error loading JSON file: ' + error.message);
                }
                
            } else {
                alert('Unsupported file type. Please drop a .json file.');
            }
        }

        // Initialize drag and drop when page loads
        document.addEventListener('DOMContentLoaded', initializeDragAndDrop);
        
        // Also initialize immediately in case DOM is already loaded
        if (document.readyState === 'loading') {
            // Do nothing, DOMContentLoaded will fire
        } else {
            // DOM is already loaded
            initializeDragAndDrop();
        }
        
        // Builder Collapse Functionality
        let isBuilderCollapsed = false;
        
        function toggleBuilderCollapse() {
            const builderPanel = document.querySelector('.builder-panel');
            const collapseBtn = document.getElementById('builderCollapseBtn');
            
            if (isBuilderCollapsed) {
                // Expand builder
                builderPanel.classList.remove('collapsed');
                collapseBtn.textContent = '‚ñ≤ Hide Builder';
                isBuilderCollapsed = false;
            } else {
                // Collapse builder
                builderPanel.classList.add('collapsed');
                collapseBtn.textContent = '‚ñº Show Builder';
                isBuilderCollapsed = true;
            }
        }
        
        // Update document title based on team name
        function updateDocumentTitle() {
            const teamNameInput = document.getElementById('teamName');
            const teamName = teamNameInput ? teamNameInput.value.trim() : '';
            
            // Use same format as filename: fallback to 'MyTeam' if no team name
                            const roadmapYear = document.getElementById('roadmapYear').value || '2025';
                document.title = `${teamName || 'MyTeam'}.Teya-Roadmap.${roadmapYear}.html`;
        }
        
        // Initialize title update when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const teamNameInput = document.getElementById('teamName');
            if (teamNameInput) {
                // Update title when team name changes
                teamNameInput.addEventListener('input', updateDocumentTitle);
                teamNameInput.addEventListener('blur', updateDocumentTitle);
                
                // Update title on initial load
                updateDocumentTitle();
            }
        });
    </script>
    
    <script>
        // File Browser functionality
        let selectedDirectoryHandle = null;
        
        // Save directory handle to localStorage (for persistence)
        function saveDirectoryHandle(directoryHandle) {
            try {
                // Store directory information in localStorage
                localStorage.setItem('roadmapDirectoryInfo', JSON.stringify({
                    name: directoryHandle.name,
                    savedAt: Date.now()
                }));
                
                // Store the actual handle in a way that can be restored
                // Note: Full persistence requires IndexedDB, but we can at least save the name
            } catch (error) {
                console.warn('Could not save directory info:', error);
            }
        }
        
        // Try to restore directory handle from localStorage
        async function restoreDirectoryHandle() {
            try {
                const savedInfo = localStorage.getItem('roadmapDirectoryInfo');
                if (!savedInfo) return false;
                
                const info = JSON.parse(savedInfo);
                
                // Show that we remember the directory, but need to re-select it
                const fileList = document.getElementById('fileList');
                const reminderDiv = document.createElement('div');
                reminderDiv.className = 'directory-reminder';
                reminderDiv.style.cssText = `
                    text-align: center;
                    color: #666;
                    font-style: italic;
                    padding: 15px;
                    font-size: 12px;
                    font-family: 'Courier New', monospace;
                    border: 1px dashed #ccc;
                    border-radius: 4px;
                    margin: 10px 0;
                `;
                reminderDiv.innerHTML = `
                    <div style="margin-bottom: 8px;">üìÅ Last used folder:</div>
                    <div style="font-weight: bold; color: #333;">${info.name}</div>
                    <div style="margin-top: 8px; font-size: 11px;">Click "Select Folder" to access it again</div>
                `;
                
                fileList.appendChild(reminderDiv);
                return true;
                
            } catch (error) {
                console.warn('Could not restore directory info:', error);
                return false;
            }
        }
        
        // Toggle file browser collapse
        function toggleFileBrowser() {
            const panel = document.getElementById('fileBrowserPanel');
            const toggle = document.getElementById('fileBrowserToggle');
            const expandBtn = document.getElementById('expandFileBrowserBtn');
            
            if (panel.classList.contains('collapsed')) {
                // Expand file browser
                panel.classList.remove('collapsed');
                toggle.textContent = '√ó';
                expandBtn.classList.remove('visible');
            } else {
                // Collapse file browser
                panel.classList.add('collapsed');
                toggle.textContent = '√ó';
                expandBtn.classList.add('visible');
            }
        }
        
        // Handle fallback directory selection
        function handleFallbackDirectorySelection(event) {
            const files = event.target.files;
            if (files && files.length > 0) {
                window._fallbackDirectoryFiles = files;
                loadDirectoryFiles();
                
                // Show directory path
                const fileList = document.getElementById('fileList');
                const pathDiv = document.createElement('div');
                pathDiv.className = 'directory-path';
                pathDiv.textContent = `üìÅ ${files[0].webkitRelativePath.split('/')[0]}/`;
                fileList.insertBefore(pathDiv, fileList.firstChild);
            }
        }
        
        // Update file browser button visibility based on panel state
        function updateFileBrowserButtonVisibility() {
            const panel = document.getElementById('fileBrowserPanel');
            const expandBtn = document.getElementById('expandFileBrowserBtn');
            
            if (panel && expandBtn) {
                if (panel.classList.contains('collapsed')) {
                    expandBtn.classList.add('visible');
                } else {
                    expandBtn.classList.remove('visible');
                }
            }
        }
        
        // Select directory using File System Access API
        async function selectDirectory() {
            try {
                if ('showDirectoryPicker' in window) {
                selectedDirectoryHandle = await window.showDirectoryPicker();
                saveDirectoryHandle(selectedDirectoryHandle);
                await loadDirectoryFiles();
                const fileList = document.getElementById('fileList');
                const pathDiv = document.createElement('div');
                pathDiv.className = 'directory-path';
                pathDiv.textContent = `üìÅ ${selectedDirectoryHandle.name}/`;
                fileList.insertBefore(pathDiv, fileList.firstChild);
                } else {
                    // Fallback: use webkitdirectory input
                    const input = document.getElementById('directoryFileInput');
                    input.onchange = handleFallbackDirectorySelection;
                    input.click();
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    return;
                }
                // If picker failed (permissions/policy), try fallback input
                try {
                    const input = document.getElementById('directoryFileInput');
                    input.onchange = handleFallbackDirectorySelection;
                    input.click();
                } catch (e) {
                console.error('Error selecting directory:', error);
                alert('Error selecting directory: ' + error.message);
                }
            }
        }
        
        // Load and display files from selected directory
        async function loadDirectoryFiles() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            
            // Clear any existing directory reminder
            const reminderDiv = document.querySelector('.directory-reminder');
            if (reminderDiv) {
                reminderDiv.remove();
            }
            
            if (!selectedDirectoryHandle && !window._fallbackDirectoryFiles) {
                fileList.innerHTML = '<div class="no-directory-message">Click "Select Folder" to browse your roadmap files</div>';
                return;
            }
            
            
            
            try {
                const roadmapFiles = [];
                if (selectedDirectoryHandle) {
                    // Iterate via File System Access API
                    for await (const [name, handle] of selectedDirectoryHandle.entries()) {
                    if (handle.kind === 'file') {
                        const isJson = name.toLowerCase().endsWith('.json');
                            if (isJson) {
                            try {
                                const file = await handle.getFile();
                                let teamName = 'Unknown Team';
                                    const content = await file.text().catch(() => null);
                                    if (content) {
                                        try {
                                        const roadmapData = JSON.parse(content);
                                        teamName = roadmapData.teamData?.teamName || 'Unknown Team';
                                        } catch (_) {
                                        teamName = 'Invalid JSON';
                                    }
                                    }
                                    roadmapFiles.push({ name, handle, teamName, size: file.size, lastModified: file.lastModified, fileType: 'json' });
                            } catch (error) {
                                console.warn(`Could not read roadmap file ${name}:`, error);
                            }
                            }
                        }
                    }
                } else if (window._fallbackDirectoryFiles) {
                    // Iterate fallback FileList
                    for (const file of window._fallbackDirectoryFiles) {
                        const name = file.name;
                        if (name.toLowerCase().endsWith('.json')) {
                            let teamName = 'Unknown Team';
                            const content = await file.text().catch(() => null);
                            if (content) {
                                try {
                                    const roadmapData = JSON.parse(content);
                                    teamName = roadmapData.teamData?.teamName || 'Unknown Team';
                                } catch (_) {
                                    teamName = 'Invalid JSON';
                                }
                            }
                            roadmapFiles.push({ name, handle: file, teamName, size: file.size, lastModified: file.lastModified, fileType: 'json' });
                        }
                    }
                }
                
                // Sort files by team name
                roadmapFiles.sort((a, b) => a.name.localeCompare(b.name));
                
                
                
                if (roadmapFiles.length === 0) {
                    fileList.innerHTML = '<div class="no-directory-message">No roadmap (.json) files found in this folder</div>';
                    return;
                }
                
                // Display files
                roadmapFiles.forEach(fileInfo => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.onclick = () => openRoadmapFile(fileInfo.handle, fileInfo.fileType);
                    
                    const fileTypeText = 'JSON';
                    const icon = 'üìã';
                    
                    fileItem.title = `${fileInfo.name}\nType: ${fileTypeText}\nTeam: ${fileInfo.teamName}\nSize: ${(fileInfo.size / 1024).toFixed(1)} KB\nModified: ${new Date(fileInfo.lastModified).toLocaleDateString('en-GB')}`;
                    
                    fileItem.innerHTML = `
                        <div class="file-item-icon">${icon}</div>
                        <div class="file-item-info">
                            <div class="file-item-name">${fileInfo.name}</div>
                        </div>
                    `;
                    
                    fileList.appendChild(fileItem);
                });
                
            } catch (error) {
                console.error('Error loading directory files:', error);
                fileList.innerHTML = '<div class="no-directory-message">Error loading files: ' + error.message + '</div>';
            }
        }
        
        // Open roadmap file - handle both JSON and Excel files
        async function openRoadmapFile(fileHandle, fileType) {
            try {
                // Support FileSystemFileHandle (getFile) and File (fallback)
                const file = (fileHandle && typeof fileHandle.getFile === 'function')
                    ? await fileHandle.getFile()
                    : fileHandle;
                
                if (fileType === 'json') {
                    // Handle JSON files - load directly in current tab
                    const content = await file.text();
                    const roadmapData = JSON.parse(content);
                    
                    // Handle both new format (with metadata) and legacy format (direct teamData)
                    const teamData = roadmapData.teamData || roadmapData;
                    
                    // Load directly in current tab (like the buttons do)
                    loadTeamData(teamData);
                    
                    // Update filename display
                    updateFilenameDisplay(file.name);
                    
                    setTimeout(() => {
                        refreshAllDatePickers();
                        generatePreview();
                    }, 500);
                }
            } catch (error) {
                console.error('Error opening roadmap file:', error);
                    alert('Error opening roadmap file: ' + error.message);
            }
                }
        
        // Process Excel workbook directly without localStorage
        
        // Check for loaded data from URL parameters
        function checkForLoadedData() {
            const urlParams = new URLSearchParams(window.location.search);
            const loadDataKey = urlParams.get('loadData');
            
            if (loadDataKey) {
                // Set flag to prevent default template loading
                window.loadingExternalData = true;
                try {
                    const dataStr = localStorage.getItem(loadDataKey);
                    if (dataStr) {
                        const loadedData = JSON.parse(dataStr);
                        
                        if (loadedData._fileType === 'excel') {
                            // Excel handling removed
                        } else {
                            // Handle JSON data
                            const teamData = loadedData.teamData || loadedData;
                            loadTeamData(teamData);
                            
                            // Ensure KTLO month data is displayed after JSON loading
                            setTimeout(() => {
                                const selector = document.getElementById('ktlo-month-selector');
                                if (selector) {
                                    const currentMonth = selector.value || 'jan';
                                    loadKTLOMonth(currentMonth);
                                }
                            }, 100);
                        }
                        
                        // Collapse the builder if requested
                        if (loadedData._collapseBuilder) {
                            setTimeout(() => {
                                if (!isBuilderCollapsed) {
                                    toggleBuilderCollapse();
                                }
                            }, 100);
                        }
                        
                        // Clean up localStorage
                        localStorage.removeItem(loadDataKey);
                        
                        // Remove the parameter from URL for cleaner appearance
                        const newUrl = window.location.href.split('?')[0];
                        window.history.replaceState({}, document.title, newUrl);
                        
                        return true; // Indicate that external data was loaded
                    }
                } catch (error) {
                    console.error('Error loading roadmap data:', error);
                    alert('Error loading roadmap data: ' + error.message);
                    
                    // Clear the flag since loading failed
                    window.loadingExternalData = false;
                    return false; // Indicate that external data loading failed
                }
            } else {
                return false; // No external data found
            }
        }
        
        // Check if File System Access API is supported and show warning if not
        document.addEventListener('DOMContentLoaded', async function() {
            // Check for loaded data first - this must happen before default template loading
            const hasExternalData = checkForLoadedData();
            
            // Initialize sorting checkboxes from saved prefs
            const sortingToggle = document.getElementById('story-sorting-toggle');
            const endToggle = document.getElementById('story-sorting-end-toggle');
            const textBelowToggle = document.getElementById('force-text-below-toggle');
            if (sortingToggle) {
                const byStart = getConfigUtility().shouldSortByStart() || getConfigUtility().shouldSortStories();
                sortingToggle.checked = !!byStart;
            }
            if (endToggle) {
                endToggle.checked = !!getConfigUtility().shouldSortByEnd();
            }
            // Force text below is a one-time action, don't restore from saved state
            if (textBelowToggle) {
                textBelowToggle.checked = false;
            }
            
            if (!('showDirectoryPicker' in window)) {
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = `
                    <div class="no-directory-message" style="color: #dc3545;">
                        <strong>File Browser Not Supported</strong><br>
                        Please use Chrome, Edge, or another compatible browser to browse local roadmap files.
                    </div>
                `;
            } else {
                // Try to restore directory info from localStorage
                const restored = await restoreDirectoryHandle();
                if (!restored) {
                    // Show default message if no previous directory
                    const fileList = document.getElementById('fileList');
                    if (fileList.children.length === 0) {
                        fileList.innerHTML = '<div class="no-directory-message">Click "Select Folder" to browse your roadmap files</div>';
                    }
                }
            }
        });
        
        // ==================== SEARCH FUNCTIONALITY ====================
        
        /**
         * Open Search interface
         */
        function openIMOSearch() {
            window.open('imo-search.html', '_blank');
        }
        
    </script>
</body>
</html> 