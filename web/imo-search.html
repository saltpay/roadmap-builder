<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Cross-team search</title>
    
    <!-- Link to external CSS file -->
    <link rel="stylesheet" href="./styles.css">
    <link rel="stylesheet" href="./roadmap-styles.css">
    
    <!-- Import Utilities -->
    <script src="./utilities/date-utility.js"></script>
    <script src="./utilities/ui-utility.js"></script>
    <script src="./utilities/config-utility.js"></script>
    <script src="./utilities/imo-utility.js"></script>
    <script src="./utilities/imo-view-generator.js"></script>
    <script src="./roadmap-generator.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #f8f9fa;
        }
        
        /* Header Container */
        .header-container {
            background: white;
            padding: 60px 20px 15px 20px;
            border-bottom: 2px solid #007cba;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 50px;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header-left h1 {
            margin: 0;
            color: #007cba;
            font-size: 28px;
        }
        
        .subtitle {
            margin: 5px 0 0 0;
            color: #666;
            font-size: 16px;
        }
        
        /* Main Container */
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .title-and-controls {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .search-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .search-title h1 {
            margin: 0;
            color: #007cba;
            font-size: 28px;
        }
        
        /* Directory Selection */
        .directory-selection {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            border-left: 4px solid #28a745;
        }
        
        .directory-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        /* Search Sections */
        .search-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            border-left: 4px solid #007cba;
        }
        
        .search-section-title {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
            font-weight: 600;
        }
        
        .directory-button {
            background: #007cba;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
            border: 2px solid #007cba;
        }
        
        .directory-button:hover {
            background: #005a87;
            border-color: #005a87;
        }
        
        .directory-button.selected {
            background: #28a745;
            border-color: #28a745;
        }
        
        .directory-status {
            font-size: 14px;
            color: #666;
            font-style: italic;
        }
        
        .search-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .search-input-group:last-child {
            margin-bottom: 0;
        }
        
        .search-input {
            flex: 1;
            padding: 5px 12px !important;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        
        .search-input.date-input {
            flex: none;
            width: 145px;
        }
        
        .search-input.range-select {
            flex: none;
            width: 110px;
        }
        
        .search-input.wide-dropdown {
            flex: none;
            width: 120px;
        }
        
        .search-input.imo-input {
            flex: none;
            width: 300px;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #007cba;
        }
        
        .search-button {
            background: #007cba;
            color: white;
            border: 2px solid transparent;
            padding: 4px 12px !important;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
            white-space: nowrap;
            min-width: 120px;
            transform: translateY(5px);
        }
        
        .search-button:hover:not(:disabled) {
            background: #005a87;
        }
        
        .search-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .search-title {
            text-align: center;
            margin-bottom: 20px;
        }
        
        /* Main Content Area */
        .main-content {
            flex: 1;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            padding: 20px;
            overflow-y: auto;
        }
        
        /* Blank State */
        .blank-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }
        
        .blank-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }
        
        .blank-state h2 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 24px;
        }
        
        .blank-state p {
            margin: 0 0 30px 0;
            font-size: 16px;
            line-height: 1.5;
        }
        

        
        /* Loading State */
        .loading-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007cba;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Results Area */
        .results-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        /* Reset any list styling that might interfere */
        .results-container ul, 
        .results-container li {
            margin: 0;
            padding: 0;
        }
        
        /* Override any page styles for bullets specifically */
        .results-container .task-bullets {
            font-size: 9pt !important;
            margin: 0 !important;
            padding-left: 12px !important;
            list-style-type: square !important;
        }
        
        .results-container .task-bullets li {
            margin: 0 !important;
            padding: 0 !important;
            line-height: 1.2 !important;
        }
        
        /* Modal Base Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px 0 24px;
            border-bottom: 1px solid #eee;
            margin-bottom: 20px;
        }

        .modal-header h3 {
            margin: 0;
            color: #333;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #999;
            line-height: 1;
        }

        .close:hover {
            color: #333;
        }

        .modal-body {
            padding: 0 24px 20px 24px;
            max-height: calc(90vh - 140px);
            overflow-y: auto;
        }

        .modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-top: 1px solid #eee;
            background-color: #f8f9fa;
            border-radius: 0 0 8px 8px;
        }

        .modal-footer button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .modal-footer .secondary {
            background-color: #6c757d;
            color: white;
        }

        .modal-footer .secondary:hover {
            background-color: #5a6268;
        }

        .modal-footer .primary {
            background-color: #007cba;
            color: white;
        }

        .modal-footer .primary:hover {
            background-color: #006ba1;
        }

        /* Read-Only Field Styles */
        .readonly-field {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px 12px;
            min-height: 20px;
            font-size: 14px;
            line-height: 1.4;
            color: #333;
        }
        
        .readonly-bullets {
            white-space: pre-line;
            max-height: 120px;
            overflow-y: auto;
        }
        
        /* Form group styling */
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }
        
        .inline-group {
            display: flex;
            gap: 20px;
        }
        
        .inline-group .form-group {
            flex: 1;
        }
        
        .border-card {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #fafafa;
        }
        
        .border-card h5 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }
        
        .border-section {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            background-color: #fafafa;
        }
        
        .border-section h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }
        
        /* Checkbox group styling */
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        /* Target specific modal checkboxes by ID */
        #viewNewStory, #viewDone, #viewCancelled, #viewInfo, 
        #viewTimelineChanges, #viewAtRisk, #viewProposed, 
        #viewTransferredIn, #viewTransferredOut {
            accent-color: red !important;
            background-color: red !important;
            border: 2px solid red !important;
            opacity: 1 !important;
            cursor: default;
        }
        
        .checkbox-group input[type="checkbox"] + label {
            margin-left: -8px;
        }
        

        
        .checkbox-group label {
            display: flex;
            align-items: center;
            font-weight: normal;
            margin-bottom: 0;
            cursor: default;
                }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .search-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-input-group {
                min-width: auto;
            }
            
            .search-title {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            
            .inline-group {
                flex-direction: column;
                gap: 15px;
            }
        }
        
        /* Tri-state checkbox styling */
        .tri-state-checkbox {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border: 2px solid #666;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            user-select: none;
            flex-shrink: 0;
        }
        
        .tri-state-checkbox[data-state="include"] {
            background-color: #007cba;
            border-color: #007cba;
            color: white;
        }
        
        .tri-state-checkbox[data-state="exclude"] {
            background-color: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        /* Bar chart expand/collapse styles */
        .bar-chart-container[data-tooltip="breakdown"]:hover {
            background: #e5e7eb !important;
        }
        
        .expand-chevron {
            display: inline-block;
            transition: transform 0.2s ease;
        }
        
        .bar-chart-container:hover .expand-chevron {
            color: #374151;
        }
    </style>
</head>
<body>
    <div class="search-container">
        <!-- Search Header -->
        <div class="search-header">
            <div class="title-and-controls">
                <div class="search-title">
                    <h1>üîç Cross-Team Search</h1>
                    <div style="display: flex; gap: 10px;">
                        <button class="search-button" onclick="openSearchStatsModal()" id="searchStatsBtn" disabled style="min-width: 120px;">
                            üìä Stats
                        </button>
                        <button class="search-button" onclick="clearAllSearchFields()" style="min-width: 160px;">
                            üßπ Clear All
                        </button>
                    </div>
                </div>
                
                <!-- Directory Selection - Top Priority -->
                <div class="directory-selection">
                    <div class="directory-row">
                        <button class="directory-button" id="selectDirBtn" onclick="selectDirectory()">
                            üìÅ Select Directory
                        </button>
                        <span class="directory-status" id="directoryStatus">No directory selected</span>
                    </div>
                </div>

                <!-- Director/VP/EM/PM Search -->
                <div class="search-section">
                    <h3 class="search-section-title">üë§ Leadership Search</h3>
                    <div class="search-input-group">
                        <input type="text"
                               class="search-input imo-input"
                               id="directorSearchInput"
                               placeholder="Enter Director/VP, EM, or PM name (partial match)"
                               onkeypress="handleDirectorSearchKeyPress(event)">
                        <button class="search-button" id="directorSearchBtn" onclick="performDirectorSearch()" disabled>
                            üë§ Search Leadership
                        </button>
                    </div>
                </div>

                <!-- IMO Search -->
                <div class="search-section">
                    <h3 class="search-section-title">üîç IMO Search</h3>
                    <div class="search-input-group">
                            <input type="text" 
                               class="search-input imo-input" 
                                   id="searchInput" 
                               placeholder="Enter IMO number (0043)" 
                                   onkeypress="handleSearchKeyPress(event)">
                        <button class="search-button" id="imoSearchBtn" onclick="performIMOSearch()" disabled>
                            üîç Search
                            </button>
                    </div>
                </div>
                
                <!-- Story Title Search -->
                <div class="search-section">
                    <h3 class="search-section-title">üìù Story Title Search</h3>
                    <div class="search-input-group">
                        <input type="text" 
                               class="search-input imo-input" 
                               id="titleSearchInput" 
                               placeholder="Enter text to search in story titles" 
                               onkeypress="handleTitleSearchKeyPress(event)">
                        <button class="search-button" id="titleSearchBtn" onclick="performTitleSearch()" disabled>
                            üìù Search Titles
                        </button>
                    </div>
                </div>
                
                <!-- Date Range Search -->
                <div class="search-section">
                    <h3 class="search-section-title">üìÖ Date Search</h3>
                    <div class="search-input-group">
                        <input type="date" 
                               class="search-input date-input" 
                               id="startDateInput" 
                               placeholder="Start Date (optional)"
                               onchange="handleDateRangeChange(event)">
                        <input type="date" 
                               class="search-input date-input" 
                               id="endDateInput" 
                               placeholder="End Date (optional)"
                               onchange="handleDateRangeChange(event)">
                        <select class="search-input range-select wide-dropdown" id="searchModeSelect" onchange="updateSearchModeHelp()">
                            <option value="exact">Exact</option>
                            <option value="exact-7days">Exact +/- 7 Days</option>
                            <option value="range">Range</option>
                            <option value="current-year">Current Year</option>
                        </select>
                        <button class="search-button" id="dateRangeSearchBtn" onclick="performDateRangeSearch()" disabled>
                            üìÖ Search Dates
                        </button>
                    </div>
                    <div id="searchModeHelp" style="font-size: 12px; color: #666; margin-top: 5px;">
                        Exact: Stories must start/end exactly on the specified dates.
                    </div>
                </div>

                <!-- Status Filters Section -->
                <div class="search-section">
                    <h3 class="search-section-title">üéØ Status Filters</h3>
                    <div style="padding: 0 5px; margin-top: 10px;">
                        <!-- Row 1: New, Done, Cancelled, Info, Timeline -->
                        <div style="display: flex; flex-wrap: wrap; column-gap: 15px; row-gap: 8px; align-items: center; margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;" onclick="cycleFilterState('filterNew', event)">
                                <span id="filterNew" class="tri-state-checkbox" data-state="none"></span>
                                <span>New</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;" onclick="cycleFilterState('filterDone', event)">
                                <span id="filterDone" class="tri-state-checkbox" data-state="none"></span>
                                <span>Done</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;" onclick="cycleFilterState('filterCancelled', event)">
                                <span id="filterCancelled" class="tri-state-checkbox" data-state="none"></span>
                                <span>Cancelled</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;" onclick="cycleFilterState('filterInfo', event)">
                                <span id="filterInfo" class="tri-state-checkbox" data-state="none"></span>
                                <span>Info</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;" onclick="cycleFilterState('filterTimeline', event)">
                                <span id="filterTimeline" class="tri-state-checkbox" data-state="none"></span>
                                <span>Timeline</span>
                            </label>
                            <!-- Force line break -->
                            <div style="flex-basis: 100%; height: 0;"></div>
                            <!-- Row 2: At Risk, Proposed, Transferred: In, Out -->
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; white-space: nowrap;" onclick="cycleFilterState('filterAtRisk', event)">
                                <span id="filterAtRisk" class="tri-state-checkbox" data-state="none"></span>
                                <span>At Risk</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;" onclick="cycleFilterState('filterProposed', event)">
                                <span id="filterProposed" class="tri-state-checkbox" data-state="none"></span>
                                <span>Proposed</span>
                            </label>
                            <span style="font-weight: bold; margin-right: 5px; display: flex; align-items: center; position: relative; top: -2px; left: 6px;">Transferred:</span>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; margin-right: 5px;" onclick="cycleFilterState('filterTransferredIn', event)">
                                <span id="filterTransferredIn" class="tri-state-checkbox" data-state="none"></span>
                                <span>In</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;" onclick="cycleFilterState('filterTransferredOut', event)">
                                <span id="filterTransferredOut" class="tri-state-checkbox" data-state="none"></span>
                                <span>Out</span>
                            </label>
                        </div>
                        
                        <div style="font-size: 11px; color: #888; margin-top: 8px;">
                            Click once for ‚úì (include), twice for ! (exclude/NOT), three times to clear. Filters apply to all search results.
                        </div>
                        
                        <!-- Advanced Expression Filter -->
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                            <div style="font-size: 12px; font-weight: bold; color: #555; margin-bottom: 5px;">Advanced Filter (Optional):</div>
                            <input type="text" 
                                   id="advancedFilterExpression" 
                                   placeholder="e.g., Done && !Timeline, (Cancelled || AtRisk) && New"
                                   onchange="applyStatusFilters()"
                                   style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 12px;">
                            <div style="font-size: 10px; color: #888; margin-top: 5px;">
                                Use: <code>&&</code> (AND), <code>||</code> (OR), <code>!</code> (NOT), <code>( )</code> (grouping)<br>
                                Status names: Done, Cancelled, Timeline, New, AtRisk, Proposed, Info, TransferredIn, TransferredOut<br>
                                Expression overrides checkboxes if provided.
                            </div>
                        </div>
                    </div>
                </div>

                </div>

                
            </div>
        
        <!-- Main Content Area -->
        <div class="main-content">
            <div id="contentArea">
                <!-- Blank State -->
                <div class="blank-state" id="blankState">
                    <div class="blank-state-icon">üîç</div>
                    <h2>Cross-Team IMO & Timeline Search</h2>
                    <p>Search across multiple team roadmaps to find stories by IMO number or timeline</p>
                    
                    <p style="font-size: 14px; color: #999;">
                        First select a directory containing roadmap JSON files, then enter your search query
                    </p>
                            </div>
                            </div>
                            </div>
                        </div>

    <!-- Story Details Modal (Read-Only) -->
    <div id="storyDetailsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="storyDetailsTitle">Story Details</h3>
                <span class="close" onclick="closeStoryDetailsModal()">&times;</span>
                </div>
            <div class="modal-body">
                <form id="viewStoryForm">
                    <div class="form-group">
                        <label>Story Title:</label>
                        <div class="readonly-field" id="viewTitle"></div>
            </div>
                    
                    <div class="form-group">
                        <label>Team:</label>
                        <div class="readonly-field" id="viewTeam"></div>
        </div>
                    
                    <div class="form-group">
                        <label>Epic:</label>
                        <div class="readonly-field" id="viewEpic"></div>
                    </div>
                    
                    <!-- KTLO Position Toggle (only shown for KTLO) -->
                    <div class="form-group" id="viewKTLOPositionGroup" style="display: none;">
                        <label>KTLO Position:</label>
                        <div class="readonly-field" id="viewKTLOPosition"></div>
                    </div>
                    
                    <div class="inline-group">
                        <div class="form-group">
                            <label>Start Date/Month:</label>
                            <div class="readonly-field" id="viewStart"></div>
                        </div>
                        <div class="form-group">
                            <label>End Date/Month:</label>
                            <div class="readonly-field" id="viewEnd"></div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Bullet Points:</label>
                        <div class="readonly-field readonly-bullets" id="viewBullets"></div>
                    </div>
                    
                    <!-- BTL Date Added field (only shown for BTL) -->
                    <div id="viewBTLDateAddedGroup" class="form-group" style="display: none;">
                        <label>Date Added:</label>
                        <div class="readonly-field" id="viewBTLDateAdded"></div>
                    </div>
                    
                    <div id="viewBTLDescriptionGroup" class="form-group" style="display: none;">
                        <label>Description:</label>
                        <div class="readonly-field" id="viewBTLDescription"></div>
                    </div>
                    
                    <!-- Monthly KTLO Data (only shown for KTLO) -->
                    <div id="viewKTLOMonthlySection" style="display: none; margin-top: 15px; padding: 15px; border: 1px solid #ddd; border-radius: 4px;">
                        <h4 style="margin: 0 0 15px 0;">Monthly KTLO Data</h4>
                        <div id="viewKTLOMonthsContainer"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>IMO <span style="font-style: italic; color: #888;">(optional)</span>:</label>
                        <div class="readonly-field" id="viewIMO"></div>
                    </div>
                    
                    <!-- Row 1: New, Done, Cancelled, Info, Timeline -->
                    <div class="checkbox-group">
                        <input type="checkbox" id="viewNewStory" disabled>
                        <label for="viewNewStory">New</label>
                        
                        <input type="checkbox" id="viewDone" disabled>
                        <label for="viewDone">Done</label>
                        
                        <input type="checkbox" id="viewCancelled" disabled>
                        <label for="viewCancelled">Cancelled</label>
                        
                        <input type="checkbox" id="viewInfo" disabled>
                        <label for="viewInfo">Info</label>
                        
                        <input type="checkbox" id="viewTimelineChanges" disabled>
                        <label for="viewTimelineChanges">Timeline</label>
                    </div>
                    
                    <!-- Row 2: At Risk, Proposed, Transferred: In, Out -->
                    <div class="checkbox-group">
                        <input type="checkbox" id="viewAtRisk" disabled>
                        <label for="viewAtRisk">At Risk</label>
                        
                        <input type="checkbox" id="viewProposed" disabled>
                        <label for="viewProposed">Proposed</label>
                        
                        <label style="margin-left: 8px; margin-right: 2px;">Transferred:</label>
                        <input type="checkbox" id="viewTransferredIn" disabled>
                        <label for="viewTransferredIn" style="margin-right: 5px;">In</label>
                        
                        <input type="checkbox" id="viewTransferredOut" disabled>
                        <label for="viewTransferredOut">Out</label>
                    </div>
                    
                    <div id="viewStatusFields" style="margin-top: 10px;">
                        
                        <div id="viewDoneFields" class="border-card" style="display: none;">
                            <h5>Story Complete</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label>Done Date:</label>
                                    <div class="readonly-field" id="viewDoneDate"></div>
                                </div>
                                <div class="form-group">
                                    <label>Done Notes:</label>
                                    <div class="readonly-field" id="viewDoneNotes"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="viewCancelFields" class="border-card" style="display: none;">
                            <h5>Story Cancellation</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label>Cancel Date:</label>
                                    <div class="readonly-field" id="viewCancelDate"></div>
                                </div>
                                <div class="form-group">
                                    <label>Cancel Notes:</label>
                                    <div class="readonly-field" id="viewCancelNotes"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="viewAtRiskFields" class="border-card" style="display: none;">
                            <h5>Story At Risk</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label>Risk Date:</label>
                                    <div class="readonly-field" id="viewAtRiskDate"></div>
                                </div>
                                <div class="form-group">
                                    <label>Risk Notes:</label>
                                    <div class="readonly-field" id="viewAtRiskNotes"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="viewNewStoryFields" class="border-card" style="display: none;">
                            <h5>New Story</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label>New Date:</label>
                                    <div class="readonly-field" id="viewNewStoryDate"></div>
                                </div>
                                <div class="form-group">
                                    <label>New Notes:</label>
                                    <div class="readonly-field" id="viewNewStoryNotes"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="viewInfoFields" class="border-card" style="display: none;">
                            <h5>Story Information</h5>
                            <div id="viewInfoEntries">
                                <!-- Info entries will be added here -->
                            </div>
                        </div>

                        <div id="viewTransferredInFields" class="border-card" style="display: none;">
                            <h5>Story Transferred In Details</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label>Transfer In Date:</label>
                                    <div class="readonly-field" id="viewTransferredInDate"></div>
                                </div>
                                <div class="form-group">
                                    <label>Transfer In Notes:</label>
                                    <div class="readonly-field" id="viewTransferredInNotes"></div>
                                </div>
                            </div>
                        </div>

                        <div id="viewTransferredOutFields" class="border-card" style="display: none;">
                            <h5>Story Transferred Out Details</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label>Transfer Out Date:</label>
                                    <div class="readonly-field" id="viewTransferredOutDate"></div>
                                </div>
                                <div class="form-group">
                                    <label>Transfer Out Notes:</label>
                                    <div class="readonly-field" id="viewTransferredOutNotes"></div>
                                </div>
                            </div>
                        </div>

                        <div id="viewProposedFields" class="border-card" style="display: none;">
                            <h5>Proposed Story</h5>
                            <div class="inline-group">
                                <div class="form-group">
                                    <label>Proposed Date:</label>
                                    <div class="readonly-field" id="viewProposedDate"></div>
                                </div>
                                <div class="form-group">
                                    <label>Proposed Notes:</label>
                                    <div class="readonly-field" id="viewProposedNotes"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Story Timeline Section -->
                    <div id="viewTimelineChangesSection" class="border-section" style="display: none; margin-top: 20px;">
                        <h4>Story Timeline</h4>
                        <div id="viewChangesContainer">
                            <!-- Story timeline entries will be added here -->
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="secondary" onclick="closeStoryDetailsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Search Stats Modal -->
    <div id="searchStatsModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 10000; align-items: center; justify-content: center; padding: 20px;">
        <div style="background: #fff; border-radius: 10px; width: 60vw; max-width: 500px; max-height: 90vh; box-shadow: 0 10px 30px rgba(0,0,0,0.25); display: flex; flex-direction: column;">
            <div style="display:flex; align-items:center; justify-content:space-between; padding: 12px 16px; border-bottom: 1px solid #e5e7eb; flex-shrink: 0;">
                <h3 style="margin:0; font-size: 18px;">üìä Search Results Statistics</h3>
                <button onclick="closeSearchStatsModal()" style="border:none; background:none; font-size: 20px; line-height: 1; cursor:pointer; color: #666; padding: 4px;">√ó</button>
            </div>
            <div id="searchStatsModalBody" style="padding: 16px; overflow-y: auto; flex: 1; min-height: 0;">
                <!-- Stats content will be injected here -->
            </div>
            <div style="padding: 12px 16px; border-top: 1px solid #e5e7eb; text-align: right; flex-shrink: 0;">
                <button onclick="closeSearchStatsModal()" class="secondary">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let selectedDirectory = null;
        let currentResults = [];
        let lastSearchStories = [];
        let lastRoadmapFiles = [];
        
        // Track tri-state checkbox states: 'none', 'include', 'exclude'
        const statusFilterStates = {
            filterNew: 'none',
            filterDone: 'none',
            filterCancelled: 'none',
            filterAtRisk: 'none',
            filterTimeline: 'none',
            filterProposed: 'none',
            filterInfo: 'none',
            filterTransferredIn: 'none',
            filterTransferredOut: 'none'
        };
        
        // Search Stats Modal Functions
        function openSearchStatsModal() {
            try {
                if (!currentResults || currentResults.length === 0) {
                    alert('No search results to analyze. Please perform a search first.');
                    return;
                }
                
                const stats = computeSearchStats(currentResults);
                const body = document.getElementById('searchStatsModalBody');
                body.innerHTML = renderSearchStatsHtml(stats);
                const modal = document.getElementById('searchStatsModal');
                modal.style.display = 'flex';
                
                // Make stats available for interactive breakdown
                window.__searchStats = stats;
                
                // Add tooltip functionality after DOM is updated
                setTimeout(setupSearchTooltips, 100);
            } catch (e) {
                alert('Failed to compute stats: ' + e.message);
            }
        }
        
        function closeSearchStatsModal() {
            const modal = document.getElementById('searchStatsModal');
            if (modal) modal.style.display = 'none';
        }
        
        function computeSearchStats(stories) {
            const result = {
                totalStories: 0,
                totalTeams: 0,
                onTime: 0,
                onTimeDone: 0,
                onTimeNotDone: 0,
                delayedOnce: 0,
                delayedTwiceOrMore: 0,
                accelerated: 0,
                cancelled: 0,
                totalDelayed: 0,
                delayBreakdown: {},
                delayStories: {},
                acceleratedStories: { done: [], notDone: [] },
                onTimeStories: { done: [], notDone: [] },
                cancelledStories: [],
                teams: new Set()
            };
            
            if (!Array.isArray(stories)) return result;
            
            result.totalStories = stories.length;
            
            for (const story of stories) {
                // Track unique teams
                if (story.teamName) {
                    result.teams.add(story.teamName);
                }
                
                if (story.isCancelled) {
                    result.cancelled++;
                    result.cancelledStories.push({
                        title: story.title || 'Untitled',
                        teamName: story.teamName || 'Unknown Team',
                        epicName: story.epicName || ''
                    });
                    continue;
                }
                
                const changes = story.roadmapChanges?.changes || [];
                
                // Count only ACTUAL delays (new date > prev date)
                let actualDelayCount = 0;
                let hasAcceleration = false;
                
                if (Array.isArray(changes) && changes.length > 0) {
                    for (const change of changes) {
                        if (change.prevEndDate && change.newEndDate) {
                            // Parse dates properly using IMOUtility
                            const roadmapYear = story.roadmapYear || new Date().getFullYear();
                            const prevISO = IMOUtility.parseStoryDate(change.prevEndDate, roadmapYear);
                            const newISO = IMOUtility.parseStoryDate(change.newEndDate, roadmapYear);
                            
                            if (prevISO && newISO) {
                                // Compare ISO date strings
                                if (newISO > prevISO) {
                                    actualDelayCount++; // Actual delay
                                } else if (newISO < prevISO) {
                                    hasAcceleration = true; // Pulled forward
                                }
                            }
                        }
                    }
                }
                
                if (actualDelayCount === 0 && !hasAcceleration) {
                    // No timeline changes at all
                    result.onTime++;
                    const isDone = story.isDone || false;
                    if (isDone) {
                        result.onTimeDone++;
                        result.onTimeStories.done.push({ title: story.title || 'Untitled', teamName: story.teamName || 'Unknown Team' });
                    } else {
                        result.onTimeNotDone++;
                        result.onTimeStories.notDone.push({ title: story.title || 'Untitled', teamName: story.teamName || 'Unknown Team' });
                    }
                } else if (hasAcceleration && actualDelayCount === 0) {
                    // Only accelerations, no delays
                    result.accelerated++;
                    const acceleratedStory = { title: story.title || 'Untitled', teamName: story.teamName || 'Unknown Team' };
                    if (story.isDone) {
                        result.acceleratedStories.done.push(acceleratedStory);
                    } else {
                        result.acceleratedStories.notDone.push(acceleratedStory);
                    }
                } else if (actualDelayCount > 0) {
                    // Has at least one actual delay
                    result.totalDelayed++;
                    if (actualDelayCount === 1) {
                        result.delayedOnce++;
                    } else {
                        result.delayedTwiceOrMore++;
                    }
                    
                    // Track exact delay count for breakdown
                    result.delayBreakdown[actualDelayCount] = (result.delayBreakdown[actualDelayCount] || 0) + 1;
                    if (!result.delayStories[actualDelayCount]) {
                        result.delayStories[actualDelayCount] = { done: [], notDone: [] };
                    }
                    const delayedStory = {
                        title: story.title || 'Untitled',
                        teamName: story.teamName || 'Unknown Team'
                    };
                    if (story.isDone) {
                        result.delayStories[actualDelayCount].done.push(delayedStory);
                    } else {
                        result.delayStories[actualDelayCount].notDone.push(delayedStory);
                    }
                }
            }
            
            result.totalTeams = result.teams.size;
            return result;
        }
        
        function renderSearchStatsHtml(s) {
            const pct = (num, den) => (den ? ((num / den) * 100).toFixed(1) : 0);
            const activeStories = s.totalStories - s.cancelled;
            
            return (
                '<div style="padding: 20px;">' +
                    '<h3 style="margin: 0 0 20px 0; color: #333; text-align: center;">üìä Search Results Overview</h3>' +
                    '<div style="margin-bottom: 20px; text-align: center; font-size: 14px; color: #666;">' +
                        `${s.totalStories} Stories across ${s.totalTeams} Teams` +
                    '</div>' +
                    '<div style="max-width: 600px; margin: 0 auto;">' +
                        barChart('On-time Projects', s.onTime, s.totalStories, '#28a745', s, 'ontime') +
                        barChart('Delayed Projects', s.totalDelayed, s.totalStories, '#dc3545', s, 'delayed') +
                        barChart('Accelerated Projects', s.accelerated, s.totalStories, '#17a2b8', s, 'accelerated') +
                        barChart('Cancelled', s.cancelled, s.totalStories, '#6c757d', s, 'cancelled') +
                    '</div>' +
                '</div>'
            );
        }
        
        function barChart(label, value, total, color, stats, breakdownType) {
            const percentage = total ? ((value / total) * 100).toFixed(1) : 0;
            
            let tooltipContent = '';
            let expandIcon = '';
            let cursorStyle = 'default';
            if (stats && breakdownType) {
                tooltipContent = `data-tooltip="breakdown" data-breakdown-type="${breakdownType}"`;
                cursorStyle = 'pointer';
                // Add expand/collapse chevron icon on the LEFT
                expandIcon = `<span class="expand-chevron" style="margin-right: 8px; font-size: 12px; color: #6b7280; transition: transform 0.2s ease; pointer-events: none;">‚ñ∂</span>`;
            }
            
            return (
                '<div style="margin-bottom: 12px; padding: 8px 12px; border-radius: 6px; background: #f9fafb; cursor: ' + cursorStyle + '; transition: all 0.2s ease;" class="bar-chart-container" ' + tooltipContent + '>' +
                    '<div style="display: flex; justify-content: space-between; align-items: center; pointer-events: none;">' +
                        `<span style="font-size: 14px; font-weight: 500; color: #374151; display: flex; align-items: center;">${expandIcon}${label}</span>` +
                        `<span style="font-size: 14px; font-weight: 600; color: ${color};">${value} (${percentage}%)</span>` +
                    '</div>' +
                '</div>'
            );
        }
        
        function getDelayBreakdown(stats) {
            let result = 'Delay Breakdown:\\n';
            
            const sortedDelays = Object.keys(stats.delayBreakdown || {})
                .map(Number)
                .sort((a, b) => a - b);
            
            if (sortedDelays.length === 0) {
                result += 'No delays recorded';
            } else {
                sortedDelays.forEach(delayCount => {
                    const count = stats.delayBreakdown[delayCount];
                    result += `${delayCount} delay${delayCount > 1 ? 's' : ''}: ${count}\\n`;
                });
            }
            
            return result;
        }
        
        function setupSearchTooltips() {
            const tooltipElements = document.querySelectorAll('[data-tooltip]');
            tooltipElements.forEach(element => {
                // Remove old listener if it exists to prevent duplicates
                element.removeEventListener('click', toggleSearchDelayBreakdown);
                element.addEventListener('click', toggleSearchDelayBreakdown);
            });
        }
        
        function toggleSearchDelayBreakdown(e) {
            e.preventDefault();
            e.stopPropagation();

            const container = e.currentTarget || e.target.closest('[data-tooltip]');
            if (!container) return;

            const breakdownType = container.getAttribute('data-breakdown-type');
            if (!breakdownType) return;
            
            const breakdownId = `search-${breakdownType}-breakdown`;

            // Toggle only this specific breakdown
            const existing = document.getElementById(breakdownId);
            
            // Find the chevron icon - the container itself should be the bar-chart-container
            const barChartContainer = container.classList.contains('bar-chart-container') ? container : container.closest('.bar-chart-container');
            const chevron = barChartContainer ? barChartContainer.querySelector('.expand-chevron') : null;
            
            if (existing) {
                existing.remove();
                // Rotate chevron back to collapsed state (pointing right)
                if (chevron) {
                    chevron.style.transform = 'rotate(0deg)';
                }
                return; // Just close it, don't reopen
            }

            // Rotate chevron to expanded state (pointing down)
            if (chevron) {
                chevron.style.transform = 'rotate(90deg)';
            }

            const stats = window.__searchStats || { delayBreakdown: {}, delayStories: {}, totalStories: 0, cancelled: 0 };
            const activeStories = (stats.totalStories || 0) - (stats.cancelled || 0);

            // Create breakdown container
            const breakdown = document.createElement('div');
            breakdown.id = breakdownId;
            breakdown.__for = container;
            breakdown.style.cssText = `
                margin-top: 10px;
                padding: 12px;
                background: #f8f9fa;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                font-size: 12px;
                color: #374151;
            `;
            
            if (breakdownType === 'delayed') {
                breakdown.innerHTML = renderSearchDelayBreakdown(stats, stats.totalStories);
            } else if (breakdownType === 'ontime') {
                breakdown.innerHTML = renderSearchOntimeBreakdown(stats, stats.totalStories);
            } else if (breakdownType === 'accelerated') {
                breakdown.innerHTML = renderSearchAcceleratedBreakdown(stats, stats.totalStories);
            } else if (breakdownType === 'cancelled') {
                breakdown.innerHTML = renderSearchCancelledBreakdown(stats);
            }

            // Insert directly after the clicked container
            container.parentNode.insertBefore(breakdown, container.nextSibling);

            // Enable expand/collapse on rows
            setupSearchDelayBreakdownInteractions();
        }
        
        function renderSearchOntimeBreakdown(stats, totalStories) {
            const done = stats.onTimeDone || 0;
            const notDone = stats.onTimeNotDone || 0;
            const doneStories = (stats.onTimeStories && stats.onTimeStories.done) || [];
            const notDoneStories = (stats.onTimeStories && stats.onTimeStories.notDone) || [];
            
            if (done === 0 && notDone === 0) {
                return '<div style="color:#6b7280;">No on-time projects</div>';
            }
            
            const donePct = totalStories ? ((done / totalStories) * 100).toFixed(1) : 0;
            const notDonePct = totalStories ? ((notDone / totalStories) * 100).toFixed(1) : 0;
            
            return (
                '<div class="delay-row" id="search-ontime-done-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Done (' + done + ' / ' + donePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="search-ontime-done-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #28a745;">' +
                        renderSearchDelayDetails(doneStories) +
                    '</div>' +
                '</div>' +
                '<div class="delay-row" id="search-ontime-notdone-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Not Done (' + notDone + ' / ' + notDonePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="search-ontime-notdone-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #ffc107;">' +
                        renderSearchDelayDetails(notDoneStories) +
                    '</div>' +
                '</div>'
            );
        }
        
        function renderSearchAcceleratedBreakdown(stats, totalStories) {
            const acceleratedStories = stats.acceleratedStories || { done: [], notDone: [] };
            
            // Handle backward compatibility: if acceleratedStories is an array (old format), convert it
            if (Array.isArray(acceleratedStories)) {
                const doneStories = acceleratedStories.filter(s => s.isDone);
                const notDoneStories = acceleratedStories.filter(s => !s.isDone);
                acceleratedStories = { done: doneStories, notDone: notDoneStories };
            }
            
            const done = acceleratedStories.done ? acceleratedStories.done.length : 0;
            const notDone = acceleratedStories.notDone ? acceleratedStories.notDone.length : 0;
            const doneStories = acceleratedStories.done || [];
            const notDoneStories = acceleratedStories.notDone || [];
            
            if (done === 0 && notDone === 0) {
                return '<div style="color:#6b7280;">No accelerated projects</div>';
            }
            
            const donePct = totalStories ? ((done / totalStories) * 100).toFixed(1) : 0;
            const notDonePct = totalStories ? ((notDone / totalStories) * 100).toFixed(1) : 0;
            
            return (
                '<div class="delay-row" id="search-accelerated-done-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Done (' + done + ' / ' + donePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="search-accelerated-done-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #28a745;">' +
                        renderSearchDelayDetails(doneStories) +
                    '</div>' +
                '</div>' +
                '<div class="delay-row" id="search-accelerated-notdone-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Not Done (' + notDone + ' / ' + notDonePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="search-accelerated-notdone-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #ffc107;">' +
                        renderSearchDelayDetails(notDoneStories) +
                    '</div>' +
                '</div>'
            );
        }
        
        function renderSearchDelayBreakdown(stats, totalStories) {
            const counts = stats.delayBreakdown || {};
            const sorted = Object.keys(counts).map(n => parseInt(n, 10)).sort((a, b) => a - b);
            if (sorted.length === 0) {
                return '<div style="color:#6b7280;">No delays recorded</div>';
            }
            
            const rows = sorted.map(delayCount => {
                const value = counts[delayCount] || 0;
                const pct = totalStories ? ((value / totalStories) * 100).toFixed(1) : 0;
                const delayGroup = (stats.delayStories && stats.delayStories[delayCount]) || { done: [], notDone: [] };
                const doneCount = delayGroup.done ? delayGroup.done.length : 0;
                const notDoneCount = delayGroup.notDone ? delayGroup.notDone.length : 0;
                const rowId = `search-delay-row-${delayCount}`;
                const detailsId = `search-delay-details-${delayCount}`;
                
                return (
                    '<div class="delay-row" id="' + rowId + '" style="margin-bottom: 8px; margin-left: 10px;">' +
                        '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                            '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                            '<span style="font-size:13px; color:#374151;">' + delayCount + ' delay' + (delayCount > 1 ? 's' : '') + ' (' + value + ' / ' + pct + '%)</span>' +
                        '</div>' +
                        '<div class="delay-row-details" id="' + detailsId + '" style="display:none; margin-left: 20px;">' +
                            renderSearchDelaySubBreakdown(delayGroup, delayCount, value) +
                        '</div>' +
                    '</div>'
                );
            }).join('');
            return rows;
        }
        
        function renderSearchDelaySubBreakdown(delayGroup, delayCount, totalCount) {
            // Handle backward compatibility: if delayGroup is an array (old format), convert it
            if (Array.isArray(delayGroup)) {
                const doneStories = delayGroup.filter(s => s.isDone);
                const notDoneStories = delayGroup.filter(s => !s.isDone);
                delayGroup = { done: doneStories, notDone: notDoneStories };
            }
            
            const doneStories = delayGroup.done || [];
            const notDoneStories = delayGroup.notDone || [];
            const doneCount = doneStories.length;
            const notDoneCount = notDoneStories.length;
            
            const donePct = totalCount ? ((doneCount / totalCount) * 100).toFixed(1) : 0;
            const notDonePct = totalCount ? ((notDoneCount / totalCount) * 100).toFixed(1) : 0;
            
            return (
                '<div class="delay-row" id="search-delay-' + delayCount + '-done-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Done (' + doneCount + ' / ' + donePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="search-delay-' + delayCount + '-done-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #28a745;">' +
                        renderSearchDelayDetails(doneStories) +
                    '</div>' +
                '</div>' +
                '<div class="delay-row" id="search-delay-' + delayCount + '-notdone-row" style="margin-bottom: 8px; margin-left: 10px;">' +
                    '<div class="delay-row-header" style="display:flex; align-items:center; cursor:pointer; padding: 4px 0;">' +
                        '<span style="margin-right: 8px; color:#999;">‚ñ∂</span>' +
                        '<span style="font-size:13px; color:#374151;">Not Done (' + notDoneCount + ' / ' + notDonePct + '%)</span>' +
                    '</div>' +
                    '<div class="delay-row-details" id="search-delay-' + delayCount + '-notdone-details" style="display:none; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #ffc107;">' +
                        renderSearchDelayDetails(notDoneStories) +
                    '</div>' +
                '</div>'
            );
        }
        
        function compareByTeamThenTitle(a, b) {
            const ta = (a.teamName || '').toLowerCase();
            const tb = (b.teamName || '').toLowerCase();
            if (ta !== tb) return ta < tb ? -1 : 1;
            const sa = (a.title || '').toLowerCase();
            const sb = (b.title || '').toLowerCase();
            if (sa !== sb) return sa < sb ? -1 : 1;
            return 0;
        }

        function renderSearchDelayDetails(stories) {
            if (!stories || !stories.length) return '<div style="color:#6b7280;">No items</div>';
            const sorted = [...stories].sort(compareByTeamThenTitle);
            return sorted.map(s => {
                const title = (s.title || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const team = (s.teamName || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                return '<div style="font-size:12px; color:#374151; padding:2px 0;">' +
                    (team ? '<span style="color:#6b7280;">[' + team + ']</span> ' : '') +
                    title +
                '</div>';
            }).join('');
        }

        function renderSearchCancelledBreakdown(stats) {
            const cancelled = Array.isArray(stats.cancelledStories) ? stats.cancelledStories : [];
            if (cancelled.length === 0) {
                return '<div style="color:#6b7280;">No cancelled projects</div>';
            }
            const sorted = [...cancelled].sort(compareByTeamThenTitle);
            const items = sorted.map(s => {
                const title = (s.title || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const team = (s.teamName || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                return '<div style="font-size:12px; color:#374151; padding:2px 0;">' +
                    (team ? '<span style="color:#6b7280;">[' + team + ']</span> ' : '') +
                    title +
                '</div>';
            }).join('');
            return '<div style="display:block; margin-left: 20px; padding:8px; background:#ffffff; border-left: 2px solid #dc3545;">' + items + '</div>';
        }
        
        function setupSearchDelayBreakdownInteractions() {
            const rows = document.querySelectorAll('[id$="-breakdown"] .delay-row');
            rows.forEach(row => {
                const details = row.querySelector('.delay-row-details');
                const header = row.querySelector('.delay-row-header');
                const arrow = header ? header.querySelector('span:first-child') : null;
                
                // Remove any existing click handler to prevent duplicates
                if (header && header._toggleHandler) {
                    header.removeEventListener('click', header._toggleHandler);
                }
                
                const toggle = () => {
                    if (!details) return;
                    const isOpen = details.style.display !== 'none';
                    details.style.display = isOpen ? 'none' : 'block';
                    if (arrow) {
                        arrow.textContent = isOpen ? '‚ñ∂' : '‚ñº';
                    }
                };
                
                // Store the handler reference for later removal
                if (header) {
                    header._toggleHandler = toggle;
                    header.addEventListener('click', toggle);
                }
            });
        }
        
        /**
         * Open story details modal (read-only)
         * @param {Object} storyData - Story data object
         */
        function openStoryDetailsModal(storyData) {
            // Check if modal exists
            const storyModal = document.getElementById('storyDetailsModal');
            if (!storyModal) {
                
                return;
            }
            
            // Set modal title
            document.getElementById('storyDetailsTitle').textContent = `Story Details: ${storyData.title}`;
            
            // Populate basic fields
            document.getElementById('viewTitle').textContent = storyData.title || '';
            document.getElementById('viewTeam').textContent = storyData.teamName || '';
            document.getElementById('viewEpic').textContent = storyData.epicName || '';
            
            // Handle start/end dates
            const startValue = storyData.startDate || storyData.startMonth || storyData.start || '';
            const endValue = storyData.endDate || storyData.endMonth || storyData.end || '';
            document.getElementById('viewStart').textContent = startValue || 'Not specified';
            document.getElementById('viewEnd').textContent = endValue || 'Not specified';
            
            // Handle bullets
            let bulletsText = '';
            if (storyData.bullets) {
                if (Array.isArray(storyData.bullets)) {
                    bulletsText = storyData.bullets.join('\n');
                } else if (typeof storyData.bullets === 'string') {
                    bulletsText = storyData.bullets;
                } else {
                    bulletsText = String(storyData.bullets);
                }
            }
            document.getElementById('viewBullets').textContent = bulletsText || 'None';
            
            // Handle IMO
            let imoText = '';
            if (storyData.imo) {
                imoText = String(storyData.imo);
            }
            document.getElementById('viewIMO').textContent = imoText || 'None';
            
            // Handle KTLO-specific fields
            const isKTLO = storyData.epicName === 'KTLO';
            const ktloPositionGroup = document.getElementById('viewKTLOPositionGroup');
            const ktloMonthlySection = document.getElementById('viewKTLOMonthlySection');
            
            if (isKTLO) {
                // KTLO Position
                const position = storyData.position ? 'Top (Before the Epics)' : 'Bottom (After the Epics)';
                document.getElementById('viewKTLOPosition').textContent = position;
                ktloPositionGroup.style.display = 'block';
                
                // KTLO Monthly Data (if available)
                if (storyData.monthlyData && Object.keys(storyData.monthlyData).length > 0) {
                    populateKTLOMonthlyData(storyData.monthlyData);
                    ktloMonthlySection.style.display = 'block';
                } else {
                    ktloMonthlySection.style.display = 'none';
                }
            } else {
                ktloPositionGroup.style.display = 'none';
                ktloMonthlySection.style.display = 'none';
            }
            
            // Handle BTL-specific fields
            const isBTL = storyData.sourceType === 'btl';
            const btlDateAddedGroup = document.getElementById('viewBTLDateAddedGroup');
            const btlDescriptionGroup = document.getElementById('viewBTLDescriptionGroup');
            
            if (isBTL) {
                if (storyData.dateAdded) {
                    document.getElementById('viewBTLDateAdded').textContent = storyData.dateAdded;
                    btlDateAddedGroup.style.display = 'block';
                } else {
                    btlDateAddedGroup.style.display = 'none';
                }
                
                if (storyData.description) {
                    document.getElementById('viewBTLDescription').textContent = String(storyData.description);
                    btlDescriptionGroup.style.display = 'block';
                } else {
                    btlDescriptionGroup.style.display = 'none';
                }
            } else {
                btlDateAddedGroup.style.display = 'none';
                btlDescriptionGroup.style.display = 'none';
            }
            
            // Handle checkboxes
            populateCheckboxes(storyData);
            
            // Handle status fields
            populateStatusFields(storyData);
            
            // Handle timeline changes
            populateTimelineChanges(storyData);
            
            // Show modal
            const modalElement = document.getElementById('storyDetailsModal');
            modalElement.style.display = 'flex';
            
            // Style checkboxes for visibility after modal is shown
            setTimeout(() => {
                const checkboxIds = ['viewNewStory', 'viewDone', 'viewCancelled', 'viewInfo', 
                                   'viewTimelineChanges', 'viewAtRisk', 'viewProposed', 
                                   'viewTransferredIn', 'viewTransferredOut'];
                checkboxIds.forEach(id => {
                    const checkbox = document.getElementById(id);
                    if (checkbox) {
                        // Remove disabled to allow styling
                        checkbox.disabled = false;
                        // Force blue styling with !important to override red !important
                        checkbox.style.setProperty('accent-color', '#007cba', 'important');
                        checkbox.style.setProperty('background-color', 'transparent', 'important');
                        checkbox.style.setProperty('border', '1px solid #ccc', 'important');
                        checkbox.style.setProperty('outline', 'none', 'important');
                    }
                });
            }, 100);
        }
        
        /**
         * Populate checkboxes based on story data
         */
        function populateCheckboxes(storyData) {
            // Check if timeline changes exist - can be either array or object with changes property
            const changes = Array.isArray(storyData.roadmapChanges) 
                ? storyData.roadmapChanges 
                : storyData.roadmapChanges?.changes;
            const hasTimelineChanges = !!(changes && changes.length > 0);
            
            // Set checkbox states
            document.getElementById('viewNewStory').checked = storyData.isNewStory || false;
            document.getElementById('viewDone').checked = storyData.isDone || false;
            document.getElementById('viewCancelled').checked = storyData.isCancelled || false;
            document.getElementById('viewInfo').checked = storyData.isInfo || false;
            document.getElementById('viewTimelineChanges').checked = hasTimelineChanges;
            document.getElementById('viewAtRisk').checked = storyData.isAtRisk || false;
            document.getElementById('viewProposed').checked = storyData.isProposed || false;
            document.getElementById('viewTransferredIn').checked = storyData.isTransferredIn || false;
            document.getElementById('viewTransferredOut').checked = storyData.isTransferredOut || false;
        }
        
        /**
         * Populate KTLO monthly data
         */
        function populateKTLOMonthlyData(monthlyData) {
            const container = document.getElementById('viewKTLOMonthsContainer');
            container.innerHTML = '';
            
            const months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            
            months.forEach(month => {
                const data = monthlyData[month];
                if (data && (data.teamSize || data.percentage || data.description)) {
                    const monthDiv = document.createElement('div');
                    monthDiv.style.marginBottom = '15px';
                    monthDiv.style.padding = '10px';
                    monthDiv.style.border = '1px solid #ddd';
                    monthDiv.style.borderRadius = '4px';
                    
                    monthDiv.innerHTML = `
                        <h5 style="margin: 0 0 10px 0; text-transform: uppercase;">${month}</h5>
                        <div class="inline-group">
                            <div class="form-group">
                                <label>Team Size:</label>
                                <div class="readonly-field">${data.teamSize || 'Not specified'}</div>
                            </div>
                            <div class="form-group">
                                <label>KTLO %:</label>
                                <div class="readonly-field">${data.percentage || 'Not specified'}</div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Description:</label>
                            <div class="readonly-field">${data.description || 'None'}</div>
                        </div>
                    `;
                    
                    container.appendChild(monthDiv);
                }
            });
        }
        
        /**
         * Populate status fields
         */
        function populateStatusFields(storyData) {
            // Always show status fields section since checkboxes are always visible
            // Individual field visibility is controlled by checkbox state
            
            // Done status
            if (storyData.isDone) {
                const doneInfo = storyData.doneInfo || {};
                const roadmapDoneInfo = storyData.roadmapChanges?.doneInfo || {};
                
                const doneDate = doneInfo.date || roadmapDoneInfo.date || storyData.doneDate || 'Not specified';
                const doneNotes = doneInfo.notes || roadmapDoneInfo.notes || storyData.doneNotes || 'None';
                
                document.getElementById('viewDoneDate').textContent = doneDate;
                document.getElementById('viewDoneNotes').textContent = doneNotes;
                document.getElementById('viewDoneFields').style.display = 'block';
            } else {
                document.getElementById('viewDoneFields').style.display = 'none';
            }
            
            // Cancelled status
            if (storyData.isCancelled) {
                const cancelInfo = storyData.cancelInfo || {};
                const roadmapCancelInfo = storyData.roadmapChanges?.cancelInfo || {};
                
                const cancelDate = cancelInfo.date || roadmapCancelInfo.date || storyData.cancelDate || 'Not specified';
                const cancelNotes = cancelInfo.notes || roadmapCancelInfo.notes || storyData.cancelNotes || 'None';
                
                document.getElementById('viewCancelDate').textContent = cancelDate;
                document.getElementById('viewCancelNotes').textContent = cancelNotes;
                document.getElementById('viewCancelFields').style.display = 'block';
            } else {
                document.getElementById('viewCancelFields').style.display = 'none';
            }
            
            // At Risk status
            if (storyData.isAtRisk) {
                // Check multiple possible locations for At Risk data
                const atRiskInfo = storyData.atRiskInfo || {};
                const roadmapAtRiskInfo = storyData.roadmapChanges?.atRiskInfo || {};
                
                // Try different property names (different data sources use different names)
                const atRiskDate = atRiskInfo.date || 
                                 roadmapAtRiskInfo.date || 
                                 storyData.atRiskDate || 
                                 storyData.riskDate || 
                                 'Not specified';
                                 
                const atRiskNotes = atRiskInfo.notes || 
                                  roadmapAtRiskInfo.notes || 
                                  storyData.atRiskNotes || 
                                  storyData.riskNotes || 
                                  'None';
                
                document.getElementById('viewAtRiskDate').textContent = atRiskDate;
                document.getElementById('viewAtRiskNotes').textContent = atRiskNotes;
                document.getElementById('viewAtRiskFields').style.display = 'block';
            } else {
                document.getElementById('viewAtRiskFields').style.display = 'none';
            }
            
            // New Story status
            if (storyData.isNewStory) {
                const newStoryInfo = storyData.newStoryInfo || {};
                const roadmapNewStoryInfo = storyData.roadmapChanges?.newStoryInfo || {};
                
                const newStoryDate = newStoryInfo.date || roadmapNewStoryInfo.date || storyData.newDate || 'Not specified';
                const newStoryNotes = newStoryInfo.notes || roadmapNewStoryInfo.notes || storyData.newNotes || 'None';
                
                document.getElementById('viewNewStoryDate').textContent = newStoryDate;
                document.getElementById('viewNewStoryNotes').textContent = newStoryNotes;
                document.getElementById('viewNewStoryFields').style.display = 'block';
            } else {
                document.getElementById('viewNewStoryFields').style.display = 'none';
            }
            
            // Info status
            if (storyData.isInfo) {
                const infoInfo = storyData.infoInfo || {};
                const roadmapInfoInfo = storyData.roadmapChanges?.infoInfo || {};
                
                // Clear existing info entries
                const infoContainer = document.getElementById('viewInfoEntries');
                if (infoContainer) {
                    infoContainer.innerHTML = '';
                }
                
                if (Array.isArray(roadmapInfoInfo) && roadmapInfoInfo.length > 0) {
                    // Multiple info entries - display all of them
                    roadmapInfoInfo.forEach((entry, index) => {
                        if (entry && (entry.date || entry.notes)) {
                            const entryDiv = document.createElement('div');
                            entryDiv.style.marginBottom = '15px';
                            entryDiv.style.padding = '10px';
                            entryDiv.style.border = '1px solid #ddd';
                            entryDiv.style.borderRadius = '4px';
                            entryDiv.style.backgroundColor = '#f9f9f9';
                            
                            entryDiv.innerHTML = `
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <strong>Info Entry #${index + 1}</strong>
                                </div>
                                <div class="inline-group">
                                    <div class="form-group">
                                        <label>Info Date:</label>
                                        <div class="readonly-field">${entry.date || 'Not specified'}</div>
                                    </div>
                                    <div class="form-group">
                                        <label>Information Details:</label>
                                        <div class="readonly-field">${entry.notes || 'None'}</div>
                                    </div>
                                </div>
                            `;
                            
                            infoContainer.appendChild(entryDiv);
                        }
                    });
                    
                    // Show the info section
                    document.getElementById('viewInfoFields').style.display = 'block';
                } else if (roadmapInfoInfo && roadmapInfoInfo.date) {
                    // Single info entry (backward compatibility)
                    const entryDiv = document.createElement('div');
                    entryDiv.style.marginBottom = '15px';
                    entryDiv.style.padding = '10px';
                    entryDiv.style.border = '1px solid #ddd';
                    entryDiv.style.borderRadius = '4px';
                    entryDiv.style.backgroundColor = '#f9f9f9';
                    
                    entryDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong>Info Entry #1</strong>
                        </div>
                        <div class="inline-group">
                            <div class="form-group">
                                <label>Info Date:</label>
                                <div class="readonly-field">${roadmapInfoInfo.date || 'Not specified'}</div>
                            </div>
                            <div class="form-group">
                                <label>Information Details:</label>
                                <div class="readonly-field">${roadmapInfoInfo.notes || 'None'}</div>
                            </div>
                        </div>
                    `;
                    
                    infoContainer.appendChild(entryDiv);
                    document.getElementById('viewInfoFields').style.display = 'block';
                } else {
                    // Fallback to old format
                    const entryDiv = document.createElement('div');
                    entryDiv.style.marginBottom = '15px';
                    entryDiv.style.padding = '10px';
                    entryDiv.style.border = '1px solid #ddd';
                    entryDiv.style.borderRadius = '4px';
                    entryDiv.style.backgroundColor = '#f9f9f9';
                    
                    entryDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong>Info Entry #1</strong>
                        </div>
                        <div class="inline-group">
                            <div class="form-group">
                                <label>Info Date:</label>
                                <div class="readonly-field">${infoInfo.date || storyData.infoDate || 'Not specified'}</div>
                            </div>
                            <div class="form-group">
                                <label>Information Details:</label>
                                <div class="readonly-field">${infoInfo.notes || storyData.infoNotes || 'None'}</div>
                            </div>
                        </div>
                    `;
                    
                    infoContainer.appendChild(entryDiv);
                    document.getElementById('viewInfoFields').style.display = 'block';
                }
            } else {
                document.getElementById('viewInfoFields').style.display = 'none';
            }
            
            // Transferred In status
            if (storyData.isTransferredIn) {
                const transferredInInfo = storyData.transferredInInfo || {};
                const roadmapTransferredInInfo = storyData.roadmapChanges?.transferredInInfo || {};
                
                const transferredInDate = transferredInInfo.date || roadmapTransferredInInfo.date || storyData.transferredInDate || 'Not specified';
                const transferredInNotes = transferredInInfo.notes || roadmapTransferredInInfo.notes || storyData.transferredInNotes || 'None';
                
                document.getElementById('viewTransferredInDate').textContent = transferredInDate;
                document.getElementById('viewTransferredInNotes').textContent = transferredInNotes;
                document.getElementById('viewTransferredInFields').style.display = 'block';
            } else {
                document.getElementById('viewTransferredInFields').style.display = 'none';
            }
            
            // Transferred Out status
            if (storyData.isTransferredOut) {
                const transferredOutInfo = storyData.transferredOutInfo || {};
                const roadmapTransferredOutInfo = storyData.roadmapChanges?.transferredOutInfo || {};
                
                const transferredOutDate = transferredOutInfo.date || roadmapTransferredOutInfo.date || storyData.handedOverDate || 'Not specified';
                const transferredOutNotes = transferredOutInfo.notes || roadmapTransferredOutInfo.notes || storyData.handedOverNotes || 'None';
                
                document.getElementById('viewTransferredOutDate').textContent = transferredOutDate;
                document.getElementById('viewTransferredOutNotes').textContent = transferredOutNotes;
                document.getElementById('viewTransferredOutFields').style.display = 'block';
            } else {
                document.getElementById('viewTransferredOutFields').style.display = 'none';
            }
            
            // Proposed status
            if (storyData.isProposed) {
                const proposedInfo = storyData.proposedInfo || {};
                const roadmapProposedInfo = storyData.roadmapChanges?.proposedInfo || {};
                
                const proposedDate = proposedInfo.date || roadmapProposedInfo.date || storyData.proposedDate || 'Not specified';
                const proposedNotes = proposedInfo.notes || roadmapProposedInfo.notes || storyData.proposedNotes || 'None';
                
                document.getElementById('viewProposedDate').textContent = proposedDate;
                document.getElementById('viewProposedNotes').textContent = proposedNotes;
                document.getElementById('viewProposedFields').style.display = 'block';
            } else {
                document.getElementById('viewProposedFields').style.display = 'none';
            }
        }
        
        /**
         * Populate timeline changes
         */
        function populateTimelineChanges(storyData) {
            const timelineSection = document.getElementById('viewTimelineChangesSection');
            const container = document.getElementById('viewChangesContainer');
            
            // Check for timeline changes - can be either array or object with changes property
            const changes = Array.isArray(storyData.roadmapChanges) 
                ? storyData.roadmapChanges 
                : storyData.roadmapChanges?.changes;
            
            if (changes && changes.length > 0) {
                container.innerHTML = '';
                
                changes.forEach((change, index) => {
                    const changeDiv = document.createElement('div');
                    changeDiv.style.marginBottom = '15px';
                    changeDiv.style.padding = '15px';
                    changeDiv.style.border = '1px solid #ddd';
                    changeDiv.style.borderRadius = '4px';
                    changeDiv.style.backgroundColor = '#f9f9f9';
                    
                    changeDiv.innerHTML = `
                        <h5 style="margin: 0 0 10px 0;">Timeline #${index + 1}</h5>
                        <div class="inline-group">
                            <div class="form-group">
                                <label>Change Date:</label>
                                <div class="readonly-field">${change.date || change.changeDate || 'Not specified'}</div>
                            </div>
                            <div class="form-group">
                                <label>Previous End Date:</label>
                                <div class="readonly-field">${change.prevEndDate || change.previousEndDate || 'Not specified'}</div>
                            </div>
                            <div class="form-group">
                                <label>New End Date:</label>
                                <div class="readonly-field">${change.newEndDate || 'Not specified'}</div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Change Notes:</label>
                            <div class="readonly-field">${change.description || change.changeNotes || 'None'}</div>
                        </div>
                    `;
                    
                    container.appendChild(changeDiv);
                });
                
                timelineSection.style.display = 'block';
            } else {
                timelineSection.style.display = 'none';
            }
        }
        
        /**
         * Close story details modal
         */
        function closeStoryDetailsModal() {
            document.getElementById('storyDetailsModal').style.display = 'none';
        }
        
        /**
         * Handle clicks outside modal to close it
         */
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('storyDetailsModal');
            if (event.target === modal) {
                closeStoryDetailsModal();
            }
        });
        
        /**
         * Handle Escape key to close modal
         */
        document.addEventListener('keydown', function(event) {
            // Check if user is currently typing in an editable element
            const activeElement = document.activeElement;
            const isEditable = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.contentEditable === 'true'
            );
            
            // Always allow Escape key to work (to close modals)
            if (event.key === 'Escape') {
                closeStoryDetailsModal();
                closeSearchStatsModal();
                return;
            }
            
            // Don't handle other shortcuts when user is typing in an editable field
            if (isEditable) {
                return;
            }
            
            // Shift-S to open stats dialog
            if (event.shiftKey && event.key === 'S') {
                event.preventDefault();
                openSearchStatsModal();
            }
        });
        
        /**
         * Add click handlers to story items in search results
         * @param {Array} storiesData - Array of story data objects
         */
        function addStoryClickHandlers(storiesData) {
            // Find all story items in the rendered roadmap
            const storyItems = document.querySelectorAll('.story-item, .ktlo-story');
            
            storyItems.forEach((storyElement, index) => {
                // Extract story identification from data attributes
                const epicName = storyElement.dataset.epicName;
                const storyTitle = storyElement.dataset.storyTitle;
                const storyIndex = storyElement.dataset.storyIndex;
                
                // Find matching story data
                const storyData = findStoryData(storiesData, epicName, storyTitle, storyIndex);
                
                if (storyData) {
                    // Add click handler
                    storyElement.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        openStoryDetailsModal(storyData);
                    });
                    
                    // Add visual indicator for clickable stories
                    storyElement.style.cursor = 'pointer';
                    storyElement.title = 'Click to view story details';
                }
            });
        }
        
        /**
         * Find story data by epic name, title, and index
         * @param {Array} storiesData - Array of story data objects
         * @param {string} epicName - Epic name
         * @param {string} storyTitle - Story title
         * @param {string} storyIndex - Story index
         * @returns {Object|null} - Story data object or null if not found
         */
        function findStoryData(storiesData, epicName, storyTitle, storyIndex) {
            return storiesData.find(story => {
                // Match by epic name and story title (most reliable)
                if (story.epicName === epicName && story.title === storyTitle) {
                    return true;
                }
                
                // Fallback: match by title only for unique titles
                if (story.title === storyTitle) {
                    const titleMatches = storiesData.filter(s => s.title === storyTitle);
                    if (titleMatches.length === 1) {
                        return true;
                    }
                }
                
                return false;
            });
        }
        
        /**
         * Select directory containing roadmap files
         */
        async function selectDirectory() {
            try {
                selectedDirectory = await window.showDirectoryPicker();
                
                // Update UI
                const dirBtn = document.getElementById('selectDirBtn');
                const dirStatus = document.getElementById('directoryStatus');
                
                dirBtn.textContent = '‚úì ' + selectedDirectory.name;
                dirBtn.classList.add('selected');
                dirStatus.textContent = `Selected: ${selectedDirectory.name}`;
                
                // Update all search button states
                updateSearchButtonStates();
                
            } catch (error) {
                if (error.name !== 'AbortError') {
                    
                    alert('Error selecting directory: ' + error.message);
                }
            }
        }
        
        /**
         * Handle Enter key in search input
         */
        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                performSearch();
            }
        }
        
        /**
         * Handle Enter key in title search input
         */
        function handleTitleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                performTitleSearch();
            }
        }
        
        /**
         * Perform the IMO/Timeline search
         */
        async function performSearch() {
            try {
                // Validate inputs
                if (!selectedDirectory) {
                    alert('Please select a directory first');
                        return;
                    }
                
                const searchQuery = document.getElementById('searchInput').value.trim();
                if (!searchQuery) {
                    alert('Please enter a search query');
                        return;
                    }
                
                // Show loading state
                showLoadingState(`Searching for "${searchQuery}"...`);
                
                // Scan directory for roadmap files
                const roadmapFiles = await IMOUtility.scanRoadmapDirectory(selectedDirectory);
                
                if (roadmapFiles.length === 0) {
                    showMessage('No roadmap JSON files found in the selected directory', 'warning');
                    return;
                }
                
                // Extract and search stories
                const allStories = IMOUtility.aggregateStoriesAcrossTeams(roadmapFiles);
                
                let matchingStories = IMOUtility.searchStories(allStories, searchQuery);
                
                // Store base search results before filtering for potential re-filtering
                lastSearchStories = matchingStories.slice();
                lastRoadmapFiles = roadmapFiles;
                
                matchingStories = applyAdditionalFilters(matchingStories, roadmapFiles, { skipIMO: true });
                
                if (matchingStories.length === 0) {
                    showMessage(`No stories found for "${searchQuery}"`, 'info');
                    return;
                }
                
                // Store results and display
                currentResults = matchingStories;
                displaySearchResults(matchingStories, searchQuery);
                
                // Enable stats button
                document.getElementById('searchStatsBtn').disabled = false;
                
            } catch (error) {
                
                showMessage('Search error: ' + error.message, 'error');
            }
        }
        
        // Temporary variable for search results force text below (one-time action)
        let searchTempForceTextBelow = false;
        let lastSearchQuery = null;
        
        /**
         * Handle force text below toggle in search results
         */
        function handleSearchForceTextBelowToggle() {
            const toggle = document.getElementById('search-force-text-below-toggle');
            if (toggle) {
                // Use temporary variable instead of saving to localStorage
                searchTempForceTextBelow = toggle.checked;
                // Regenerate the search results to apply placement
                displaySearchResults(currentResults, lastSearchQuery);
                
                // Restore checkbox state after regeneration
                setTimeout(() => {
                    const newToggle = document.getElementById('search-force-text-below-toggle');
                    if (newToggle) {
                        newToggle.checked = searchTempForceTextBelow;
                    }
                }, 100);
            }
        }
        
        /**
         * Display search results using roadmap format
         */
        function displaySearchResults(stories, searchQuery, searchRange = null) {
            try {
                // Only reset search force text below checkbox for new searches (not regenerations)
                if (searchQuery !== lastSearchQuery) {
                    const searchToggle = document.getElementById('search-force-text-below-toggle');
                    if (searchToggle) {
                        searchToggle.checked = false;
                        searchTempForceTextBelow = false;
                    }
                }
                
                // Update lastSearchQuery for next comparison
                lastSearchQuery = searchQuery;
                
                // Sort stories by dates in ascending order (oldest first)  
                stories.sort((a, b) => {
                    // Use consistent year for all stories - roadmap year if available, otherwise current year
                    const roadmapYear = stories.length > 0 && stories[0].roadmapYear 
                        ? stories[0].roadmapYear 
                        : new Date().getFullYear();
                    
                    const aStartDate = IMOUtility.parseStoryDate(a.startDate || a.startMonth || '', roadmapYear);
                    const aEndDate = IMOUtility.parseStoryDate(a.endDate || a.endMonth || '', roadmapYear);
                    const bStartDate = IMOUtility.parseStoryDate(b.startDate || b.startMonth || '', roadmapYear);
                    const bEndDate = IMOUtility.parseStoryDate(b.endDate || b.endMonth || '', roadmapYear);
                    
                    // If both have start dates, sort by start date first
                    if (aStartDate && bStartDate) {
                        const startComparison = aStartDate - bStartDate;
                        if (startComparison !== 0) {
                            return startComparison; // Different start dates
                        }
                        // Same start dates - sort by end date (ascending)
                        if (aEndDate && bEndDate) {
                            return aEndDate - bEndDate;
                        }
                        // One has end date, one doesn't
                        if (aEndDate && !bEndDate) return -1; // a comes first
                        if (!aEndDate && bEndDate) return 1;  // b comes first
                        return 0; // Both have same start, no end dates
                    }
                    
                    // Fallback: use primary date (start date or end date)
                    let aPrimaryDate = aStartDate || aEndDate;
                    let bPrimaryDate = bStartDate || bEndDate;
                    
                    // Handle null dates (put them at the end)
                    if (!aPrimaryDate && !bPrimaryDate) return 0;
                    if (!aPrimaryDate) return 1;
                    if (!bPrimaryDate) return -1;
                    
                    return aPrimaryDate - bPrimaryDate; // Ascending order
                });
                
                // Transform stories into roadmap format
                const crossTeamData = IMOViewGenerator.transformStoriesToRoadmapData(stories, searchQuery, searchRange);
                
                // Generate roadmap HTML - use embedded mode but extract content only
                const generator = new RoadmapGenerator(crossTeamData.roadmapYear);
                const fullRoadmapHtml = generator.generateRoadmap(crossTeamData, true, false); // embedded=true, enableEditing=false
                
                // Extract just the content without the wrapper and embedded CSS
                const contentMatch = fullRoadmapHtml.match(/<div class="roadmap-wrapper">[^>]*<link[^>]*>(.*)<\/div>/s);
                const roadmapHtml = contentMatch ? contentMatch[1] : fullRoadmapHtml;
                
                // Clean up the HTML (remove BTL sections, etc.)
                const cleanedHtml = cleanRoadmapHtml(roadmapHtml);
                
                // Display in results container with an inline Stats button above the roadmap
                const contentArea = document.getElementById('contentArea');
                const queryLabelSafe = (searchQuery || '').toString();
                contentArea.innerHTML = `
                    <div class="results-container" style="margin-bottom: 0; padding-bottom: 0;">
                        <div class="search-results-header" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #007cba;">
                            <h2 style="margin: 0 0 10px 0; color: #007cba; font-size: 24px;">üîç Search Results</h2>
                            <div class="search-summary" style="color: #666; font-size: 14px; margin: 5px 0;">
                                Found <strong>${stories.length}</strong> ${stories.length === 1 ? 'story' : 'stories'} 
                                across <strong>${new Set(stories.map(s => s.teamName)).size}</strong> ${new Set(stories.map(s => s.teamName)).size === 1 ? 'team' : 'teams'} 
                                for "<strong>${queryLabelSafe}</strong>": (${Array.from(new Set(stories.map(s => s.teamName))).sort().join(', ')})
                            </div>
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                                <label style="display: flex; align-items: center; gap: 5px; font-weight: normal; font-size: 14px;">
                                    <input type="checkbox" id="search-force-text-below-toggle" style="width: auto; flex-shrink: 0;" onchange="handleSearchForceTextBelowToggle()" ${searchTempForceTextBelow ? 'checked' : ''}>
                                    Force all text boxes below stories
                                </label>
                            </div>
                        </div>
                        <div style="margin-bottom: 0; padding-bottom: 0;">
                            ${cleanedHtml}
                        </div>
                    </div>
                `;
                
                // Add click handlers to story items after rendering
                setTimeout(() => {
                    addStoryClickHandlers(stories);
                    insertStatsButtonNearHeader();
                }, 100);
                
            } catch (error) {
                
                showMessage('Error displaying results: ' + error.message, 'error');
            }
        }

        // Insert Stats button inside the search results header
        function insertStatsButtonNearHeader() {
            try {
                const container = document.querySelector('.results-container');
                if (!container) return;
                
                // Avoid duplicates
                if (container.querySelector('#inlineSearchStatsBtn')) return;
                
                // Look for the search results header instead of the old roadmap header
                const headerEl = container.querySelector('.search-results-header');
                if (!headerEl) {
                    // If no search results header found, don't add the button
                    return;
                }
                
                // Ensure header is positioned for absolute child
                const computed = window.getComputedStyle(headerEl);
                if (!computed.position || computed.position === 'static') {
                    headerEl.style.position = 'relative';
                }

                // Position button in top-right of search results header
                const bar = document.createElement('div');
                bar.style.cssText = `position: absolute; right: 5px; top: 5px; z-index: 2;`;
                bar.innerHTML = '<button id="inlineSearchStatsBtn" class="search-button" style="min-width: 120px;">üìä Stats</button>';

                headerEl.appendChild(bar);
                
                const btn = bar.querySelector('#inlineSearchStatsBtn');
                if (btn) {
                    btn.addEventListener('click', openSearchStatsModal);
                }
            } catch (e) {
                // Silent fail - stats button is optional
            }
        }
        
        /**
         * Clean roadmap HTML by removing unwanted sections
         */
        function cleanRoadmapHtml(html) {
            let cleaned = html;
            
            // Remove BTL-related content
            cleaned = cleaned.replace(/<div class="swimlane-separator-dashed"><\/div>/g, '');
            cleaned = cleaned.replace(/Below the Line/g, '');
            
            // Remove ALL BTL-related swimlanes with various patterns
            cleaned = cleaned.replace(/<div class="swimlane btl-swimlane[^>]*>[\s\S]*?<\/div>/g, '');
            cleaned = cleaned.replace(/<div class="btl-swimlane[^>]*>[\s\S]*?<\/div>/g, '');
            
            // Remove any swimlane with min-height: 172px (BTL specific height)
            cleaned = cleaned.replace(/min-height:\s*172px;?/g, '');
            
            // Remove the roadmap header to avoid duplicate headers in search results
            cleaned = cleaned.replace(/<div class="header">[\s\S]*?<\/div>/g, '');
            
            // Remove any potential duplicate "Search Results" or similar headers
            cleaned = cleaned.replace(/<h[1-6][^>]*>.*?Search Results.*?<\/h[1-6]>/gi, '');
            cleaned = cleaned.replace(/<h[1-6][^>]*>.*?üîç.*?<\/h[1-6]>/gi, '');
            cleaned = cleaned.replace(/<h[1-6][^>]*>.*?Cross-Team.*?<\/h[1-6]>/gi, '');
            
            // Remove extra bottom padding/margins that cause white space
            cleaned = cleaned.replace(/margin-bottom:\s*[^;]+;?/g, '');
            cleaned = cleaned.replace(/padding-bottom:\s*[^;]+;?/g, '');
            cleaned = cleaned.replace(/<div[^>]*style="[^"]*margin-bottom[^"]*"[^>]*>[\s\S]*?<\/div>/g, '');
            
            return cleaned;
        }
        
        /**
         * Show loading state
         */
        function showLoadingState(message = 'Loading...') {
            const contentArea = document.getElementById('contentArea');
            contentArea.innerHTML = `
                <div class="loading-state">
                    <div class="loading-spinner"></div>
                    <h3>${message}</h3>
                </div>
            `;
        }
        
        /**
         * Show message (info, warning, error)
         */
        function showMessage(message, type = 'info') {
            const contentArea = document.getElementById('contentArea');
            
            let icon = 'üìù';
            let color = '#007cba';
            
            if (type === 'warning') {
                icon = '‚ö†Ô∏è';
                color = '#856404';
            } else if (type === 'error') {
                icon = '‚ùå';
                color = '#721c24';
            }
            
            contentArea.innerHTML = `
                <div class="blank-state">
                    <div style="font-size: 48px; margin-bottom: 20px;">${icon}</div>
                    <h2 style="color: ${color};">${message}</h2>
                    <button onclick="showBlankState()" class="secondary" style="margin-top: 20px;">
                        Try Another Search
                    </button>
                </div>
            `;
        }
        
        /**
         * Show blank state
         */
        function showBlankState() {
            const contentArea = document.getElementById('contentArea');
            contentArea.innerHTML = `
                <div class="blank-state" id="blankState">
                    <div class="blank-state-icon">üîç</div>
                    <h2>Cross-Team IMO & Timeline Search</h2>
                    <p>Search across multiple team roadmaps to find stories by IMO number or timeline</p>
                    
                    <p style="font-size: 14px; color: #999;">
                        First select a directory containing roadmap JSON files, then enter your search query
                    </p>
                </div>
            `;
        }
        
        /**
         * Clear all results and return to blank state
         */
        function clearAllResults() {
            currentResults = [];
            lastSearchStories = [];
            lastRoadmapFiles = [];
            showBlankState();
            
            // Disable stats button
            document.getElementById('searchStatsBtn').disabled = true;
            
            // Clear search inputs
            document.getElementById('searchInput').value = '';
            document.getElementById('titleSearchInput').value = '';
            const directorEl = document.getElementById('directorSearchInput');
            if (directorEl) directorEl.value = '';
            
            // Clear date inputs
            const startEl = document.getElementById('startDateInput');
            if (startEl) {
                startEl.value = '';
                startEl.setAttribute('value', '');
            }
            const endEl = document.getElementById('endDateInput');
            if (endEl) {
                endEl.value = '';
                endEl.setAttribute('value', '');
            }
            
            // Reset search mode
            const modeEl = document.getElementById('searchModeSelect');
            if (modeEl) {
                modeEl.value = 'exact';
                updateSearchModeHelp();
            }
            
            // Clear status filter tri-state checkboxes
            Object.keys(statusFilterStates).forEach(filterId => {
                statusFilterStates[filterId] = 'none';
                const checkbox = document.getElementById(filterId);
                if (checkbox) {
                    checkbox.setAttribute('data-state', 'none');
                    checkbox.textContent = '';
                }
            });
            
            // Clear advanced expression
            const advancedExpr = document.getElementById('advancedFilterExpression');
            if (advancedExpr) advancedExpr.value = '';
            
            updateSearchButtonStates();
        }

        // Clear inputs and results from the top button
        function clearAllSearchFields() {
            clearAllResults();
        }
        
        /**
         * Navigate back to roadmap builder
         */
        function goToRoadmapBuilder() {
            window.location.href = 'roadmap-builder.html';
        }

        // Apply additional filters based on other filled inputs (AND semantics)
        function applyAdditionalFilters(stories, roadmapFiles, options = {}) {
            let result = Array.isArray(stories) ? stories.slice() : [];
            const opts = Object.assign({ skipDirector: false, skipIMO: false, skipTitle: false, skipDate: false, skipStatus: false }, options);

            try {
                // Director/VP filter (team-level)
                const directorQuery = document.getElementById('directorSearchInput')?.value.trim();
                if (!opts.skipDirector && directorQuery) {
                    const matchingRoadmaps = IMOUtility.filterRoadmapsByDirector(roadmapFiles, directorQuery);
                    const allowedTeams = new Set(matchingRoadmaps.map(f => (f.teamData && f.teamData.teamName) || ''));
                    result = result.filter(story => allowedTeams.has(story.teamName));
                }

                // IMO/Timeline filter
                const imoQuery = document.getElementById('searchInput')?.value.trim();
                if (!opts.skipIMO && imoQuery) {
                    result = IMOUtility.searchStories(result, imoQuery);
                }

                // Title filter
                const titleQuery = document.getElementById('titleSearchInput')?.value.trim();
                if (!opts.skipTitle && titleQuery) {
                    result = IMOUtility.searchStoriesByTitle(result, titleQuery);
                }

                // Date filter
                const startDate = document.getElementById('startDateInput')?.value;
                const endDate = document.getElementById('endDateInput')?.value;
                const searchModeEl = document.getElementById('searchModeSelect');
                const searchMode = (searchModeEl && searchModeEl.value) ? searchModeEl.value : 'exact';
                if (!opts.skipDate && (startDate || endDate)) {
                    result = IMOUtility.searchStoriesByDateRange(result, startDate, endDate, searchMode);
                }

                // Status filter - apply if any status filters are active
                if (!opts.skipStatus) {
                    // Check if advanced expression is provided
                    const advancedExpression = document.getElementById('advancedFilterExpression')?.value.trim();
                    
                    if (advancedExpression) {
                        // Use expression-based filtering
                        result = result.filter(story => {
                            const matches = evaluateFilterExpression(advancedExpression, story);
                            // If expression is invalid (null), don't filter
                            return matches === null ? true : matches;
                        });
                    } else {
                        // Use checkbox-based filtering
                        // Get all filter states
                        const filters = {
                            filterNew: statusFilterStates.filterNew,
                            filterDone: statusFilterStates.filterDone,
                            filterCancelled: statusFilterStates.filterCancelled,
                            filterAtRisk: statusFilterStates.filterAtRisk,
                            filterTimeline: statusFilterStates.filterTimeline,
                            filterProposed: statusFilterStates.filterProposed,
                            filterInfo: statusFilterStates.filterInfo,
                            filterTransferredIn: statusFilterStates.filterTransferredIn,
                            filterTransferredOut: statusFilterStates.filterTransferredOut
                        };
                        
                        // Check if any filters are active (include or exclude)
                        const hasIncludeFilters = Object.values(filters).some(state => state === 'include');
                        const hasExcludeFilters = Object.values(filters).some(state => state === 'exclude');
                        const anyFilterActive = hasIncludeFilters || hasExcludeFilters;
                    
                    if (anyFilterActive) {
                        // Use OR logic for checkboxes (simpler without the button)
                        result = result.filter(story => {
                            // Helper function to check story status
                            const hasStatus = (filterKey) => {
                                switch(filterKey) {
                                    case 'filterNew': return story.isNewStory;
                                    case 'filterDone': return story.isDone;
                                    case 'filterCancelled': return story.isCancelled;
                                    case 'filterAtRisk': return story.isAtRisk;
                                    case 'filterTimeline': return story.roadmapChanges && story.roadmapChanges.changes && story.roadmapChanges.changes.length > 0;
                                    case 'filterProposed': return story.isProposed;
                                    case 'filterInfo': return story.isInfo;
                                    case 'filterTransferredIn': return story.isTransferredIn;
                                    case 'filterTransferredOut': return story.isTransferredOut;
                                    default: return false;
                                }
                            };
                            
                            // First, check all EXCLUDE conditions - these must ALL pass regardless of mode
                            for (const [filterKey, state] of Object.entries(filters)) {
                                if (state === 'exclude' && hasStatus(filterKey)) {
                                    return false; // Story has a status that should be excluded
                                }
                            }
                            
                            // If there are no INCLUDE filters, and we passed all EXCLUDE checks, include the story
                            if (!hasIncludeFilters) {
                                return true;
                            }
                            
                            // OR logic: Story must have at least ONE included status
                            for (const [filterKey, state] of Object.entries(filters)) {
                                if (state === 'include' && hasStatus(filterKey)) {
                                    return true;
                                }
                            }
                            return false;
                        });
                    }
                    }
                }
            } catch (e) {
                
            }

            return result;
        }

        /**
         * Parse and evaluate a filter expression for a story
         * Supports: &&, ||, !, and ( ) with status names
         */
        function evaluateFilterExpression(expression, story) {
            if (!expression || !expression.trim()) return null;
            
            // Tokenize the expression
            const tokens = expression
                .replace(/\(/g, ' ( ')
                .replace(/\)/g, ' ) ')
                .replace(/&&/g, ' && ')
                .replace(/\|\|/g, ' || ')
                .replace(/!/g, ' ! ')
                .split(/\s+/)
                .filter(t => t.length > 0);
            
            let pos = 0;
            
            // Recursive descent parser
            const parseExpression = () => parseOr();
            
            const parseOr = () => {
                let left = parseAnd();
                while (pos < tokens.length && tokens[pos] === '||') {
                    pos++; // consume ||
                    const right = parseAnd();
                    left = left || right;
                }
                return left;
            };
            
            const parseAnd = () => {
                let left = parseNot();
                while (pos < tokens.length && tokens[pos] === '&&') {
                    pos++; // consume &&
                    const right = parseNot();
                    left = left && right;
                }
                return left;
            };
            
            const parseNot = () => {
                if (pos < tokens.length && tokens[pos] === '!') {
                    pos++; // consume !
                    return !parsePrimary();
                }
                return parsePrimary();
            };
            
            const parsePrimary = () => {
                if (pos >= tokens.length) {
                    throw new Error('Unexpected end of expression');
                }
                
                const token = tokens[pos];
                
                // Handle parentheses
                if (token === '(') {
                    pos++; // consume (
                    const result = parseExpression();
                    if (pos >= tokens.length || tokens[pos] !== ')') {
                        throw new Error('Missing closing parenthesis');
                    }
                    pos++; // consume )
                    return result;
                }
                
                // Handle status names
                const statusMap = {
                    'Done': story.isDone,
                    'Cancelled': story.isCancelled,
                    'Timeline': story.roadmapChanges && story.roadmapChanges.changes && story.roadmapChanges.changes.length > 0,
                    'New': story.isNewStory,
                    'AtRisk': story.isAtRisk,
                    'Proposed': story.isProposed,
                    'Info': story.isInfo,
                    'TransferredIn': story.isTransferredIn,
                    'TransferredOut': story.isTransferredOut
                };
                
                // Case-insensitive lookup
                const statusKey = Object.keys(statusMap).find(key => key.toLowerCase() === token.toLowerCase());
                
                if (statusKey !== undefined) {
                    pos++; // consume status name
                    return statusMap[statusKey] || false;
                }
                
                throw new Error(`Unknown status: ${token}`);
            };
            
            try {
                const result = parseExpression();
                if (pos < tokens.length) {
                    throw new Error(`Unexpected token: ${tokens[pos]}`);
                }
                return result;
            } catch (error) {
                console.error('Expression parse error:', error.message);
                return null; // Return null on error to indicate invalid expression
            }
        }

        /**
         * Cycle through tri-state checkbox: none ‚Üí include (‚úì) ‚Üí exclude (!) ‚Üí none
         */
        function cycleFilterState(filterId, event) {
            event.preventDefault();
            event.stopPropagation();
            
            const checkbox = document.getElementById(filterId);
            const currentState = statusFilterStates[filterId];
            
            // Cycle: none ‚Üí include ‚Üí exclude ‚Üí none
            if (currentState === 'none') {
                statusFilterStates[filterId] = 'include';
                checkbox.setAttribute('data-state', 'include');
                checkbox.textContent = '‚úì';
            } else if (currentState === 'include') {
                statusFilterStates[filterId] = 'exclude';
                checkbox.setAttribute('data-state', 'exclude');
                checkbox.textContent = '!';
            } else {
                statusFilterStates[filterId] = 'none';
                checkbox.setAttribute('data-state', 'none');
                checkbox.textContent = '';
            }
            
            applyStatusFilters();
        }

        /**
         * Apply status filters to current search results
         */
        function applyStatusFilters() {
            try {
                // Re-filter the last search results with the new status filters
                if (lastSearchStories && lastSearchStories.length > 0) {
                    const filteredStories = applyAdditionalFilters(lastSearchStories, lastRoadmapFiles, {});
                    
                    // Get the current search parameters to determine which range to use
                    const startDate = document.getElementById('startDateInput')?.value;
                    const endDate = document.getElementById('endDateInput')?.value;
                    const searchModeEl = document.getElementById('searchModeSelect');
                    const searchMode = (searchModeEl && searchModeEl.value) ? searchModeEl.value : 'exact';
                    
                    // Create search range info if dates exist
                    let searchRange = null;
                    if (startDate || endDate) {
                        searchRange = {
                            startDate: startDate || 'N/A',
                            endDate: endDate || 'N/A',
                            mode: searchMode
                        };
                    }
                    
                    // Display the filtered results
                    displaySearchResults(filteredStories, 'Filtered Results', searchRange);
                    currentResults = filteredStories;
                }
            } catch (e) {
                console.error('Error applying status filters:', e);
                showMessage('Error applying filters', 'error');
            }
        }

        /**
         * Handle date range picker change
         */
        /**
         * Set date range to current year (01/01 to 31/12)
         */
        function setCurrentYearRange() {
            const currentYear = new Date().getFullYear();
            const startDateInput = document.getElementById('startDateInput');
            const endDateInput = document.getElementById('endDateInput');
            
            // Set to ISO format for date inputs (YYYY-MM-DD)
            startDateInput.value = `${currentYear}-01-01`;
            endDateInput.value = `${currentYear}-12-31`;
            
            // Enable the search button
            updateSearchButtonStates();
        }
        
        function handleDateRangeChange(event) {
            updateSearchButtonStates();
        }

        /**
         * Update search button enabled states
         */
        function updateSearchButtonStates() {
            const imoSearchBtn = document.getElementById('imoSearchBtn');
            const titleSearchBtn = document.getElementById('titleSearchBtn');
            const dateRangeSearchBtn = document.getElementById('dateRangeSearchBtn');
            const directorSearchBtn = document.getElementById('directorSearchBtn');
            
            const hasDirectory = !!selectedDirectory;
            const hasImoInput = document.getElementById('searchInput').value.trim().length > 0;
            const hasTitleInput = document.getElementById('titleSearchInput').value.trim().length > 0;
            const hasDirectorInput = document.getElementById('directorSearchInput').value.trim().length > 0;
            const hasStartDate = document.getElementById('startDateInput').value.length > 0;
            const hasEndDate = document.getElementById('endDateInput').value.length > 0;
            const hasAnyDate = hasStartDate || hasEndDate;
            
            imoSearchBtn.disabled = !hasDirectory || !hasImoInput;
            titleSearchBtn.disabled = !hasDirectory || !hasTitleInput;
            dateRangeSearchBtn.disabled = !hasDirectory || !hasAnyDate;
            directorSearchBtn.disabled = !hasDirectory || !hasDirectorInput;
        }

        /**
         * Update search mode help text based on selected mode
         */
        function updateSearchModeHelp() {
            const searchMode = document.getElementById('searchModeSelect').value;
            const helpElement = document.getElementById('searchModeHelp');
            
            if (searchMode === 'exact') {
                helpElement.textContent = 'Exact: Stories must start/end exactly on the specified dates.';
            } else if (searchMode === 'exact-7days') {
                helpElement.textContent = 'Exact +/- 7 Days: Start date to +7 days forward only, end date +/- 7 days buffer.';
            } else if (searchMode === 'current-year') {
                const currentYear = new Date().getFullYear();
                helpElement.textContent = `Current Year: Searches all stories in ${currentYear} (auto-fills 01/01/${currentYear} to 31/12/${currentYear}).`;
                // Auto-populate with current year dates
                setCurrentYearRange();
            } else {
                helpElement.textContent = 'Range: Stories must start on or after start date AND end on or before end date.';
            }
        }

        /**
         * Perform date range search
         */
        async function performDateRangeSearch() {
            try {
                if (!selectedDirectory) {
                    showMessage('Please select a directory first', 'warning');
                    return;
                }
                
                const startDate = document.getElementById('startDateInput').value;
                const endDate = document.getElementById('endDateInput').value;
                const searchMode = document.getElementById('searchModeSelect').value;
                
                if (!startDate && !endDate) {
                    showMessage('Please select at least one date', 'warning');
                    return;
                }
                
                // Build search message
                let searchMessage = 'Searching for stories ';
                let queryLabel = '';
                let modeText;
                let modeLabel;
                
                if (searchMode === 'exact') {
                    modeText = 'exactly';
                    modeLabel = 'Exact';
                } else if (searchMode === 'exact-7days') {
                    modeText = 'with +/- 7 day buffer';
                    modeLabel = 'Exact +/- 7 Days';
                } else if (searchMode === 'current-year') {
                    modeText = 'in current year';
                    modeLabel = 'Current Year';
                } else {
                    modeText = 'in range';
                    modeLabel = 'Range';
                }
                
                if (startDate && endDate) {
                    searchMessage += `${modeText} between ${startDate} and ${endDate}...`;
                    queryLabel = `${modeLabel}: ${startDate} to ${endDate}`;
                } else if (startDate) {
                    searchMessage += `${modeText} starting ${startDate}...`;
                    queryLabel = `${modeLabel} Start: ${startDate}`;
                } else {
                    searchMessage += `${modeText} ending ${endDate}...`;
                    queryLabel = `${modeLabel} End: ${endDate}`;
                }
                
                showMessage(searchMessage, 'info');
                
                // Scan directory and search
                const roadmapFiles = await IMOUtility.scanRoadmapDirectory(selectedDirectory);
                if (roadmapFiles.length === 0) {
                    showMessage('No roadmap JSON files found in the selected directory', 'warning');
                    return;
                }
                
                const allStories = IMOUtility.aggregateStoriesAcrossTeams(roadmapFiles);
                let matchingStories = IMOUtility.searchStoriesByDateRange(allStories, startDate, endDate, searchMode);
                
                // Store base search results before filtering for potential re-filtering
                lastSearchStories = matchingStories.slice();
                lastRoadmapFiles = roadmapFiles;
                
                matchingStories = applyAdditionalFilters(matchingStories, roadmapFiles, { skipDate: true });
                
                if (matchingStories.length === 0) {
                    showMessage(`No stories found for the specified date range`, 'info');
                    return;
                }
                
                // Store results and display
                currentResults = matchingStories;
                displaySearchResults(matchingStories, queryLabel, { startDate, endDate });
                
                // Enable header stats button
                document.getElementById('searchStatsBtn').disabled = false;
                
            } catch (error) {
                
                showMessage('Search error: ' + error.message, 'error');
            }
        }

        /**
         * Perform IMO search (renamed for clarity)
         */
        async function performIMOSearch() {
            await performSearch();
        }
        
        /**
         * Perform title search
         */
        async function performTitleSearch() {
            try {
                // Validate inputs
                if (!selectedDirectory) {
                    alert('Please select a directory first');
                    return;
                }
                
                const searchQuery = document.getElementById('titleSearchInput').value.trim();
                if (!searchQuery) {
                    alert('Please enter a search query');
                    return;
                }
                
                // Show loading state
                showLoadingState(`Searching for stories with title containing "${searchQuery}"...`);
                
                // Scan directory for roadmap files
                const roadmapFiles = await IMOUtility.scanRoadmapDirectory(selectedDirectory);
                
                if (roadmapFiles.length === 0) {
                    showMessage('No roadmap JSON files found in the selected directory', 'warning');
                    return;
                }
                
                // Extract and search stories by title
                const allStories = IMOUtility.aggregateStoriesAcrossTeams(roadmapFiles);
                
                let matchingStories = IMOUtility.searchStoriesByTitle(allStories, searchQuery);
                
                // Store base search results before filtering for potential re-filtering
                lastSearchStories = matchingStories.slice();
                lastRoadmapFiles = roadmapFiles;
                
                matchingStories = applyAdditionalFilters(matchingStories, roadmapFiles, { skipTitle: true });
                
                if (matchingStories.length === 0) {
                    showMessage(`No stories found with title containing "${searchQuery}"`, 'info');
                    return;
                }
                
                // Store results and display
                currentResults = matchingStories;
                displaySearchResults(matchingStories, `Title: "${searchQuery}"`);
                
                // Enable stats button
                document.getElementById('searchStatsBtn').disabled = false;
                
            } catch (error) {
                
                showMessage('Search error: ' + error.message, 'error');
            }
        }
        
                function handleDirectorSearchKeyPress(event) {
            if (event.key === 'Enter') {
                performDirectorSearch();
            }
        }

        async function performDirectorSearch() {
            try {
                if (!selectedDirectory) {
                    alert('Please select a directory first');
                    return;
                }

                const query = document.getElementById('directorSearchInput').value.trim();
                if (!query) {
                    alert('Please enter a leadership name (Director/VP, EM, or PM)');
                    return;
                }

                showLoadingState(`Searching roadmaps for leadership containing "${query}"...`);

                const roadmapFiles = await IMOUtility.scanRoadmapDirectory(selectedDirectory);
                const matchingRoadmaps = IMOUtility.filterRoadmapsByDirector(roadmapFiles, query);

                if (!matchingRoadmaps.length) {
                    showMessage(`No roadmaps found for leadership containing "${query}"`, 'info');
                    return;
                }

                // Get all stories from the matching roadmaps
                const allStories = IMOUtility.aggregateStoriesAcrossTeams(matchingRoadmaps);
                
                // Store base search results before filtering for potential re-filtering
                lastSearchStories = allStories.slice();
                lastRoadmapFiles = roadmapFiles;
                
                // Apply additional filters if other search fields are filled
                let filteredStories = allStories;
                filteredStories = applyAdditionalFilters(filteredStories, roadmapFiles, { skipDirector: true });

                if (!filteredStories.length) {
                    showMessage(`No stories found for leadership "${query}"`, 'info');
                    return;
                }

                currentResults = filteredStories;
                displaySearchResults(filteredStories, `Leadership: "${query}"`);
                
                // Enable stats button
                document.getElementById('searchStatsBtn').disabled = false;
            } catch (error) {
                
                showMessage('Search error: ' + error.message, 'error');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Check if modal exists and is properly structured
            const modal = document.getElementById('storyDetailsModal');
            if (!modal) {
                
            }
            
            // Add input listeners for real-time button state updates
            document.getElementById('searchInput').addEventListener('input', updateSearchButtonStates);
            document.getElementById('titleSearchInput').addEventListener('input', updateSearchButtonStates);
            document.getElementById('directorSearchInput').addEventListener('input', updateSearchButtonStates);
            if (document.getElementById('dateInput')) {
                document.getElementById('dateInput').addEventListener('change', updateSearchButtonStates);
            }
            if (document.getElementById('startDateInput')) {
                document.getElementById('startDateInput').addEventListener('change', updateSearchButtonStates);
            }
            
            // Focus on search input if directory is already selected
            if (selectedDirectory) {
                document.getElementById('searchInput').focus();
            }
        });
    </script>
</body>
</html>